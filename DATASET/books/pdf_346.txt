 LOCAL GENERATOR "diviser pour régner" pour l’extraction des traverses minimales d’un hypergraphe M Nidhal Jelassi Christine Largeron Sadok Ben Yahia Université Jean Monnet Saint Etienne France nidhal jelassi christine largeron univ st etienne fr Faculté des Sciences de Tunis Tunis Tunisia nidhal jelassi sadok benyahia fst rnu tn Résumé Du fait qu’elles apportent des solutions dans de nombreuses applica tions les traverses minimales des hypergraphes ne cessent de susciter l’intérêt de la communauté scientifique et le développement d’algorithmes pour les calculer Dans cet article nous présentons une nouvelle approche pour l’optimisation de l’extraction des traverses minimales basée sur les notions d’hypergraphe partiel et de traverses minimales locales selon une stratégie diviser pour régner Nous introduisons aussi un nouvel algorithme appelé LOCAL GENERATOR pour le calcul des traverses minimales Les expérimentations effectuées sur divers jeux de données ont montré l’intérêt de notre approche notamment sur les hyper graphes ayant un nombre de transversalité élevé et renfermant un nombre très important de traverses minimales Mots clés Hypergraphe traverse minimale nombre de transversalité hyper graphe partiel 1 Introduction Bien que réputé comme singulièrement difficile et considéré comme NP complet le pro blème du calcul des traverses minimales d’un hypergraphe a suscité l’intérêt de la communauté scientifique Berge 1989 Kavvadias et Stavropoulos 2005 Hébert et al 2007 Murakami et Uno 2013 Toda 2013 Cet intérêt pour les traverses minimales est dû au fait qu’elles présentent une solution pour de nombreuses applications dans des domaines variés tel que la cryptographie le web sémantique l’e commerce etc Hagen 2008 La principale difficulté que pose l’extraction des traverses minimales réside dans le nombre exponentiel de ces dernières même quand l’hypergraphe d’entrée est simple À titre d’exemple considérons l’hypergraphe H = X ξ avec l’ensemble des sommets X = x1 x2 x2n et l’ensemble des hyperarêtes ξ = {x1 x2} {x3 x4} {x2n−1 x2n} Le nombre de traverses minimales est égal à 2n tandis que le nombre de sommets est égal à 2n Les algorithmes d’extraction des traverses minimales les plus performants sont des amélio rations de l’algorithme de Berge 1989 Ce dernier traite les hyperarêtes une à une en calculant à chaque itération i les traverses minimales de l’hypergraphe constitué par les i èmes hyper arêtes considérées Avec pour objectif d’optimiser le calcul des traverses minimales notre ap proche repose sur cette idée en usant du paradigme "diviser pour régner" Le principe consiste 245 LOCAL GENERATOR "diviser pour régner" pour l’extraction des traverses minimales à réduire ce nombre d’itérations en partitionnant l’hypergraphe en un nombre précis d’hyper graphes partiels équivalent au nombre de transversalité de l’hypergraphe d’entrée H A partir de chaque hypergraphe partiel Hi nous calculons alors ce que nous appelons les traverses minimales locales à Hi Le produit cartésien de ces traverses minimales locales correspondra alors à un ensemble de traverses de H qui seront soumises à une vérification de la minima lité pour être considérées comme des traverses minimales En outre pour un hypergraphe H avec un nombre de transversalité égal à k le fait de partitionner H en k hypergraphes Hi per met d’éliminer le test de la minimalité pour les ensembles de sommets de taille k qui seront considérés comme traverses minimales de H sans aucun autre calcul supplémentaire Cet article est organisé comme suit dans la section 2 nous reviendrons sur différents algo rithmes proposés dans la littérature pour calculer les traverses minimales d’un hypergraphe Ensuite dans la section 3 nous rappelons des notions clés issues de la théorie des graphes et de la fouille de données que nous combinerons pour introduire notre approche basée sur la notion de traverse minimale locale et d’hypergraphe partiel La section 4 présentera notre ap proche pour le calcul des traverses minimales à travers un algorithme original appelé LOCAL GENERATOR Enfin une étude expérimentale sur des hypergraphes aléatoires sera décrite dans la section 5 2 Etat de l’art Berge a été le premier à proposer un algorithme dédié à l’extraction des traverses minimales mais cette solution est impraticable sur des hypergraphes de grande taille car elle nécessite le stockage des traverses minimales temporaires calculées après chaque ajout d’une nouvelle hyperarête En effet l’algorithme de Berge commence par calculer l’ensemble des traverses minimales de la première hyperarête avant de le mettre à jour en ajoutant incrémentalement les autres hyperarêtes une à une D’après Hagen 2008 et Takata 2007 l’algorithme de Berge présente une complexité super polynomiale en la taille de l’entrée et de la sortie Récemment Boros et al 2008 ont prouvé que le temps d’exécution de l’algorithme avait une borne supé rieure sub exponentielle Plusieurs travaux ont ensuite tenté d’améliorer l’algorithme de Berge parmi lesquels on peut citer ceux de Bailey et al 2003 Dong et Li 2005 et Kavvadias et Stavropoulos 2005 L’approche la plus performante est celle de ces derniers qui pour remédier à la principale la cune de l’algorithme pionner à savoir une consommation excessive de mémoire ont proposé une technique consistant à combiner les sommets qui appartiennent aux mêmes hyperarêtes à chaque itération de l’algorithme Alors que l’algorithme de Berge effectue un parcours en lar geur de l’arbre des traverses minimales Kavvadias et al proposent un parcours en profondeur de l’hypergraphe d’entrée en introduisant la notion de noeud généralisé qui représentent un ensemble de sommets appartenant aux mêmes hyperarêtes et qui est mis à jour Enfin notons que dans cet algorithme la vérification de la minimalité est effectuée à travers la notion de noeud approprié En l’assimilant à un problème de dualisation de fonctions booléennes et monotones Fred man et Khachiyan ont proposé un algorithme incrémental pour l’extraction des traverses mi nimales en vérifiant si deux formules f et g sont mutuellement duales i e si f x = ḡ x̄ Cette approche a été reprise de différentes manières par Eiter et Gootlob ou encore par Boros Eiter et al 2002 Boros et al 2003 La version de ce dernier généralise le principe de la 246 M N Jelassi et al dualisation dans la mesure où les formules ne traitent plus que des variables booléennes mais manipulent désormais aussi des variables entières bornées Adoptant un parcours en largeur d’abord et opérant par niveau l’algorithme MTMINER de Hébert et al 2007 met à contribution les récents travaux sur l’extraction des motifs Il commence par générer et tester les candidats de taille 1 i e les sommets avant de générer à chaque niveau un nouveau candidat X et calculer l’ensemble G X des hyperarêtes qui ne renferment aucun sommet de X En ce sens si le cardinal de G X est nul le candidat X est considéré comme une traverse qui est minimale si elle vérifie la propriété d’anti monotonie de la minimalité dans les classes d’équivalence Outre cette stratégie d’élagage Hebert et al in troduisent une deuxième propriété selon laquelle aucun sur ensemble d’une traverse minimale ne peut représenter à son tour une traverse minimale Les algorithmes MMCS et RS de type SHD ont été proposés plus récemment par Murakami et Uno Ils adopent une stratégie en profondeur et sont basés respectivement sur le principe du branch and bound et sur celui du reverse search Les auteurs exploitent aussi une nouvelle technique pour vérifier la minimalité des traverses calculées au moyen d’hyperarête s cri tique s Murakami et Uno 2013 Actuellement ces algorithmes sont considérés dans la littérature comme les plus efficaces aussi bien en termes de temps d’exécution qu’en consom mation mémoire notamment sur des hypergraphes de grande taille Le dernier algorithme en date dédié au calcul des traverses minimales est celui de Toda Il fait appel à des structures de données compressés BDD diagramme de décision binaire 1 et ZDD zéro diagramme de décision binaire supprimée 2 Ces structures sont respectivement une représentation graphique des fonctions booléennes et une variété de BDD spécialisées pour les bases éparses Les expérimentation de Toda Toda 2013 ont monté que son algorithme est hautement compétitif avec les algorithmes existants en particulier avec les algorithmes SHD Enfin signalons que d’autres travaux se sont intéressés au calcul des traverses minimales approchées dont l’objectif est de produire un ensemble de traverses minimales de façon à ce que chacune n’intersecte qu’un ensemble donné d’hyperarêtes ξ′ ⊂ ξ Ruchkys et Song 2002 Abreu et van Gemund 2009 Durand et Quafafou 2013 Notre approche qui repose sur le paradigme "diviser pour régner" est une extension de l’algorithme de Berge Alors que dans ce dernier ainsi que dans les améliorations qui en ont été proposées l’idée est de traiter les hyperarêtes une à une dans cet article nous proposons de traiter les hyperarêtes ensemble par ensemble L’hypergraphe d’entrée H se trouve alors partitionné en un nombre d’hypergraphes partiels égal au nombre de transversalité k de H Chaque hypergraphe partiel renferme des traverses minimales locales et le produit cartésien combiné à un test de la minimalité permet de retrouver l’ensemble des traverses minimales de H Le choix du nombre d’hypergraphes partiels n’est pas arbitraire puisqu’il garantit que les traverses dont la taille est égale à k peuvent être directement considérées comme des traverses minimales de H 3 Définitions et notations Dans cette section nous proposons de présenter des définitions et notations que nous uti liserons tout au long des sections suivantes Pour aboutir à notre approche d’extraction des 1 binary decision diagram 2 zero suppressed binary decision diagrams 247 LOCAL GENERATOR "diviser pour régner" pour l’extraction des traverses minimales traverses minimales basée sur la notion des traverse minimale locale nous avons combiné des concepts de la théorie des hypergraphes hypergraphe traverse nombre de transversalité avec d’autres de la fouille de données ensemble essentiel support Le nombre de transversalité d’un hypergraphe est la notion clé de cette section autour de laquelle est bâtie notre approche Définition 1 HYPERGRAPHE SIMPLE Berge 1989 Soit H = X ξ avec X = {x1 x2 xn} un ensemble fini d’éléments et ξ = {e1 e2 em} une famille de parties de X H constitue un hypergraphe simple sur X si 1 ei 6= ∅ i ∈ {1 m} 2 ⋃ i=1 m ei = X 3 ∀ ei ∈ ξ et ej ∈ ξ ei ⊆ ej ⇒ i = j Les éléments de X sont appelés sommets et ceux de ξ hyperarêtes de l’hypergraphe et dans la suite nous ne considérerons que des hypergraphes simples Exemple 1 La figure 1 illustre un hypergraphe simple H = X ξ tel que X = 1 2 3 4 5 6 7 8 9 et ξ = { e1 e2 e3 e4 e5 e6 } avec e1 = {1 2} e2 = {2 3 7} e3 = {3 4 5} e4 {4 6} e5 = {6 7 8} et e6 = {7 9} 1 2 3 4 5 6 7 8 9 {1 2} 1 1 0 0 0 0 0 0 0 {2 3 7} 0 1 1 0 0 0 1 0 0 {3 4 5} 0 0 1 1 1 0 0 0 0 {4 6} 0 0 0 1 0 1 0 0 0 {6 7 8} 0 0 0 0 0 1 1 1 0 {7 9} 0 0 0 0 0 0 1 0 1 FIG 1 Un exemple d’hypergraphe H = X ξ et la matrice d’incidence IMH correspondante Définition 2 TRAVERSE MINIMALE ET NOMBRE DE TRANSVERSALITÉ Berge 1989 Soit un hypergraphe H = X ξ tel que X est l’ensemble de sommets et ξ = {e1 e2 em} est l’ensemble des hyperarêtes de H T ⊂ X est une traverse de H si T ⋂ ei 6= ∅ ∀i = 1 m γH désigne l’ensemble des traverses définies sur H Une traverse T de γH est dite minimale si T0 ⊂ T s t T0 ∈ γH On notera MH l’ensemble des traverses minimales définies sur H Le nombre minimum de sommets d’une traverse est appelé le nombre de transversalité de l’hypergraphe H et on le désigne par τ H = min {|T | s t T ∈ MH} De plus d’après Berge 1989 MH représente les hyperarêtes de l’hypergraphe transversal correspondant à H et défini sur X Exemple 2 Dans l’exemple illustratif de la figure 1 l’ensemble MH de l’hypergraphe est { {1 4 7} {2 4 7} {2 5 6 7} {2 5 6 9} {2 4 8 9} {2 4 6 9} {2 3 6 7} {2 3 6 9} {1 5 6 7} {1 3 6 7} {1 3 6 9} et {1 3 4 8 9} 248 M N Jelassi et al Un hypergraphe H peut être représenté par une matrice d’incidence IMH définie par un tri plet ξ X R où R ⊆ ξ×X est une relation binaire entre les hyperarêtes et les sommets Cette matrice d’incidence IMH associée à l’hypergraphe H = X ξ est définie par ∀xi ∈ X et ∀ej ∈ ξ R ej xi = 1 si xi ∈ ej et R ej xi = 0 sinon La Table de la figure 1 représente la matrice d’incidence associée à l’hypergraphe H Définition 3 SUPPORT D’UN ENSEMBLE DE SOMMETS Soit l’hypergraphe H = X ξ et X un sous ensemble de X Nous définissons Supp X comme le nombre d’hyperarêtes de H renfermant au moins un élément de X Supp X = |{e ∈ ξ|∃x ∈ X ∧ R e x = 1}| Ainsi l’ensemble X peut être vu comme une disjonction de sommets x1 ∨ x2 ∨ ∨ xn tel que la présence d’un seul sommet de X suffit à affirmer que X satisfait une hyperarête donnée indépendamment des autres sommets Définition 4 ENSEMBLE ESSENTIEL DE SOMMETS Casali et al 2005 Soit l’hypergraphe H = X ξ et X ⊆ X X représente un ensemble essentiel de sommets si et seulement si Supp X > max{Supp X\x | ∀x ∈ X} Il est important de souligner que les ensembles essentiels extraits à partir d’une matrice d’incidence vérifient la propriété d’idéal ordre i e si X est un ensemble essentiel alors ∀Y ⊂ X Y est aussi un ensemble essentiel De plus la notion de traverse peut être redéfinie par le biais du support d’un ensemble de sommets et de la notion d’ensemble essentiel selon la proposition 1 Proposition 1 TRAVERSE MINIMALE Un sous ensemble de sommets X ⊆ X est une traverse minimale de l’hypergraphe H si X est essentiel et si son support est égal au nombre des hyperarêtes de H autrement dit X est un ensemble essentiel tel que Supp X =|ξ| Preuve 1 Soit X un ensemble essentiel de sommets tel que Supp X =|ξ| Par conséquent X ⋂ ei 6= ∅ ∀ei ∈ ξ i = 1 m Donc d’après la définition 2 X est une traverse La minimalité de X tient à son "essentialité" En effet puisque X est essentiel alors son support est strictement supérieur à celui de ses sous ensembles directs Par conséquent X1 ⊂ X s t Supp X1 =|ξ| X est donc une traverse minimale Définition 5 UNION ET PRODUIT CARTÉSIEN Berge 1989 Soit H = X ξ et G = X ′ ξ′ deux hypergraphes tels que ξ = {ξ1 ξ2 ξm} et ξ′ = {ξ′1 ξ′2 ξ′m} H ∪ G représente l’union de H et G Le résultat de cette union est un hypergraphe dont l’ensemble des sommets est constitué de ceux de H et de G et l’ensemble des hyperarêtes contient celles de H et G qui par souci de simplification sera aussi noté H ∪ G H ∪ G = X ∪ X ′ ξ1 ξ2 ξm ξ′1 ξ′2 ξ′m H ×G représente le produit cartésien des deux hypergraphes dont le résultat est un hyper graphe dont l’ensemble des sommets contient ceux des deux hypergraphes Quant à l’ensemble des hyperarêtes il est aussi noté H ×G et est égal au produit cartésien de ξ et de ξ′ autrement dit à l’union de tous les couples possibles d’hyperarêtes tels que le premier élément appartient à ξ et le deuxième à ξ′ H × G = X ∪ X ′ ξi ∪ ξ′j i = 1 m j = 1 m′ 249 LOCAL GENERATOR "diviser pour régner" pour l’extraction des traverses minimales Proposition 2 Kavvadias et Stavropoulos 2005 Soient H et G deux hypergraphes simples Les traverses minimales de l’hypergraphe H ∪ G sont des couples minimaux au sens de l’inclusion générés par le produit cartésien des ensembles de traverses minimales de H et de G MH∪G = Min{ MH × MG } Définition 6 HYPERGRAPHE PARTIEL Berge 1989 Un hypergraphe partiel H ′ est la restriction d’un hypergraphe H à un sous ensemble d’hy perarêtes ξ′ incluses dans ξ et aux sommets contenus dans ces hyperarêtes Dans le cadre de cet article nous proposons d’étendre la proposition 2 en considérant plus de deux hypergraphes Plus précisément à partir d’un hypergraphe H= X ξ dont le nombre de transversalité τ H est égal à k et d’une traverse minimale T = {x1 x2 xk} de MH de taille k dont les sommets sont numérotés par ordre de support décroissant nous proposons de construire k hypergraphes partiels Hi= Xi ξi i = 1 k tels que – ξ1 = {e ∈ ξ | x1 ∈ e} – X1 = {x ∈ X | x ∈ e ∀e ∈ ξ1 } – ξi = {e ∈ ξ − i−1⋃ j=1 ξj | xi ∈ e} – Xi = {x ∈ X | x ∈ e ∀e ∈ ξi } On peut remarquer que les hypergraphes partiels Hi vérifient de façon évidente les propriétés suivantes – ξi ⊆ ξ – k⋃ i=1 ξi = ξ – e ∈ ξ tel que e ∈ ξi ∩ ξj i 6= j Les traverses minimales de l’hypergraphe partiel Hi sont appelées traverses minimales locales à Hi et leur ensemble est noté par MHi Exemple 3 L’hypergraphe de l’exemple illustratif de la Figure 1 a un nombre de transversalité égal à 3 Sachant que H possède 2 traverses minimales de cardinalité minimale égale à 3 {1 4 7} et {2 4 7} Prenons par exemple {1 4 7} Après avoir ordonné les trois sommets le composant selon un ordre décroissant de support nous obtenons les trois hypergraphes partiels présentés par la Figure 2 tel que H1 ne contient que les hyperarêtes auxquelles appartient le sommet 7 dont le support est égal à 3 H2 ne contient que celles auxquelles appartient 4 dont le support est égal à 2 et H3 contient les hyperarêtes restantes i e celles qui renferment le sommet 1 Il importe de noter qu’en choisissant {2 4 7} au lieu de {1 4 7} le résultat reste le même 4 Traverses minimales locales approche et algorithme Optimiser le calcul de ces traverses minimales revient donc principalement à réduire le nombre de candidats traités Ceci passe par la réduction de la taille de l’hypergraphe d’entrée L’approche proposée dans cet article consiste à construire à partir de l’hypergraphe d’entrée 250 M N Jelassi et al FIG 2 Les 3 hypergraphes partiels dérivés de H H1 H2 et H3 H k hypergraphes partiels H1 H2 Hk tel que k correspond au nombre de transversalité de H Le calcul de l’ensemble des traverses minimales locales MHi de chaque hypergraphe partiel Hi s’en trouve amélioré puisque la taille de Hi est relativement petite par rapport à celle de H Ainsi nous proposons d’effectuer l’union des hypergraphes partiels de façon à dé terminer l’ensemble des traverses minimales MH de H à partir des k uplets minimaux au sens de l’inclusion issus du produits cartésien des ensembles de traverses minimales locales déter minées pour les hypergraphes partiels MHi Dans ce qui suit nous présentons l’algorithme LOCAL GENERATOR dédié au calcul des traverses minimales et basé essentiellement sur les notions de nombre de transversalité et d’hypergraphe partiel 4 1 L’algorithme LOCAL GENERATOR L’algorithme LOCAL GENERATOR dont le pseudo code est décrit par l’Algorithme 1 prend en entrée une matrice d’incidence correspondant à l’hypergraphe d’entrée et fournit en sortie l’ensemble des traverses minimales On suppose que les sommets de l’hypergraphe sont triés par ordre lexicographique LOCAL GENERATOR démarre par un appel à la fonction GETMINTRANSVERSALITY dont le pseudo code est décrit par l’Algorithme 2 Cette fonction recherche une traverse minimale dont la taille est minimale égale au nombre de transversalité de l’hypergraphe Pour ce faire la fonction parcourt les sommets un par un Pour chaque élément xi de X GETMINTRANSVERSALITY supprime de la matrice d’incidence IMH les hyperarêtes de ξ qui contiennent xi La fonction prend ensuite le sommet différent de xi ayant le plus grand support dans IMH et réactualise la matrice de la même manière i e en retirant les hyperarêtes contenant ce dernier sommet Le traitement entre la ligne 11 et la ligne 15 s’ar rête dès que IMH se vide complètement de toute hyperarête Le vecteur Ttmp sert à stocker les sommets supprimés un à un à partir de X pour aboutir à ξ′ = ∅ Si le nombre de sommets de Ttmp est le plus petit obtenu jusque là dans la fonction la cardinalité de Ttmp est stockée dans min et les éléments de Ttmp sont copiés dans T Le traitement est répété pour tous les som mets de X A chaque itération de la boucle de la ligne 5 l’ensemble ξ′ est réinitialisé avec les éléments de ξ et Ttmp est vidé des éléments qu’il renferme Au final GETMINTRANSVERSA LITY retourne la suite de sommets qui a permis de "vider" la matrice d’incidence en un nombre minimum d’étapes Cette suite là contenue dans Ttmp représente une traverse minimale dont la taille est nécessairement égale au nombre de transversalité de l’hypergraphe d’entrée H Une fois le nombre de transversalité calculé et une traverse minimale de taille minimale renvoyée par la fonction GETMINTRANSVERSALITY l’algorithme LOCAL GENERATOR 251 LOCAL GENERATOR "diviser pour régner" pour l’extraction des traverses minimales Algorithme 1 LOCAL GENERATOR Entrées Une matrice d’incidence IMH associée à H = X ξ Sorties MH ensemble des traverses minimales de H début1 initialiser T vecteur 2 T = GETMINTRANSVERSALITY IMH 3 k = T size 4 i = 1 5 tant que i ≤ k faire6 ξi = {e ∈ ξ | T [i] ∈ e} 7 Xi = X ∩ ξi 8 MHi = COMPUTE_TM IMHi 9 i = i + 1 10 γH = MH1 × MH2 × × MHk 11 pour chaque X ∈ γH faire12 si | X | = k alors13 MH = MH ∪ {X} 14 sinon15 si 6 ∃ x ∈ X Supp X = Supp X\x alors16 MH = MH ∪ {X} 17 retourner MH 18 fin19 construit à partir de la matrice d’incidence IMH k hypergraphes partiels et fait appel à la fonction COMPUTE_TM pour construire leurs traverses minimales locales stockées dans MHi ligne 9 Cette fonction 3 prend en entrée une matrice d’incidence associée à un hypergraphe partiel Hi de H et calcule par niveaux l’ensemble des traverses minimales locales à Hi se lon la définition 1 A la fin de la boucle de la ligne 6 LOCAL GENERATOR a déjà calculé les ensembles des traverses minimales locales Le produit cartésien ligne 11 de ces ensembles MHi permet de construire l’ensemble γH Chaque élément de γH issu de ce produit cartésien représente une traverse Il reste à vérifier sa minimalité Un des intérêts de notre décomposition de l’hypergraphe initial est d’éviter de tester la minimalité des éléments de γH dont la cardi nalité est égale à k En effet ces derniers représentent des traverses minimales de H puisqu’il ne peut pas exister une traverse minimale de taille inférieure au nombre de transversalité de H Pour les traverses de taille supérieure à k LOCAL GENERATOR teste la minimalité lignes 15 − 16 suivant la Proposition 1 Si le support d’un candidat X est strictement supérieur au maximum des supports de ses sous ensembles directs alors X est une traverse minimale et est ajouté à MH 3 Dans les expérimentations nous avons utilisé l’algorithme MTMINER pour implémenter cette fonction 252 M N Jelassi et al Algorithme 2 GETMINTRANSVERSALITY Entrées Matrice d’incidence IMH associée à H Sorties T Vecteur contenant une plus petite traverse minimale initialiser Ttmp vecteur 1 initialiser T vecteur 2 T = Ttmp = ∅ 3 min = | ξ | 4 foreach xi ∈ X do5 Ttmp clear 6 Ttmp add xi 7 ξ′ = ξ 8 ξ′ = ξ′ | {e ∈ ξ′ | xi ∈ e} | 9 while ξ′ 6= ∅ do10 Max − item = xj ∈ X s t | {e ∈ ξ′ | xj ∈ e} | = max11 {| {e ∈ ξ′ | xl ∈ e} | xl ∈ X} Ttmp add Max − item 12 ξ′ = ξ′ | {e ∈ ξ′ | Max − item ∈ e} | 13 if min > | Ttmp | then14 min = | Ttmp | 15 T = Ttmp 16 retourner T 17 5 Etude Expérimentale Différentes expérimentations ont été menées sur des jeux de données variés afin d’éva luer l’algorithme LOCAL GENERATOR Le premier lot de jeux de données considérés dans cette étude expérimentale comporte des hypergraphes générés à partir des bases de données "Accidents" 4 et "Connect 4" 5 alors que le deuxième lot contient des hypergraphes aléatoires générés à travers le "random hypergraph generator" implementé par Boros et al Boros et al 2003 en fonction du nombre de sommets du nombre d’hyperarêtes et de la taille minimale des hyperarêtes |X | |ξ| τ H |MH | SHD KS LOCAL GENERATOR Accidents1 81 990 1 1 961 0 301 8 620 6 519 Accidents2 336 10968 2 17 486 2 787 11 073 Connect Win 79 12800 2 4 587 967 88 491 200 501 TAB 1 Caractéristiques et temps de traitement des hypergraphes Accidents et Connect 4 archive ics uci edu ml 5 fimi cs helsinki fi data 253 LOCAL GENERATOR "diviser pour régner" pour l’extraction des traverses minimales Le tableau 1 détaille les caractéristiques de chacun des hypergraphes du premier lot consi déré La première et la seconde colonne correspond respectivement au nombre de sommets et au nombre d’hyperarêtes des différents hypergraphes La troisième colonne indique le nombre de transversalité alors que la quatrième colonne indique le nombre de traverses minimales que renferme chaque hypergraphe Ces trois hypergraphes ont été traités par trois algorithmes l’algorithme SHD de Mura kami et Uno 2013 l’algorithme KS de Kavvadias et Stavropoulos 2005 et notre algorithme LOCAL GENERATOR Le tableau 1 récapitule aussi les temps d’exécution de chaque algorithme sur chaque hypergraphe L’algorithme SHD étant déjà le plus rapide parmi tout ceux proposés dans la littérature il l’est aussi sur ces trois jeux de données LOCAL GENERATOR est moins rapide alors que KS ne parvient pas à traiter les hypergraphes Accidents2 et Connect Win Le fait que LOCAL GENERATOR ait des temps de traitement plus grands que SHD s’explique par le faible nombre de transversalité des 3 hypergraphes qui varie entre 1 et 2 comme le montre le tableau 1 Dans ce cas le partitionnement de l’hypergraphe d’entrée en hypergraphes par tiels ne permet pas d’optimiser convenablement le calcul des traverses minimales La stratégie "diviser pour régner" n’est pas pertinente lorsque la taille de la plus petite traverse minimale d’un hypergraphe donné est très petite Extraire directement les traverses minimales sur l’hy pergraphe considéré s’avère plus judicieux que de passer par les traverses minimales locales |X | |ξ| τ H |MH | SHD KS LOCAL GENERATOR H1 78 50 8 3 179 102 150 1920 337 3911 431 1500 269 H2 95 51 9 5 040 431 550 3608 182 2399 088 H3 119 91 4 4 186 560 000 3115 226 1918 101 H4 159 142 20 7 158 203 125 5509 455 4275 364 TAB 2 Caractéristiques et temps de traitement des hypergraphes aléatoires Le Tableau 2 récapitule les caractéristiques des différents hypergraphes que nous avons générés Ces données synthétiques ont été générés en fonction des probabilités minimale et maximale d’appartenance d’un sommet aux hyperarêtes dans l’hypergraphe Si les nombres de sommets et d’hyperarêtes ne sont pas très élévés ces hypergraphes renferment néanmoins un très grand nombre de traverses minimales qui varie entre 7 158 203 125 et 3 179 102 150 Le nombre de transversalité τ H est aussi élevé en comparaison avec les hypergraphes du Ta bleau 1 Ceci favorise donc notre approche puisque les hypergraphes d’entrée sont partitionnés en un nombre important de petits hypergraphes partiels et de ce fait les traverses minimales de taille égale à τ H y sont plus nombreuses épargnant ainsi à notre algorithme le test de la minimalité Les temps d’exécution récapitulés dans le tableau 2 montrent que l’algorithme LOCAL GENERATOR présente des temps plus intéressants que ceux obtenus par les algo rithmes KS et SHD Notons que l’algorithme de Kavvadias et Stavropoulos 2005 ne parvient à extraire les traverses minimales que sur H1 Les temps d’exécution supérieurs à 1500 se condes peuvent s’expliquer par le nombre élevé de traverses minimales calculées L’écart entre LOCAL GENER ATOR et SHD varie entre 420 et 1234 secondes La différence de performances entre les tableaux 1 et 2 permet de dresser un profil des types d’hypergraphes sur lesquels notre approche est plus performante En effet LOCAL GENERATOR présente des temps intéressants 254 M N Jelassi et al dès que la taille des plus petites traverses minimales de l’hypergraphe d’entrée est élevée ce qui lui permet de partitionner l’hypergraphe en plusieurs hypergraphes partiels De plus le nombre de traverses minimales est très important Sur des hypergraphes renfer mant peu de traverses minimales LOCAL GENERATOR peine à se montrer efficace puisque le nombre de traverses minimales devient négligeable par rapport au nombre de candidats traités et testés Cette constatation est confirmée par le tableau 2 en observant les hypergraphes H1 et H4 Quand le nombre de traverses minimales a pratiquement doublé l’écart en secondes est passé de 420 à 1234 entre les deux algorithmes 6 Conclusion Dans cet article nous avons introduit une nouvelle approche pour le calcul des traverses minimales d’un hypergraphe Cette approche repose sur le paradigme "diviser pour régner" afin de partitionner l’hypergraphe d’entrée en hypergraphes partiels en fonction du nombre de transversalité Le calcul des traverses minimales locales correspondantes à ces hypergraphes partiels permet de retrouver l’ensemble des traverses minimales à travers un produit carté sien combiné à un test de la minimalité Ceci nous a permis d’introduire un nouvel algo rithme LOCAL GENERATOR pour l’extraction des traverses minimales L’étude expérimentale a confirmé l’intérêt de notre approche sur un type précis d’hypergrpahes renfermant des pro priétés données Les résultats obtenus nous incitent par ailleurs à réfléchir à la mise en place d’un algorithme hybride qui s’auto adapte à la valeur du nombre de transversalité i e si ce dernier est jugé petit alors on évitera de générer les hypergraphes partiels Par ailleurs nous chercherons à explorer l’espace de recherche en profondeur d’abord dont l’efficacité par rap port à l’exploration par niveaux a été montré Remerciements Ce travail est partiellement soutenu par St Etienne Metropole agglo st etienne fr et le projet Utique CMCU 11G1417 Références Abreu R et A J C van Gemund 2009 A low cost approximate minimal hitting set algo rithm and its application to model based diagnosis In Proceedings of the Eighth Symposium on Abstraction Reformulation and Approximation SARA’09 California Etats Unis Bailey J T Manoukian et K Ramamohanarao 2003 A fast algorithm for computing hy pergraph transversals and its application in mining emerging patterns In Proceedings of the Third IEEE International Conference on Data Mining ICDM ’03 Washington USA pp 485–488 Berge C 1989 Hypergraphs Combinatorics of Finite Sets 3rd ed North Holland Boros E K Elbassioni V Gurvich et L Khachiyan 2003 An efficient implementation of a quasi polynomial algorithm for generating hypergraph transversals In Proceedings of 255 LOCAL GENERATOR "diviser pour régner" pour l’extraction des traverses minimales 11th Annual European Symposium on Algorithms ESA 2003 Amsterdam Netherlands pp 556–567 Boros E K Elbassioni et K Makino 2008 On Berge multiplication for monotone boolean dualization In Proceedings of the 35th international colloquium on Automata Languages and Programming Part I ICALP ’08 pp 48–59 Casali A R Cicchetti et L Lakhal 2005 Essential patterns A perfect cover of frequent patterns In Proceedings of the 7th International Conference on DaWaK Copenhagen Den mark pp 428–437 Dong G et J Li 2005 Mining border descriptions of emerging patterns from dataset pairs Knowledge and Information Systems 178–202 Durand N et M Quafafou 2013 Approximation de bordures de motifs fréquents par le calcul de traverses minimales approchées d’hypergraphes In Actes de la 13ème Conférence Francophone sur l’Apprentissage Automatique CAp 2013 Lille France pp to appear Eiter T G Gottlob et K Makino 2002 New results on monotone dualization and generating hypergraph transversals In SIAM Journal On Computing pp 14–22 Hagen M 2008 Algorithmic and Computational Complexity Issues of MONET Phd disser tation Institut für Informatik Friedrich Schiller Universität Jena Hébert C A Bretto et B Crémilleux 2007 A data mining formalization to improve hyper graph minimal transversal computation Fundamdamenta Informaticae 80 4 415–433 Kavvadias D J et E C Stavropoulos 2005 An efficient algorithm for the transversal hy pergraph generation Journal of Graph Algorithms and Applications 9 2 239–264 Murakami K et T Uno 2013 Efficient algorithms for dualizing large scale hypergraphs In Proceedings of the 15th Meeting on Algorithm Engineering and Experiments ALENEX’13 New Orleans USA pp 1–13 Ruchkys D et S Song 2002 A parallel approximation hitting set algorithm for gene expres sion analysis In Proceedings of the 14th Symposium on Computer Architecture and High Performance Computing SBAC PAD’02 Vitoria Espirito Santo Brazil pp 75–81 Takata K 2007 A worst case analysis of the sequential method to list the minimal hitting sets of a hypergraph SIAM Journal on Discrete Mathematics 21 4 936–946 Toda T 2013 Hypergraph transversal computation with binary decision diagrams In Pro ceedings of the 12th International Symposium on Experimental Algorithms SEA’13 Rome Italy pp 91–102 Summary Generating minimal transversals from a hypergraph is a problem which is known to be par ticularly difficult with a large number of applications in both theoretical and applied Computer Science and several works have been proposed in the literature to solve it In this paper we propose a novel approach to optimize the extraction of minimal transversals which is based on both the partial hypergraph and local minimal transversal notions according divide and con quer strategy We introduce a new algorithm called LOCAL GENERATOR which computes ef ficiently minimal transversals and the experiments carried out on several types of hypergraphs showed that LOCAL GENERATOR obtains an interesting performances 256 