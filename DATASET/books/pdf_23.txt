 Echantillonnage de motifs séquentiels sous contrainte sur la norme Lamine Diop Cheikh Talibouya Diop Arnaud Giacometti Dominique Li Arnaud Soulet Université de Tours France {arnaud giacometti dominique li arnaud soulet} univ tours fr Université Gaston Berger de Saint Louis Sénégal {diop lamine3 cheikh talibouya diop} ugb edu sn Résumé L’échantillonnage de motifs est une méthode non exhaustive pour dé couvrir des motifs pertinents qui assure une bonne interactivité tout en offrant des garanties statistiques fortes grâce à sa nature aléatoire Curieusement une telle approche explorée pour les motifs ensemblistes et les sous graphes ne l’a pas encore été pour les données séquentielles Dans cet article nous proposons la première méthode d’échantillonnage de motifs séquentiels Outre le passage aux séquences l’originalité de notre approche est d’introduire une contrainte sur la norme pour maîtriser la longueur des motifs tirés et éviter l’écueil de la longue traîne Nous démontrons que notre méthode fondée sur une procédure aléatoire en deux étapes effectue un tirage exact Malgré le recours à un échantillonnage avec rejet les expérimentations montrent qu’elle reste performante 1 Introduction Les motifs séquentiels ont été introduits par Agrawal et Srikant 1995 il y a plus de 20 ans et leur utilité a été prouvée dans différents domaines de recherche et d’applications comme la fouille d’usage du Web la fouille de textes la bioinformatique la détection de fraudes etc Depuis la première publication de nombreuses méthodes ont optimisé l’extraction des motifs séquentiels Zaki 2001 Pei et al 2001 et ont introduit des variantes Lo et al 2008 Gomariz et al 2013 Malgré toutes ces avancées l’extraction des motifs séquentiels reste une tâche coûteuse qui génère souvent trop de motifs Cette limite aussi atteinte par l’extraction des motifs ensemblistes a été contournée par l’échantillonnage de motifs Une telle approche tire un nombre limité de motifs où la probabilité de tirer un motif est proportionnelle à sa fréquence Cette approche a l’avantage de contrôler la taille de la sortie et d’apporter une collection de motifs qui reflète l’intégralité de l’espace de recherche A notre connaissance une telle approche n’a encore pas été envisagée pour les motifs séquentiels Adapter la procédure d’échantillonnage de motifs en deux étapes Boley et al 2011 aux données séquentielles n’est pas trivial D’une part une limite importante de l’échantillonnage de motifs est d’avoir tendance à retourner des motifs rares correspondant à la longue traîne En effet la longue traîne signifie que la très grande majorité des motifs ont une fréquence très faible et elle occulte les motifs les plus fréquents Ce problème est exacerbé dans le cas 35 Echantillonnage de motifs séquentiels des séquences où le nombre de motifs séquentiels de fréquence 1 explose dans les jeux de données réels Malgré un tirage proportionnel à la fréquence l’échantillonnage se concentrerait uniquement sur des séquences très longues et de fréquence 1 Pour éviter cet écueil de la longue traîne nous choisissons d’introduire une contrainte sur la norme i e sur le nombre d’items pour contrôler la taille des motifs tirés D’autre part le coeur de cette approche requiert de dénombrer pour chaque séquence le nombre de sous séquences distinctes Cette tâche n’est pas aisée car une même séquence peut contenir plusieurs occurrences d’une même sous séquence A cette fin nous généraliserons le travail de Egho et al 2015 afin de dénombrer les sous séquences en tenant compte de la norme Dans cet article notre objectif est d’échantillonner les motifs séquentiels proportionnel lement à la fréquence avec une contrainte sur la norme Premièrement dans la section 4 nous proposons une méthode en deux étapes grâce à la généralisation de la formule de dé nombrement des sous séquences de Egho et al 2015 Nous démontrons que cette méthode effectue un échantillonnage exact Deuxièmement dans la section 5 nous expérimentons cette approche sur plusieurs jeux de données réels Nous montrons que notre approche est suffi samment performante pour retourner des centaines de motifs séquentiels par seconde Nous montrons également l’apport de la contrainte sur la norme pour mieux maîtriser la qualité des motifs retournés et éviter la malédiction de la longue traîne 2 Travaux relatifs Cet état de l’art distingue les méthodes d’échantillonnage de motifs en entrée et en sortie L’échantillonnage en entrée Toivonen et al 1996 consiste à régénérer depuis un échantillon de données tous les motifs qui auraient été extraits depuis le jeu de données complet L’échan tillonnage en sortie Al Hasan et Zaki 2009 consiste à générer un échantillon de motifs parmi les motifs qui auraient été extraits depuis le jeu de données complet Plusieurs approches ont été proposées pour l’échantillonnage en entrée des motifs séquentiels Raissi et Poncelet 2007 mais à notre connaissance cet article propose la première approche d’échantillonnage de mo tifs séquentiels en sortie Comme la complexité de l’échantillonnage de motifs est indépen dante de la taille du langage elle est propice aux langages structurés dont la combinatoire est forte D’ailleurs des méthodes ont été proposées pour les sous graphes Plusieurs procédures ont été proposées pour l’échantillonnage de motifs La première fa mille Al Hasan et Zaki 2009 repose sur les méthodes de Monte Carlo par chaînes de Markov L’idée est que la loi stationnaire de la marche aléatoire corresponde à la distribution à échan tillonner La limite de telles approches stochastiques est la vitesse de convergence qui peut être lente La seconde famille Boley et al 2011 consiste à tirer une instance du jeu de données puis à tirer un motif contenu dans cette instance En choisissant judicieusement les deux dis tributions de tirage il est alors possible d’obtenir un tirage exact selon la distribution désirée Nous avons opté pour une telle approche en deux étapes pour sa rapidité et sa précision Outre la difficulté de traiter des séquences plutôt que des itemsets nous avons également ajouté une contrainte sur la norme des motifs A notre connaissance seule une approche Dzyuba et al 2017 permettrait de traiter à la fois des langages complexes et des contraintes Fondée sur la satisfaction de contraintes elle requière de disposer d’un solveur intégrant efficacement des contraintes XOR et elle n’a été utilisée que pour des motifs ensemblistes Par ailleurs Dzyuba 36 L Diop et al et al 2017 soulignent que leur approche générique rivalisera difficilement avec des approches dédiées à un seul langage et ou classe de contraintes 3 Préliminaires Après avoir rappelé quelques définitions cette section formalise le problème de l’échan tillonnage de motifs séquentiels sous contraintes sur la norme 3 1 Définitions Soit I un ensemble fini de littéraux nommés items Un itemset ou motif X est un sous ensemble non vide de I Une séquence s définie sur I est une liste ordonnée s = 〈X1 Xn〉 d’itemsets non vides Xi ⊆ I 1 ≤ i ≤ n n ∈ N n est la taille de la séquence s noté |s| La norme d’une séquence s notée ‖s‖ est la somme des cardinalités de ses itemsets i e ‖s‖ = ∑ni=1 |si| Par la suite on note sl le préfixe 〈X1 Xl〉 de s 0 ≤ l ≤ n l ∈ N s0 étant la séquence vide représentée par 〈〉 et s[j] = Xj le j ième itemset de s 1 ≤ j ≤ n j ∈ N Enfin on note S l’ensemble universel de toutes les séquences définies sur I et une base de données séquentielles S sur I est un multi ensemble de séquences définies sur I Nous rappelons maintenant les définitions de sous séquences et d’occurrences d’une sous séquence dans une séquence donnée Définition 1 Sous séquence Une séquence s′ = 〈X ′1 X ′m〉 est une sous séquence d’une séquence s = 〈X1 Xn〉 noté s′ v s s’il existe une séquence d’indices 1 ≤ i1 < i2 < · · · < im ≤ n telle que pour tout j ∈ [1 m] on ait X ′j ⊆ Xij Etant donnée une séquence s on note φ s l’ensemble des sous séquences de s i e φ s = {s′ ∈ S | s′ v s} et Φ s la cardinalité de cet ensemble i e Φ s = |φ s | Etant donnée une séquence s = 〈X1 Xn〉 une sous séquence s′ = 〈X ′1 X ′m〉 de s peut apparaître plusieurs fois au sein de s s’il existe plusieurs séquences d’indices 1 ≤ i1 < i2 < · · · < im ≤ n telles que pour tout j ∈ [1 m] on ait X ′j ⊆ Xij Dans ce cas on parle d’occurrences multiples de la sous séquence s′ au sein de s La définition suivante précise comment ces différentes occurrences peuvent être représentées Définition 2 Occurrence Etant donnée une séquence s = 〈X1 Xn〉 une liste ordonnée d’itemsets o = 〈Z1 Zn〉 de même taille que s est une occurrence d’une sous séquence s′ = 〈X ′1 X ′m〉 de s s’il existe une séquence d’indices 1 ≤ i1 < · · · < im ≤ n telle que pour tout j ∈ {i1 im} on ait Zij = X ′j et tout j ∈ {1 n} \ {i1 im} on ait Zj = ∅ Cette séquence d’indices appelée signature de o est unique par définition Exemple 1 Pour s = 〈 ab cd ce 〉 o1 = 〈 a c ∅〉 et o2 = 〈 a ∅ c 〉 sont deux occurrences de s′ = 〈 a c 〉 avec pour signature respective 〈1 2〉 et 〈1 3〉 3 2 Formalisation du problème Une méthode d’extraction de motifs par échantillonnage a généralement pour objectif de tirer aléatoirement un motif par rapport à une mesure d’intérêt donnée Dans notre cas la mesure considérée est la fréquence du motif dans une base de données séquentielles 37 Echantillonnage de motifs séquentiels Définition 3 Fréquence Etant données une base de données séquentielles S définie sur I et une sous séquence s ∈ S La fréquence de s dans S noté freq s S ou plus simplement freq s est définie par freq s S = |{s′ ∈ S | s v s′}| Notre objectif est de tirer aléatoirement des motifs séquentiels par rapport à la fréquence et sous une contrainte de norme Etant donnés deux entiers m et M tels que m ≤ M on notera S[m M ] l’ensemble des séquences de S de norme comprise entre m et M i e S[m M ] = {s ∈ S |m ≤ ‖s‖ ≤M} Le problème posé peut finalement s’énoncer comme suit Etant données une base de données séquentielles S des normes minimale m et maxi maleM notre problème consiste à tirer aléatoirement une sous séquence s ∈ S[m M ] telle que la probabilité de tirage p s de s soit égale à la fréquence de s dans S normalisé par la somme des fréquences des sous séquences de S dans S[m M ] i e p s = freq s S ∑ s′∈S[m M] freq s ′ S 4 Méthode d’échantillonnage en deux étapes sous contrainte 4 1 Aperçu de l’approche Dans l’approche proposée par Boley et al 2011 les auteurs montrent comment échan tillonner des itemsets proportionnellement à leur support dans une base de données transaction nelles Nous proposons d’utiliser une solution comparable en deux étapes mais en ajoutant une contrainte sur la norme des motifs extraits Tirage d’une séquence Soient S une base de données séquentielles et deux entiers m et M tels que m ≤ M Dans une première étape voir lignes 1 et 2 de l’algorithme 1 nous commençons par calculer pour toute séquence s ∈ S le nombre Φ[m M ] s de sous séquences de s de norme comprise entre m et M i e Φ[m M ] s = |{s′ v s |m ≤ ‖s‖ ≤M}| En se basant sur les travaux de Egho et al 2015 nous montrons dans la section 4 2 comment calculer un tel nombre de sous séquences Ensuite cette première étape se poursuit par le tirage aléatoire d’une séquence s de S proportionnellement à son poids w s = Φ[m M ] s Tirage d’un motif séquentiel Dans la deuxième étape nous commençons par tirer aléatoi rement ligne 3 de l’algorithme 1 la norme k de la sous séquence de s qui sera finalement retournée Ce nombre k est tiré proportionnellement au nombre de sous séquences de s de norme exactement égale à k i e selon la distribution de probabilité P[m M ] définie pour tout k ∈ [m M ] par P[m M ] k = Φ[k k] s Φ[m M] s Finalement l’algorithme 1 retourne à la ligne 4 une sous séquence s′ de s de norme k selon une distribution uniforme ce qui signifie que toute sous séquence s′ de s de norme k sera tirée avec la même probabilité 1Φ[k k] s Nous montrons dans la section 4 3 comment effectuer un tel tirage uniforme grâce à une méthode par rejet Le problème principal posé est qu’une sous séquence s′ de s peut avoir plusieurs occurrences dans s et qu’il ne faut donc pas tirer avec une probabilité plus élevée des sous séquences de s ayant un nombre d’occurrences plus important 38 L Diop et al Algorithm 1 Echantillonnage de motifs séquentiels sous contraintes de norme Input Une base de données séquentielles S et deux entiers m et M tels que m ≤M Output Une sous séquence s ∈ S[m M ] tirée aléatoirement i e s ∼ freq S[m M ] S 1 Soient les poids w définis par w s = Φ[m M ] s pour tout s ∈ S 2 Tirer une séquence de S proportionnellement à w s ∼ w S 3 Tirer un entier k entre m et M selon la distribution P[m M ] k 4 return Une sous séquence s′ ∼ u {s′ v s | ‖s′‖ = k de s où u est la distribution uniforme 4 2 Poids et tirage d’une séquence Dans cette section nous montrons comment calculer le nombre de sous séquences d’une séquence s sous contrainte de norme en généralisant la proposition de Egho et al 2015 La principale difficulté est de ne pas compter plusieurs fois une même sous séquence même si elle possède plusieurs occurrences dans s Sans contrainte sur la norme Soient une séquence s = 〈X1 Xn〉 et un itemset Y Par la suite nous notons s ◦ Y la concaténation de s et Y définie par s ◦ Y = 〈X1 Xn Y 〉 Intuitivement si Y est disjoint de tous les itemsets de la séquence s il est aisé de vérifier que le nombre de sous séquences distinctes de s ◦ Y est égal au nombre de sous séquences de s multiplié par le nombre de sous ensembles de Y i e Φ s ◦ Y = Φ s × 2|Y | Si Y n’est pas disjoint des itemsets de S Φ s ◦ Y sera inférieur à Φ s × 2|Y | et Egho et al 2015 introduisent un terme correcteur R s Y pour calculer le nombre exact de sous séquences distinctes Pour ce faire ils commencent par introduire un ensemble de positions précisant où les répétitions d’items de l’itemset Y sont localisées dans la séquence s Définition 4 Ensemble de positions Egho et al 2015 Soient une séquence s et un item set Y L s Y = {i ∈ N | i ≤ |s|∧s[i]∩Y 6= 0∧ ∀j > i s[i]∩Y 6⊆ s[j]∩Y } est l’ensemble des positions où l’itemset Y a une intersection maximale avec les différents itemsets de s Exemple 2 Soit la séquence s = 〈 ab c ac 〉 Nous avons s1 = 〈 ab 〉 s[2] = c et L s1 s[2] = ∅ car s[2] n’intersecte aucun itemset de s1 Calculons maintenant L s2 s[3] s[3] = ac intersecte à la fois le premier itemset s[1] = ab de s s[1] ∩ s[3] = a et le second itemset s[2] = c de s s[2] ∩ s[3] = c De plus ces deux intersections sont disjointes Par conséquent nous avons L s2 s[3] = {1 2} ce qui indique qu’en concaténant des sous ensembles de s[3] à des sous séquences de s2 des répétitions de sous séquences de s2 pourront être générées du fait que des items de s[3] se retrouvent aux postions 1 et 2 de s2 A partir de cet ensemble de positions il est possible de calculer le nombre de sous séquences distinctes d’une séquence s grâce à la formule récursive suivante Théorème 1 Nombre de sous séquences Egho et al 2015 Etant donnés une séquence s et un itemset Y le nombre de sous séquences distinctes de s ◦ Y noté Φ s ◦ Y est défini par Φ s ◦ Y = Φ s × 2|Y | −R s Y où R s Y est un terme correcteur R s Y = ∑ ∅⊂K⊆L s Y −1 |K|+1 Φ smin K −1 × 2|s[K]∩Y | − 1 avec s[K] = ∩k∈Ks[k] pour toute séquence s et ensemble d’indices K 39 Echantillonnage de motifs séquentiels L’exemple suivant permet de donner une intuition de la formule récursive introduite précédem ment et en particulier de son terme correcteur Exemple 3 Poursuivons l’exemple 2 L’ensemble φ s1 des sous séquences de s1 = 〈 ab 〉 est défini par φ s1 = {〈 〉 〈a〉 〈b〉 〈 ab 〉} Nous avons donc Φ s1 = 4 CommeL s1 s[2] = 0 etR s1 s[2] = 0 nous avons Φ s2 = Φ s1 ×|2 c | = 4×2 = 8 En effet les sous séquences de s2 sont obtenues par simple concaténation de l’itemset vide ou de l’itemset c avec une sous séquence de s1 Nous détaillons maintenant le calcul de Φ s3 = Φ s2 × |2 ac | − R s2 s[3] = 8 × 4 − R s2 s[3] et du terme correcteur R s2 s[3] Comme L s2 s[3] = {1 2} nous avons R s2 s[3] = −1 2Φ s0 × 2| a | − 1 + −1 2Φ s1 × 2| c | − 1 = 1+4 = 5 Le premier terme deR s2 s[3] permet de ne pas recompter la sous séquence 〈a〉 de s2 en la construisant par concaténation de l’itemset a inclus dans s[3] à la sous séquence vide de s0 Quant au second terme de R s2 s[3] il permet de ne pas recompter les sous séquences 〈c〉 〈ac〉 〈bc〉 〈 ab c〉 de s2 en les construisant par concaténation de l’itemset c inclus dans s[3] aux sous séquences 〈〉 〈a〉 〈b〉 〈 ab 〉 de s1 Nous avons finalement Φ s3 = 32−R s2 s[3] = 27 Avec contrainte sur la norme Nous proposons une généralisation du théorème 1 permettant de calculer le nombre de sous séquences de norme inférieure ou égale à M d’une séquence s Théorème 2 Nombre de sous séquences de norme bornée Etant donnés une séquence s un itemset Y et un entier j ≤ ‖s‖ le nombre de sous séquences distinctes de norme inférieure ou égale à j de s ◦ Y noté Φ≤j s ◦ Y est défini ci dessous Φ≤j s ◦ Y =   min{j |Y |}∑ k=0 Ck|Y | × Φ≤j−k s  −R≤j s Y où R≤j s Y est un terme correcteur défini par R≤j s Y = ∑ ∅⊂K⊆L s Y −1 |K|+1   |s[K]∩Y |∑ k=1 Ck|s[K]∩Y | × Φ≤j−k smin K −1   sachant que R≤j s Y = 0 si L s Y = ∅ Ce théorème est une généralisation du théorème 1 Notons par exemple que le premier terme Φ s × 2|Y | de Φ s ◦ Y est remplacé par∑min{j |Y |}k=0 Ck|Y | × Φ≤j−k s pour calculer Φ≤j s ◦ Y Intuitivement pour construire une sous séquence de norme inférieure à j de s ◦ Y on peut concaténer tout sous ensemble de taille k de Y à une sous séquence de norme inférieure à j − k de s Ainsi on est certain d’obtenir une sous séquence de s ◦ Y de norme inférieure à k + j − k = j et il faut répéter ce principe pour toute taille possible d’un sous ensemble de Y La même intuition explique la généralisation du terme correcteur R s Y En poursuivant l’exemple 3 l’exemple suivant illustre le principe de fonctionnement de la formule du théorème 2 40 L Diop et al Exemple 4 L’ensemble φ≤2 s1 des sous séquences de s1 = 〈 ab 〉 de norme inférieure à 2 est défini par φ≤2 s1 = {〈 〉 〈a〉 〈b〉 〈 ab 〉} Nous avons donc Φ≤2 s1 = 4 et on voit aussi aisément que Φ≤1 s1 = 3 la sous séquence 〈 ab 〉 étant de norme strictement supérieure à 1 Comme L s1 s[2] = 0 nous avons R≤2 s1 s[2] = 0 et Φ≤2 s2 = ∑| c | k=0 C k | c | × Φ≤2−k s1 = C01 × Φ≤2 s1 + C11 × Φ≤1 s1 = 4 + 3 = 7 Le premier terme de la somme correspond aux 4 sous séquences de s3 obtenues par concaténation du sous ensemble vide aux sous séquences de s2 alors que le deuxième terme correspond aux 3 sous séquences de s3 obtenues par concaténation de l’itemset c aux sous séquences de s2 de norme inférieure à 1 Détaillons maintenant le calcul de Φ≤2 s3 = ∑| ac | k=0 C k | ac | × Φ≤2−k s2 − R≤2 s2 s[3] = Φ≤2 s2 +2×Φ≤1 s2 +Φ≤0 s2 −R≤2 s2 s[3] = 7+2×4+1−R≤2 s2 s[3] Le second terme de Φ≤2 s3 égal à 2 × 4 correspond par exemple au nombre de sous séquences de s3 pouvant être obtenues par concaténation d’un sous ensemble de taille 1 de ab au nombre de 2 avec une sous séquence de s2 de norme inférieure à 1 Pour finir le calcul du terme correcteur R≤2 s2 s[3] se présente comme suit R≤2 s2 s[3] = −1 2C1| a | ×Φ≤1 s0 + −1 2C1| c |×Φ≤1 s1 = 1+3 = 4 On en déduit ainsi que Φ≤2 s3 = 7+2×4+1−4 = 12 La formule présentée au théorème 2 est récursive Néanmoins étant données une séquence s et une borne M ≤ ‖s‖ cette récursivité peut facilement être supprimée en calculant ligne par ligne les matrices T et R définies par — T [i][j] = Φ≤j si pour i ∈ [0 |s|] et j ∈ [0 M ] T [i][j] représente le nombre de sous séquences de norme inférieure ou égal à j de la séquence si — R[i][j] = R≤j si−1 s[i] pour i ∈ [2 |s|] et j ∈ [0 M ] Ce terme correcteur repré sente le terme à soustraire quand on souhaite calculer le nombre de sous séquences de norme inférieure à j de si = si−1 ◦s[i] à partir du nombre de sous séquences de norme inférieure à j de si en y concaténant des sous ensembles de s[i] Des exemples de matrices T et R sont données en figure 1 pour la séquence s = 〈 ab c ac 〉 l’exemple 4 illustrant comment calculer R[3][2] = R≤2 s2 s[3] et T [3][2] = Φ≤2 s3 T[i][j] ≤ 0 ≤ 1 ≤ 2 ≤ 3 s0 = 〈〉 1 1 1 1 s1 = 〈 ab 〉 1 3 4 4 s2 = 〈 ab c〉 1 4 7 8 s3 = 〈 ab c ac 〉 1 4 12 21 R[i][j] ≤ 0 ≤ 1 ≤ 2 s1 s[2] = c 0 0 0 s2 s[3] = ac 2 4 5 FIG 1 Exemples de matrices T et R Pour conclure cette section notons qu’à partir du théorème 2 étant donnés une séquence s et deux entiers m et M tels que 1 ≤ m ≤ M ≤ ‖s‖ il est possible de calculer le nombre de sous séquences distinctes de s de norme comprise entre m et M En effet nous avons Φ[m M ] s = Φ≤M s − Φ≤m−1 s Dans l’algorithme 1 cette formule permet de calculer à l’étape 1 le poids initial w s des séquences s de la base de données séquentielles S 4 3 Tirage par rejet d’une sous séquence Après avoir tiré aléatoirement une séquence s ∈ S proportionnellement à son poids w s ligne 2 de l’algorithme 1 et un entier k entre m et M selon la distribution P[m M ] k ligne 41 Echantillonnage de motifs séquentiels 3 l’objectif est maintenant de montrer comment retourner une sous séquence de norme k tirée uniformément depuis la séquence s ligne 4 La difficulté est de ne pas favoriser les séquences qui disposent de plusieurs occurrences au sein de la séquence Afin de contourner cette difficulté nous proposons d’utiliser une méthode par rejet en ti rant uniformément une occurrence de la séquence s et en la rejetant si cette occurrence n’est pas la première Comme chaque séquence dispose d’une unique première occurrence cette ap proche garantit un tirage uniforme des motifs séquentiels Pour commencer nous formalisons la notion de première occurrence Définition 5 Première occurrence Soient o1 et o2 deux occurrences d’une sous séquence s′ de s de signatures respectives 〈i11 i12 i1m〉 et 〈i21 i22 i2m〉 On dit que o1 précède o2 noté o1 < o2 s’il existe un indice l ∈ [1 m] tel que pour tout j ∈ [1 l − 1] on ait i1j = i2j et i1l < i 2 l Enfin on appelle première occurrence de s ′ dans s sa plus petite occurrence selon l’ordre défini précédemment Exemple 5 Dans la continuité de l’exemple 1 comme 〈1 2〉 et 〈1 3〉 sont les signatures respectives des deux occurrences o1 = 〈 a c ∅〉 et o2 = 〈 a ∅ c 〉 de la sous séquence s′ = 〈 a c 〉 de s = 〈 ab cd ce 〉 et que 〈1 2〉 précède 〈1 3〉 nous avons o1 < o2 Enfin il est aisé de vérifier que o1 est la première occurrence de s′ dans s o1 et o2 étant les deux seules occurrences de s′ dans s En pratique nous devons surtout vérifier si une occurrence de la sous séquence s′ v s est la première occurrence de s′ au sein de la séquence s Propriété 1 Etant donnée une occurrence o d’une sous séquence s′ v s de signature σ = 〈i1 i2 im〉 o est la première occurrence de s′ si et seulement si pour ij ∈ σ il n’existe pas l ∈ [ij−1 + 1 ij − 1] tel que o[ij ] ⊆ s[l] avec i0 = 0 Exemple 6 Toujours dans la continuité de l’exemple 1 supposons qu’après avoir tiré k = 2 items de la séquence s = 〈 ab cd ce 〉 à savoir les items aux positions d’index 1 et 5 nous ayons généré l’occurrence o = 〈 a ∅ c 〉 de signature 〈1 3〉 de la sous séquence s′ = 〈 a c 〉 de s Dans ce cas comme il existe l = 2 appartenant à [1 + 1 3 − 1] tel que o[3] = c ⊆ s[2] = cd o n’est pas une première occurrence de s′ et cette occurrence sera rejetée Grâce à la propriété 1 il est finalement aisé de tirer uniformément une sous séquence de norme k d’une séquence s En tirant aléatoirement k positions distinctes entre 1 et ‖s‖ de s on commence par tirer uniformément une occurrence de norme k d’une sous séquence de s Si cette occurrence est une première occurrence on l’accepte et on la retourne Sinon on la rejette et on effectue un tirage aléatoire d’une nouvelle occurrence de s Même si cet algorithme repose sur une technique d’échantillonnage avec rejet nous montrons dans la section suivante que le nombre moyen de tirages avant acceptation est calculable 4 4 Analyse de la méthode La propriété suivante indique que l’algorithme 1 retourne un échantillon exact des motifs séquentiels avec une contrainte sur la norme 42 L Diop et al Propriété 2 Correction Soient une base de données séquentielles S des normes minimale m et maximale M l’algorithme 1 effectue le tirage d’une sous séquence de S de norme com prise entre m et M et proportionnellement à sa fréquence Concernant la complexité nous pouvons distinguer deux grandes phases dans notre ap proche le pré traitement où la distribution des motifs séquentiels en fonction de la norme est calculée pour chaque séquence et le tirage de sous séquences Complexité du pré traitement Le pré traitement s’avère coûteux avec une complexité tem porelle en O |S| · L ·M2 · 2P · T 2 où L est la longueur maximale d’une séquence M est la norme maximale des sous séquences tirées P est la taille maximale d’un ensemble de posi tions L si−1 s[i] et T est la taille maximale d’un itemset d’une séquence Néanmoins P ≤ L peut être petit en pratique et ce pré traitement ligne 1 de l’algorithme 1 est réalisé une unique fois avant de pouvoir tirer N sous séquences de S Complexité du tirage Le tirage effectif des sous séquences est moins coûteux Tout d’abord le tirage d’une séquence ligne 2 de l’algorithme 1 se réalise en O ln |S| Il est plus difficile d’estimer la complexité au pire du tirage d’une sous séquence car le nombre de rejets n’est pas borné Néanmoins une bonne façon de mesurer l’efficacité de l’approche est de calculer le nombre moyen de tirages nécessaires noté µ[m M ] S pour tirer une sous séquence de S de norme comprise entre m et M Intuitivement µ[m M ] S dépend à la fois de la probabilité qu’une séquence s ∈ S soit tirée et du nombre moyen de tirages nécessaires noté µ[m M ] s pour tirer une occurrence d’une sous séquence de s qui soit une première occurrence La pro priété suivante montre comment ces termes peuvent être calculés Propriété 3 Nombre moyen de tirages Soient une base de données séquentielles S des normes minimale m et maximale M le nombre moyen de tirages pour tirer un motif séquen tiel de norme compris entre m et M est défini par µ[m M ] S = ∑ s∈S Φ[m M] s ∑ s′∈S Φ[m M] s ′ × µ[m M ] s avec µ[m M ] s = ∑M k=m C k ‖s‖ Φ[m M] s Lorsque le nombre moyen de tirages est proche de 1 cela signifie que le tirage d’un motif séquentiel ne donnera pas lieu à un rejet Pour une séquence donnée il n’y a pas de rejet si chaque occurrence est la première occurrence i e il n’y a pas de répétition au sein de la sé quence Dans la pratique le nombre moyen de tirages mesuré sur des jeux de données réels est souvent très faible voir la section expérimentale suivante Finalement la complexité tempo relle du tirage d’une occurrence de norme égale à k ∈ [m M ] d’une séquence s étant dans le pire des cas en O M2 la complexité en moyenne du tirage de N sous séquences d’une base de données S après la phase de pré traitement est en O N ·M2 · µ[m M ] S 5 Expérimentations L’objectif de cette section expérimentale est d’évaluer la rapidité de notre méthode et d’ob server l’impact de la contrainte sur les motifs extraits Pour cela nous avons utilisé six jeux de données bms et sign sont des jeux de données réels disponibles avec SPMF 1 Les quatre autres ont été construits avec le générateur de données de IBM également disponible sur le site 1 philippe fournier viger com spmf 43 Echantillonnage de motifs séquentiels Caractéristiques générales Nombre moyen de tirages pour M = Jeu de données |S| |I| |S|moy ‖S‖moy 3 4 5 6 7 bms 59 601 497 2 5 5 0 1 0 1 0 1 0 1 0 1 0 sign 730 267 52 0 104 0 1 0 1 0 1 0 1 0 1 0 D10K5S2T6I 10 000 6 5 6 15 9 11 4 16 9 23 5 30 8 38 4 D10K6S3T10I 10 000 10 6 0 21 9 10 4 14 4 18 5 22 4 25 7 D100K5S2T6I 100 000 6 4 8 13 3 8 5 11 5 14 9 19 0 23 9 D100K6S2T6I 100 000 6 5 6 16 0 11 1 16 0 21 4 27 0 32 4 TAB 1 Caractéristiques des benchmarks de SPMF Un des intérêts des jeux de données synthétiques est d’avoir des exemples de jeux de données avec un nombre moyen de tirages nécessaires µ[m M ] S supérieur à 1 grâce à l’ajout de répétitions au sein des séquences Le tableau 1 présente les caractéristiques générales des jeux de données partie gauche et le nombre moyen de tirages nécessaires µ[m M ] S pour extraire un motif avec m = 1 et M ∈ [3 7] partie droite Notre méthode est implémentée avec le langage Python Toutes les expériences sont faites sur un PC avec un processeur AMD 2 5 GHz Quad Core A8 7410 une RAM de 8GB avec Ubuntu 16 04 LTS 64 bits Prétraitement s Tirage d’un motif ms M M Jeu de données 3 4 5 6 7 3 4 5 6 7 bms 11 15 20 21 24 1 1 1 4 1 5 1 7 1 8 sign 10 15 20 24 27 0 6 0 6 0 6 0 7 0 7 D10K5S2T6I 10 15 19 25 30 0 8 1 3 2 5 2 7 4 7 D10K6S3T10I 18 28 38 48 59 0 9 1 2 2 0 2 9 2 5 D100K5S2T6I 71 109 141 165 193 0 6 0 9 1 4 1 7 2 6 D100K6S2T6I 105 155 198 247 271 0 8 1 3 2 2 2 7 3 9 TAB 2 Temps d’exécution de l’échantillonnage de sous séquences de norme inférieure à M Rapidité de l’approche Le tableau 2 indique le temps d’exécution de la méthode en distin guant le temps de prétraitement et le temps moyen pour tirer un motif séquentiel dont la norme est comprise entre 1 et M ∈ [3 7] On constate que le temps de préparation augmente avec la taille du jeu de données du nombre de séquences et d’items et avec la norme maximale Même pour D100K6S2T6I qui est de grande taille le temps d’exécution de ce prétraitement qui peut se faire hors ligne est tout à fait raisonnable moins de 5 min Concernant la phase de tirage quel que soit le jeu de données et M le temps d’exécution est de l’ordre de quelques millisecondes au plus 4 ms pour D100K6S2T6I avec M = 7 Malgré un nombre moyen de tirages nécessaires µ[m M ] S supérieur à 1 et donc du rejet lors du tirage les performances sur les jeux de données synthétiques sont bonnes On observe une hausse du temps d’exécution avec M mais celle ci reste limitée avec des durées moyennes de tirage inférieures à 4 ms Impact de la contrainte La figure 2 montre la répartition de 10 000 motifs séquentiels échantillonnés selon la fréquence avec une contrainte de norme inférieure à 4 ou 7 en gris et sans contrainte en noir pour les différents jeux de données Dans tous les cas la méthode sans contrainte retourne uniquement des motifs de fréquence très faible en particulier de fré quence unitaire sur les jeux de données réels A l’inverse la méthode d’échantillonnage avec contrainte sur la norme retourne des sous séquences de fréquence significativement plus élevée 44 L Diop et al 0 2000 4000 6000 8000 10000 5 10 15 20 25 N om br e de m ot ifs Frequence BMS without constraint with M=7 with M=4 0 2000 4000 6000 8000 10000 5 10 15 20 25 N om br e de m ot ifs Frequence SIGN without constraint with M=7 with M=4 0 2000 4000 6000 8000 10000 0 500 1000 1500 2000 2500 3000 3500 4000 4500 5000 N om br e de m ot ifs Frequence D10K5S2T6I without constraint with M=7 with M=4 0 2000 4000 6000 8000 10000 0 500 1000 1500 2000 2500 3000 3500 4000 4500 5000 N om br e de m ot ifs Frequence D10K6S3T10I without constraint with M=7 with M=4 0 2000 4000 6000 8000 10000 0 10000 20000 30000 40000 50000 N om br e de m ot ifs Frequence D100K5S2T6I without constraint with M=7 with M=4 0 2000 4000 6000 8000 10000 0 10000 20000 30000 40000 50000 N om br e de m ot ifs Frequence D100K6S2T6I sans contrainte avec M=7 avec M=4 FIG 2 Répartition de 10 000 motifs séquentiels selon leur fréquence de 100 à 1000 fois plus élevées ce qui démontre l’importance d’introduire des contraintes sur la norme Notons que pour sign l’effet est peu significatif avec M = 7 mais la diminution de la norme maximale parvient à juguler l’explosion des motifs de fréquence peu élevée 6 Conclusion Cet article propose la première méthode pour échantillonner en sortie des motifs séquen tiels Elle permet en outre de spécifier un intervalle sur la norme des motifs séquentiels afin de mieux contrôler les motifs retournés Nous avons démontré que notre approche est exacte et nous avons estimé son efficacité en fonction du nombre de rejets moyen qui se dégrade avec le nombre de répétitions au sein d’une séquence Néanmoins la partie expérimentale a montré que l’approche s’avère très performante sur des jeux de données réels où le taux de répéti tion est très faible De plus les expérimentations montrent que l’ajout d’une contrainte sur la norme évite de retourner trop de motifs trop rares Dans l’immédiat nous voudrions appli quer l’échantillonnage de motifs séquentiels à la détection de données aberrantes Giacometti et Soulet 2016 ou au sein de systèmes interactifs Giacometti et Soulet 2017 pour démon 45 Echantillonnage de motifs séquentiels trer son utilité Nous souhaiterions aussi étendre notre approche à tout système ensembliste En effet le tirage uniforme au sein de structures complexes rendu possible grâce à une forme canonique est envisageable avec d’autres langages structurés Remerciements Lamine Diop est partiellement financé par le CEA MITIC Centre d’Excellence Afri cain en Mathématiques Informatique et TIC Références Agrawal R et R Srikant 1995 Mining sequential patterns In Proc of ICDE 95 pp 3–14 Al Hasan M et M J Zaki 2009 Output space sampling for graph patterns Proc of the VLDB Endowment 2 1 730–741 Boley M C Lucchese D Paurat et T Gärtner 2011 Direct local pattern sampling by efficient two step random procedures In Proc of the 17th ACM SIGKDD pp 582–590 Dzyuba V M van Leeuwen et L De Raedt 2017 Flexible constrained sampling with guarantees for pattern mining Data Mining and Knowledge Discovery 31 5 1266–1293 Egho E C Raïssi T Calders N Jay et A Napoli 2015 On measuring similarity for sequences of itemsets Data Mining and Knowledge Discovery 29 3 732–764 Giacometti A et A Soulet 2016 Frequent pattern outlier detection without exhaustive mining In Proc of PAKDD 2016 pp 196–207 Springer Giacometti A et A Soulet 2017 Interactive pattern sampling for characterizing unlabeled data In Proc of IDA 2017 pp 99–111 Springer Gomariz A M Campos et R M B Goethals 2013 ClaSP An efficient algorithm for mining frequent closed sequences In Proc of PAKDD 2013 pp 50–61 Lo D S C Khoo et J Li 2008 Mining and ranking generators of sequential patterns In Proc of SDM 2008 pp 553–564 Pei J J Han B Mortazavi Asl et H Pinto 2001 PrefixSpan Mining sequential patterns efficiently by prefix projected pattern growth In Proc of ICDE 2001 pp 215–224 Raissi C et P Poncelet 2007 Sampling for sequential pattern mining From static databases to data streams In Proc of ICDM 2007 pp 631–636 IEEE Toivonen H et al 1996 Sampling large databases for association rules In Proc of VLDB 96 Vo lume 96 pp 134–145 Zaki M J 2001 SPADE An efficient algorithm for mining frequent sequences Machine Lear ning 42 1 2 31–60 Summary Pattern sampling is a method for discovering patterns with strong statistical guarantees In this paper we propose the first method for sampling sequential patterns Beyond addressing the sequential data the originality of our approach is to constrain the norm of sequential patterns to avoid the long tail issue We demonstrate that our constrained two step random procedure performs an exact sampling which is efficient in practice 46 