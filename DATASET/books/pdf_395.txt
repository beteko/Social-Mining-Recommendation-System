Détection académique Plagiat avec des graphiques Bin-Hui Chou, Einoshin Suzuki Dept. Informatique, Université de Kyushu, au Japon chou@i.kyushu-u.ac.jp, suzuki@inf.kyushu-u.ac.jp Résumé. Dans cet article, nous nous attaquons au problème de la détection plagia- académique risme, qui est considéré comme un grave problème en raison de la facilité de mise en ligne sur l'autre. méthodes de recherche d'information typiques, des méthodes basées sur des méthodes et des termes courants ngerprinting, sont couramment utilisés pour détecter le plagiat en utilisant la séquence de mots tels qu'ils apparaissent dans l'article. A ce titre, ils ne parviennent pas à détecter le plagiat quand un auteur reconstitue un article source en re-commande et de phrases re- combinant. Parce que ts structure graphique pour représenter les relations entre les entités, nous proposons une nouvelle méthode de détection de plagiat, dans lequel nous utilisons des graphiques pour représenter des documents en modélisant les relations grammaticales entre les mots. Les résultats expérimentaux montrent que notre méthode proposée surpasse deux méthodes et des augmentations rappellent les valeurs n-gramme de 10 à 20%. 1 Introduction Publication en ligne offre une plate-forme pour les chercheurs de partager leurs résultats de recherche alors qu'il apporte également un effet secondaire grave, le problème de plagiat académique. Autrement dit, les étudiants ou les cher- cheurs copier tout le contenu ou une partie des passages des documents d'autres sans citation appropriée (Howard, 1995). Il est difcile pour les éditeurs de journaux et procédures pour découvrir tous les comportements de plagiat en raison de la limitation dans le temps et la quantité de publications. Une méthode de détection automatique matic peut être utilisé pour les emplois d'aide éditeurs et d'atténuer le problème. méthodes de détection de plagiat existants évaluent les similitudes de documents en utilisant des mots de contenu (Gustafson et al, 2008;. Hoad et Zobel, 2003), les mots vides (Stamatatos, 2011) ou du document empreintes digitales (Seo et Croft, 2008; Schleimer, 2003) . En commun dans la recherche d'information (IR), les méthodes (Grman et Ravas, 2011, Gustafson et al, 2008;. Hoad et Zobel, 2003) de mots vides jettez, par exemple, l'est, et considérer le contenu restant mots comme des mots significatifs. Ce genre de méthodes utiliser des séquences de mots pour représenter le contenu d'un document. Stamatatos (2011) estime qu'un plagiaire peut remplacer les mots de contenu pour éviter la détection, et a proposé de représenter des documents en supprimant les mots de contenu, mais en conservant les mots vides. Seo et Croft (2008); Schleimer (2003) l'utilisation hash des morceaux de longueur xé en tant que document. Empreintes digitales Les deux passages sans citation copie et paraphraser directement sont considérés comme le plagiat démie acadé- (Howard, 1995, Rosamond, 2002). Ici, nous cherchons à détecter les documents plagiés où l'on paraphrases du texte à partir d'autres documents par des phrases re-commande ou modiers altérant. La plupart des approches existantes utilisent des séquences de mots tels qu'ils apparaissent dans le document pour représenter le document afin qu'ils ne parviennent pas à détecter ce type de plagiat. Détection académique Plagiat avec des graphiques pour détecter ce genre de plagiat, nous considérons ce qui représente un document en modélisant tionships entre les paires de rela- mots dans le document. En capturant les relations entre les mots, nous sommes toujours en mesure de détecter le plagiat, même si un plagiaire en grande partie modifie l'ordre des phrases. Dans cet article, nous proposons une nouvelle méthode de détection de plagiat par la représentation des documents avec des graphiques. Dans notre méthode, chaque document est transformé en structure graphique en fonction des relations Tical syntac- entre les mots. Nous détectons un plagiat si les deux graphiques contiennent des sous-graphes similaires. Les résultats expérimentaux montrent que notre méthode est plus efficace que les méthodes existantes pour détecter le plagiat de paraphraser. 2 Motivation et problème Denition 2.1 Motivation Prenons un exemple indiqué dans le tableau 1, où le texte A est un extrait de (Shi et Malik, 2000) et le texte B est un texte que nous récrit du texte A par réordonner la phrases A et ajout / suppression de mots sans altérer son contenu. Textes A et B représentent le même concept, mais ont des expressions différentes dans leurs phrases et constructions. Nous considérons textes A et B en tant que document source et un document plagié, respectivement. LANGUETTE. 1 Exemple d'une source et des documents plagiés. (A) Texte A (Source) Nous proposons une nouvelle approche pour solv- le problème de l'ing groupement perceptuel dans la vision. Nos objectifs d'approche à l'ING impression y décompresser globale d'une image. Nous traitons la segmentation d'images comme un problème de partitionnement de graphe et de proposer un nouveau critère global, la coupe normalisée, pour segmenter le graphique. (B) Texte B (Plagiat) Dans cet article, nous traitons la tion de l'image, à savoir le problème de groupement perceptuel dans la vision, comme un problème de partitionnement de graphe et visent à extraire la pression globale im- d'une image. Nous vous proposons un nouveau critère global pour segmenter le graphique, appelé la coupe normalisée. Nous classons les méthodes existantes dans les méthodes typiques IR (Grman et ravas, 2011, Gustafson et al, 2008;. Hoad et Zobel, 2003), les méthodes ngerprinting (Schleimer, 2003, Seo et Croft, 2008) et une méthode basée sur mot vide- (Stamatatos, 2011). Les méthodes typiques d'IR évaluent souvent la similitude des deux documents par le texte de diviser en séquences de mots d'une longueur specied et en comparant le nombre de mots. Puisque l'ordre des phrases dans le texte B dans le tableau 1 est en grande partie changé, ce qui diminue le nombre de mots communs entre des séquences de mots, les méthodes typiques IR ne parviennent pas à détecter un tel type de plagiat. Les méthodes existantes (ngerprinting Schleimer, 2003, Seo et Croft, 2008) représentent un document en utilisant hash des morceaux de longueur xes. Les deux caractères et les mots peuvent être utilisés pour des morceaux, mais la plupart d'entre eux (Schleimer, 2003, Seo et Croft, 2008) considèrent mot n-grammes. Ainsi, l'ajout ou la suppression d'un petit nombre de mots modifie le résultat de hachage, ce qui rend les méthodes ngerprinting moins efficaces pour détecter le plagiat où un plagiaire modies en grande partie l'ordre des mots ou le phrasé (Seo et Croft, 2008). Stamatatos (2011) supprime tous les mots de contenu dans un B. Chou et E. Document Suzuki et a proposé la méthode n-grammes de mots interdits (SWNG). Depuis l'ordre de mots vides est modifiée ainsi dans le texte B dans le tableau 1, SWNG est pas efficace pour détecter le plagiat. Dans l'exemple, nous sommes motivés à inventer une méthode de détection de plagiat, où la représentation d'un document est basé sur les relations entre les mots au lieu de leurs positions d'occurrence. Précisément parlant, nous utilisons des graphiques pour modéliser les relations grammaticales entre les paires de mots. Notre méthode représente les structures syntaxiques de documents tels que notre méthode est capable de détecter le plagiat, même si les mots dans un document sont réarrangée. Comme le montre la figure 1, les textes du tableau 1 sont différentes, mais leurs structures de graphes sont similaires dans notre transformation. le segment gâterie propose dans résoudre comme image problème de la segmentation de la vision graphique nous d'extrait d'impression proposer critère d'approche (a) Graphique A partir du texte Un traitement segments nous problème de segmentation vision impression graphique propose du critère d'extrait d'image en tant que (b) Le graphique B du texte B figure . 1 Un exemple de modélisation de documents sous forme de graphiques. 2.2 Denition de détection Plagiat Nous formalisons ici le problème. Nous considérons que la détection de plagiat monolingue dans ce travail. L'entrée est un ensemble DSRC de documents de source et un ensemble dsusp de documents suspects, le nombre minimum k de nœuds communs dans un sous-graphe candidat, et la longueur maximale δ d'un chemin, dont nous parlerons dans la section suivante. Compte tenu d'une source et un document suspect, notre tâche est de décider s'il existe des passages plagiés dans le document suspect et découvrir leurs passages source correspondants si les passages plagiés existent. Nous adoptons la dénition dans (Potthast et al., 2010). Laissez un plagiat s = <splg, dplg, SSRC, DSRC> comme 4-tuple qui contient un splg de passage dans un document DPLG qui comprend la version plagié d'un certain ssrc de passage de source dans le document DSRC. Compte tenu dplg, la tâche d'un détecteur de plagiat est de détecter s en signalant une détection de plagiat r = <rplg, dplg, rsrc, d'src> qui consi m d'un rplg de passage plagié dans le document prétendument DPLG et son rsrc source dans d'src. A r de détection est deni: r détecte s ⇐⇒ splg ∩ rplg 6 = ∅, SSRC ∩ rsrc 6 = ∅, et DSRC = d'src. 3 Approche proposée 3.1 Vue d'ensemble Nous transformons chaque document à un graphique, dans lequel les relations syntaxiques sont conservées entre les mots. Après la transformation, les textes similaires devraient avoir des structures similaires afin que nous proposons une mesure de similarité et un algorithme d'appariement de graphes. Notre approche comprend quatre procédures dans chaque cycle de détection: le pré-traitement, trans- formation, la correspondance et les étapes de post-traitement. Dans l'étape de pré-traitement, on obtient des lemmes, des décalages et des longueurs des mots et la détermination des relations de coréférence des pronoms par le Plagiat Academic Detecting Stanford graphiques algorithme 1: Transformer un document à un graphique d'entrée: Un document d, qui contient s1, s2 ,. . . , Des phrases sn sortie: un graphe G = <V, E> 1 G ← ∅; 2 pour i ← 1 à n faire 3 Γ ← tous les Relations de dépendance en Si; 4 foreach r ∈ Γ faire 5 r.ψ de commutation font 6 cas nsubj nsubj (r, Γ, G); Pause; 7 cas xsubj xsubj (r, Γ, G); Pause; 8 cas iobj iobj (r, Γ, G); Pause; Agent 9 cas (r, Γ, G); Pause; 10 cas de préparation de préparation (r, Γ, G); Pause; 11 cas prepc prepc (r, Γ, G); Pause; 12 cas partmod Parmod (r, Γ, G); Pause; 13 MergeNodes (G); 14 retour G; CoreNLP (Klein et Manning, 2003. Raghunathan et al, 2010). Nous allons discuter des étapes et trans- formation correspondants dans les sections 3.2 et 3.3, respectivement. Dans l'étape de post-traitement, nous transformons les paires de découvertes semblables à leurs sous-graphes passages correspondants. Nous ob- TAIN un passage plagié en incluant des mots situés dans la gamme des compensations minimales et maximales des mots entre les nœuds du sous-graphe. Nous utilisons le cas d'un seul document suspect et un document source pour simplifier des discussions. Nous pouvons obtenir des résultats de dsusp et DSRC en effectuant des courses nsuspnsrc, où nsusp et nsrc représentent le nombre de documents dans dsusp et DSRC, respectivement. Laissez un document suspect et un document source soient dsusp et DSRC, respectivement. Laissez les graphiques générés par dsusp et DSRC dans l'étape de transformation soient G et H, respectivement. G et H sont des graphes orientés, et des noeuds et des arêtes qui représentent des étiquettes de mots. V (G) et E (G) l'ensemble de noeuds et l'ensemble des arêtes de G, respectivement. LG (v) et LG (x, y) représentent des étiquettes de noeud v et le bord (x, y) à G, respectivement. LG (v) est abrégé L (v) quand il n'y a pas d'ambiguïté. 3.2 Transformation de graphes Nous pensons que les noms sont des éléments essentiels dans une phrase et les verbes ou prépositions sont généralement liés à des noms. Ainsi, nous considérons intuitivement les noms et les verbes en tant que nœuds ou prépositions arêtes dans la transformation. parlant Intuitivement, si nous sommes en mesure de trouver un verbe ou préposition concernant deux noms, nous créons un lien dirigé entre eux. Au lieu de tirer directement des positions de mot, nous dérivons la représentation graphique du texte par la modélisation des relations grammaticales entre les mots. Algorithme 1 montre une vue d'ensemble de la transformation des phrases dans le document d au graphe G. On invente des procédures dans des lignes de 6 à 12 pour générer des noeuds et des arêtes B. Chou et E. Suzuki fonction PREP (r, Γ, G) Entrée: Une relation de préparation r = <ψ, wgov, wdep>, où ψ représente une chaîne de préparation avec la combinaison d'une préposition par un trait de soulignement (par exemple, prep_into), l'ensemble de Γ de relations de la phrase qui r appartient, et le graphique G = <V, E> sortie: Mise à jour graphique G 1 si r.wgov est un verbe, puis 2 R ← rFindDobj (r, r.wgov, Γ); 3 R ← R ∪ rFindNsubj (r, r.wgov, Γ); 4 R ← R ∪ rFindNsubjpass (r, r.wgov, Γ); 5, tandis que R 6 = ∅ do 6 L (v) ← pop (R) .wdep; L (u) ← r.wdep; 7 e ← (v, u); L (e) ← r.wgov; Insert 8 v, u et E à G; / * Lors de l'insertion d'un nœud, v, nous vérifions s'il existe L (v) entre les étiquettes de nœud existant dans G * / 9 d'autre si r.wgov est un nom puis 10 L (v) ← r.wgov; L (u) ← r.wdep; 11 e ← (v, u); L (e) ← la préposition après le trait de soulignement dans ψ; 12 Insertion v, u et E à G; sur la base des relations grammaticales, à savoir, les relations de dépendance (explaine d ultérieurement). Après un graphique est généré, nous autres noeuds de fusion selon leur relationships.1 coréférence Identifier les relations grammaticales entre les noms, nous utilisons l'analyseur Stanford (version 2.0.1) (Klein et Manning, 2003), qui fournit les relations de dépendance tapée Stanford (de Marn- Effe et Manning, 2008). Une relation de dépendance est une simple description de la relation grammaticale entre les mots dans le format de triplets, <ψ, wgov, wdep>, ce qui représente une ψ relation grammaticale entre un mot de gouverneur wgov et un wdep mot à charge. Une phrase est composée d'un ensemble ordonné de relations de dépendance. Par exemple, la peine étant donné la détection communautaire est le problème des nœuds en cluster dans un graphique dans les communautés, l'une des relations obtenues, relation <dobj, regroupement, noeuds> indique que mot nœuds est un objet direct de regroupement de mots. Relation <prep_into, regroupement, communautés> indique que les communautés de mots accompagnés en est un modier préposition de regroupement verbe. Parce que les relations de dépendance ne contiennent pas nécessairement une seule paire de noms et un verbe / préposition représentant la relation entre les noms, nous faisons référence à des relations multiples pour obtenir les noms connexes et leur verbe / préposition dans la plupart des cas correspondants. L'intuition derrière les règles heuristiques est que nous voulons capturer autant de noms que possible des sujets, des objets ou des compléments de phrases. parlant spéciquement, nous e paires de noeuds, chaque paire est associée à un verbe / préposition, en recherchant des relations nsubj, passe nsubj- ou dobj. Nous considérons que les relations de dépendance impliquées dans la partie du sujet, l'objet et le complément d'une phrase comprennent les relations nsubj, xsubj, iobj, agent, préparation, prepc et 1Suppose v est fusionnée à son homologue u. Nous copions tous bords adjacents de v u et nous négligeons v dans le graphique. Détection académique Plagiat avec des graphiques partmod.2 Chacune des relations a une règle de recherche correspondante comme montré dans l'algorithme 1. Fonction montre de préparation que nous e mots connexes quand donné une relation où ψ est prep (préposition modier). En préparation de la fonction, indique r.wgov mot de gouverneur wgov de relation r. rFindDobj (r, r.wgov, Γ) retourne toutes les relations dobj situé en face de r dans Γ dont chacun des wgov est r.wgov.3 De même, nous pouvons dénir rFindSubj (·) et rFindNsubjpass (·). pop (R) ressorte une relation de l'ensemble R des relations. Avec la fonction de préparation, nous générons un sous-graphe de la phrase, noeud into-- → communauté, lorsque les relations données <dobj, regroupement, noeuds> et <prep_into, regroupement, communautés>. Le reste des règles heuristiques sont présentés dans la figure 3. 3.3 Graphique Matching Si deux textes sont semblables, leurs structures de graphique transformées devraient être similaires. Ainsi, nous interprétons une détection de plagiat comme la découverte d'une paire de sous-graphes similaires dans ce document. Ci-dessous nous dénir la similitude des deux sous-graphes et de proposer un algorithme de découverte. 3.3.1 Similitude Denition En raison de la diversité des expressions en langage naturel, une dénition de correspondance exacte limite sa capacité de découvrir similaires dans une sous-graphes application réelle. Pour détecter des textes similaires qui ont des graphiques différents, nous considérons dans notre correspondance dénition inexacte des sous-graphes similaires. Envisager des peines, TextRunner est un système qui extrait de l'OIE et relationnelle tuples TextRunner extraits relationnels tuples. On remarque que même s'il existe des mots supplémentaires (par exemple, l'OIE et système) dans la phrase première, les deux phrases ont toujours le même sens que les mots supplémentaires sont entre les mots communs (par exemple, TextRunner, tuples) de telle sorte que les mots supplémentaires fonctionner comme modiers. Au niveau graphique, nous appelons mots comme des noeuds communs et des mots supplémentaires comme des noeuds hors du commun. Nous dénit similaires en permettant des sous-graphes noeuds hors du commun d'exister dans le chemin entre les nœuds communs. Laissez un sous-graphe de G et un sous-graphe H g et h, respectivement. Prenons le cas de deux nœuds communs pour l'instant. G et h sous-graphes sont similaires subgr APHS si elles satisfont à: 1. (Noeud de similarité) Lg (α) = Lh (a) ∧ Lg (β) = Lh (b) 4 2. (Chemin de similarité) chemin (α, β) est similaire au chemin (a, b), où a et b sont des noeuds communs à g, et α et β sont des noeuds communs h. Les quatre noeuds sont des noeuds communs. Chemin (x, y) représente le chemin le plus court entre x et y. Comme il existe des noeuds hors du commun, nous considérons la similitude des chemins au lieu des bords. Denition. (Chemin similarité) Soit chemin chemin (v1, vl) le plus court chemin du noeud v1 à Vn dans G, et le chemin chemin (u1, um) est le plus court chemin du noeud u1 um isoniazide Si 0,5 | Chemin (v1, vl) | ≤ δ, | Chemin (u1, um) | ≤ δ et L (1-vl, vl) = L (um-1, um), on dit que les chemins Chemin (v1, vl) et le chemin (u1, um) sont similaires. 2nsubj, nsubjpass, DOBJ, xsubj, iobj, prepc et partmod représentent sujet nominal, sous réserve nominale passive, objet direct, le contrôle de l'objet, l'objet indirect, propositionnelle clausal modier et participial modier, respectivement. 3FindDobj (r, r.wgov, Γ) retourne toutes les relations de dobj situées à l'arrière de r, utilisés dans d'autres règles. 4Pour simplifier l'explication, nous ignorons le problème des synonymes ici. En fait, nous considérons synonymes de mots dans notre approche en vérifiant l'ensemble des synonymes d'un mot avec WordNet (Miller, 1995). En d'autres termes, L (x) = L (y) si x est un synonyme de y et sont donc les étiquettes des bords. 5Si il y a deux chemins les plus courts, nous vérifions les deux. B. Chou et E. Suzuki Algorithme 2: Vue d'ensemble de l'algorithme de découverte Entrée: Un graphe suspect G, un graphique de la source H, K, δ sortie: paires (g, h), de sous-graphes similaires entre G et H 1 (Vs, nous ) ← {v ∈ V (G), u ∈ V (H) | v et u sont des noeuds communs; il existe une relation de mise en correspondance une à une entre v et u}; 2 tandis que PopSeeds (Vs, nous) 6 = ∅ faire 3 (vs, nous) ← PopSeeds (Vs, nous); 4 vs si nous ne sommes pas inclus dans une paire quelconque de (g, h), puis 5 (g, h) ← jeu (G, H, vs, vu, δ); 6 si SimNodesNum (g, h) ≥ k puis 7 sortie (g, h); g ← ∅; h ← ∅; Soit p1 désigne chemin α → → x1 · · · → xn → β, où α et β sont des noeuds communs tandis que chaque xi représente un noeud rare. De même, nous dénit chemin p2 comme → y1 → · · · → YM → b. Pour dénir la similitude entre P1 et P2, nous devons considérer: le nombre maximum de nœuds hors du commun que nous autorisons dans les chemins (à savoir, la longueur maximale des chemins), et les étiquettes des bords. Plus les noeuds hors du commun sont autorisés, les sous-graphes sont les moins dissemblables. Par conséquent, nous avons fixé un seuil, δ, pour déterminer la longueur d'un chemin entre les nœuds communs. Nous dénit L (1-vl, vl) = L (um-1, um) en raison de deux raisons. Les nombres d'arêtes de V1 à Vn et ceux de u1 um peuvent être différentes si l'on compare chaque paire d'entre eux est difcile. De plus, comme indiqué dans les phrases, considérer qu'un casse plagiaires une phrase à part en insérant des phrases ou des clauses modier. Le dernier verbe ou préposition dans les phrases insérés est le bord de connexion d'un noeud commun donc nous pensons qu'il est plus important que d'autres. 3.3.2 algorithme Découverte Notre but est de découvrir des paires (g, h) de sous-graphes similaires maximale entre un graphique suspect G et un graphique H source dans notre algorithme. Avec les denitions dans la section précédente, nous pouvons déterminer si g avec deux noeuds communs a et β est similaire à h avec deux noeuds communs a et b. Si g et h sont similaires, nous pouvons encore utiliser α et β, et a et b comme semences et la recherche dans leur proximité agrandir g et h par concaténer nouvellement acquise sous-graphes g 'et h', qui ont aussi deux nœuds communs, g et h, respectivement. L'algorithme 2 montre une vue d'ensemble de l'algorithme de découverte. Nous Rst ème toutes les paires de noeuds communs. Nous ne correspond pas à v à d'autres noeuds si v est mis en correspondance au noeud u de sorte que chaque paire de noeuds a une relation un-à-un rapport de correspondance. Etant donné une paire de noeuds communs, nous recherchons leur maximale similaires en match des sous-graphes (·). Puisque nous comparons mots du début à la fin des textes, PopSeeds (·) retourne nœuds communs dans leur ordre. Si un sous-graphe retourné a quelques noeuds communs, à savoir, moins de seuil k, nous le considérons comme une découverte banale que nous détruisons, vérifié en fonction SimNodesNum. SimNodesNum (· ) Renvoie le nombre de noeuds communs entre une paire de sous-graphes. montre match de la façon dont nous fonction recherche d'une paire de semblables. maximale des sous-graphes Notre straté- gie est de vérifier si nous pouvons développer un sous-graphe d'un noeud commun à un sous-graphe de deux noeuds communs et ainsi de suite, jusqu'à ce qu'aucun des noeuds les plus courants peuvent être inclus dans le graphique. Détection Academic Plagiarism avec correspondance graphes de fonction (G, H, vs, nous, δ) Entrée: G, H, les noeuds de semences vs et nous, la longueur d'un chemin δ sortie: Nodes V (g), V (h) de la sous-graphes g , h / * nous estimons que le passage d'un sous-graphe candidat de nœuds, qui ont des informations de décalages de caractères et longueurs pour que nous générons que les nœuds g et h dans notre mise en œuvre. * / 1 g ← ∅; h ← ∅; S1 ← ∅; S2 ← ∅; 2 V (g) ← V (g) ∪ {vs}; V (h) ← V (h) ∪ {nous}; S1 ← S1 ∪ {vs}; S2 ← S2 ∪ {nous}; 3 4 v répétition ← pop (S1); u ← pop (S2); (V, U) ← FindCandiNodes (G, H, v, u, δ); 5 foreach (x, y) ∈ (V, U) faire 6 s'il existe un chemin entre v et x && il existe un chemin entre u et y puis 7 si x et y ne sont pas inclus dans une paire quelconque de (g, h ) && PathSim (v, x, u, y), alors V 8 (g) ← V (g) ∪ {x}; V (h) ← V (h) ∪ {y}; 9 S1 ← S1 ∪ {x}; S2 ← S2 ∪ {y}; 10 jusqu'à ce que S1 = ∅, S2 = ∅; 11 V retour (g), V (h); FindCandiNodes (G, H, v, u, δ) nds noeuds communs qui sont proches de l'intérieur de la longueur de δ v ou u dans les graphiques sous-jacents obtenus par le remplacement de tous les bords dirigés avec des bords non orientés. Par exemple, FindCandiNodes (·) renvoie des noeuds adjacents du noeud v qui sont des noeuds communs dans la version non orienté de G lorsque δ = 1. Dans PathSim (v, x, u, y), on vérifie à la fois σ1 de similarité entre le chemin (v, x) et le chemin (u, y) et σ2 similitude entre le chemin (x, v) et le chemin (y, u). PathSim (v, x, u, y) renvoie vrai lorsque l'σ1 σ2 ou est vrai et retourne faux, sinon. 4 expériences Nous comparons notre méthode avec une méthode n-grammes naïf, qui utilise des mots de contenu comme la représentation d'un document, et un état de l'art méthode appelée SWNG (mots vides n-grammes méthode) (Stamatatos, 2011). Dans SWNG, θ, qui est une limite supérieure de longueur d'intervalle permis dans un passage, est établie pour être 100 comme l'indique l'auteur. Nous examinons de nombreuses valeurs de n utilisées dans la méthode et SWNG n-grammes naïfs dans nos expériences et nous montrons les résultats lorsque n = 5, 6 que nous considérons comme les meilleures performances. Dans notre méthode, k, qui est un seuil de décider du nombre minimal de nœuds communs requis dans un sous-graphe de sortie, est réglé pour être 3. Une valeur de δ implique que beaucoup de mots rares sont autorisés à être inclus dans les paires de sous-graphes similaires. Pour éviter la découverte de passages différents, nous avons mis δ à une faible valeur, δ = 2. B. Chou et E. Suzuki 4.1 ensembles de données et métriques d'évaluation Nous utilisons l'ensemble de données réseau DBLP-citation (Tang et al., 2008) nos expériences, où chaque enregistrement, par exemple, un article, des informations sont assignées généralement des auteurs, le lieu, Ørences abstraits, réfé- et publication year.From le réseau de citations de jeu de données, nous préparons deux ensembles de données, DBLP1 et DBLP2, utilisés pour examiner les performances des méthodes lorsque la totalité du contenu d'un document est plagié et qu'une partie du contenu d'un document est plagié, respectivement. Dans ensemble de données DBLP1, nous sélectionnons un ensemble de documents D, qui sont publiés dans les actes de conférences de haut niveau telles que KDD et utiliser leurs résumés DSRC comme documents de test dans les expé- riences. Pour chaque document d en D, nous préparons un document plagié correspondant dplg par des phrases de fractionnement, ré-organisation et des phrases re-commande sans modifier le contenu, en ajoutant des mots mineurs et en remplaçant au hasard des noms et des verbes avec des mots de leurs ensembles de synonymes par WordNet (Miller , 1995). Nous utilisons également des résumés Dref des documents cités dans les documents de D pour faux-fuyants. En résumé, les documents suspects dsusp comprennent tous les documents plagiés DPLG et Dref. | DSRC | = 20. | dsusp | = 89, où | Dref | = 69, qui sont des documents non plagiés, et | Dplg | = 20, qui sont des documents plagié. Dans ensemble de données DBLP2, les documents source sont les mêmes que dans DBLP1. Il y a 100 documents suspects, parmi lesquels 31 et 69 documents sont partiellement plagié et documents non plagié, respectivement. La moitié des phrases dans chacun des documents partiellement plagié sont extraits d'un document dans Dplg et la moitié d'un des documents correspondant à Dref. Nous utilisons les mesures de précision, le rappel, la granularité et une mesure globale combinant précision, rappel et granularité, PlagDet, qui sont proposés pour la détection de plagiat (Potthast et al., 2010), pour évaluer les résultats expérimentaux. Soit S l'ensemble des plagiats dans les documents suspi- cieuses d'un corpus, et que R représentent l'ensemble des détections de plagiat qui a des rapports de détection. Pour simplifier la notation, un plagiat s, s ∈ S, est représenté comme un ensemble de références à des caractères de dplg et DSRC qui forment les passages de la SSRC et. De même, une détection de plagiat r, r ∈ R, est représenté par r. prec (S, R) = 1 | R | Σ r∈R | Ss∈S (sur) | | R | rec (S, R) = 1 | S | Σ s∈S | Sr∈R (sur) | | S | où sur = s∩r si r Détecte de, et sur = ∅ autrement. Un score élevé de précision représente que bon nombre des passages détectés sont des passages plagié. Un score élevé de rappel représente que le détecteur identies de nombreux passages plagiés. Parce que les détecteurs de plagiat peuvent signaler ou plusieurs détections qui se chevauchent pour un plagiat unique, nous utilisons la mesure de granularité en plus de précision et de rappel. (. Pot- thast et al, 2010) La granularité est deni comme, gran (S, R) = 1 | SR | Σ s∈SR | R |, où SR ⊆ S sont des cas détectés par R dans les détections et Rs de R sont de s détections. Un score élevé de granularité représente que de nombreux segments sont présentés comme détections du même passage plagié. La combinaison de la précision, le rappel et la granularité, PlagDet est deni comme PlagDet (S, R) = F1 log2 (1 + gran (S, R)), où F1 = 2 · prec (S, R) · rec (S, R ) prec (S, R) + rec (S, R). Les valeurs de précision, le rappel et PlagDet, sauf plage de granularité de 0 à 1. La valeur minimale et idéal pour la granularité est égal à 1. 4.2 Résultats expérimentaux Les figures 2 (a) et 2 (b) montrent des résultats expérimentaux sur les ensembles de données DBLP1 et DBLP2, re - pectivement. Des chiffres, nous voyons que notre méthode surclasse SWNG et la méthode naïve grammes n- dans les expériences de détection des deux passages totalement et partiellement plagié. Détection Academic Plagiarism avec précision les graphiques de rappel PlagDet Granularité 0 0,0 0 0,5 1 0,0 1 0,5 2 0,0 0 0,0 0 0,5 1 0,0 Proposition SWNG (n = 5) SWNG (n = 6) n-grammes ( n = 5) n-grammes (n = 6) (a) DBLP1 résultats de précision de rappel PlagDet Granularité 0 0,0 0 0,5 1 0,0 0 0,0 0 0,5 1 0,0 0,5 1 Proposition SWNG (n = 5) SWNG (n = 6) n-grammes (n = 5) n-grammes (n = 6) (b) DBLP2 ​​résultats FIG. 2 résultats expérimentaux sur les ensembles de données DBLP1 et DBLP2. Bien que notre méthode a tendance plus grande à obtenir des résultats qui se chevauchent que SWNG, qui est observée à partir des valeurs de granularité, notre méthode permet d'obtenir des scores plus élevés sur la précision, le rappel et PlagDet que SWNG. Autrement dit, notre méthode montre sa compétitivité dans la détection des passages plagiés, qui sont en grande partie par des mots modied re-commande et des phrases. En comparant les deux figures, on constate que toutes les méthodes obtenir plus favorables ré- sultats dans les expériences de DBLP1 que dans les expériences de DBLP2. En effet, le problème de la détection des documents qui ont partiellement le contenu plagié est intuitivement plus difficile que le problème de la détection des documents que tout leur contenu sont plagié d'autres documents. En dépit de l'difculty du problème, les résultats de notre méthode sont encore supérieures à celles des SWNG et la méthode n-grammes. Nous examinons les graphiques que nous transformons du texte. Un graphique généré est parfois pas un graphe connexe en raison de la diversité des expressions en langage naturel. Étant donné que nos Détecte méthode passages plagiés en recherchant des noeuds communs le long de chemins dans le graphe, graphiques déconnectées peuvent provoquer des passages infructueux détections plagiés. Ceci est probablement la raison pour laquelle notre méthode ne permet pas d'atteindre des scores plus élevés sur le rappel de 0,6. Cependant, notre méthode est toujours efficace pour détecter le plagiat de réorganisées ou re-contre texte struits par rapport aux méthodes existantes, montrant l'avantage de la modélisation des relations entre les mots avec la structure graphique. 5 Conclusions et travaux futurs Nous avons proposé une méthode de détection de plagiat par la représentation des documents avec des graphiques. Nous transformons des documents à des graphiques en fonction des relations grammaticales entre les mots et découvrir des paires de sous-graphes similaires, dont chacun est une détection de plagiat. les résultats montrent que expérimentaux notre méthode améliore largement les valeurs de rappel et est plus efficace pour détecter le plagiat de paraphraser que les méthodes existantes. Dans notre travail futur, nous considérons comparer notre méthode avec d'autres méthodes fondées sur les graphiques utilisés pour détecter le plagiat de logiciels tels que GPLAG (Liu et al., 2006) et d'analyser la façon dont nos échelles de proposition en ce qui concerne le nombre et la taille des documents. Nous considérons aussi l'extension de notre méthode pour contrefaçon de brevet. B. Chou et E. Suzuki agent de fonctionnement (R, Γ, G) 1 R ← rFindNsubjpass (r, r.wgov, Γ); 2 Whiler 6 = ∅ faire 3 L (v) ← pop (R) .wdep; 4 L (u) ← r.wdep; 5 e ← (v, u); L (e) ← r.wgov; Insert 6 v, u et e TOG; Fonction partmod (r, Γ, G) 1 R ← toutes les relations à l'arrière de chacun des r whosewgov est r.wdep; 2 Whiler 6 = ∅ faire 3 L (v) ← r.wgov; 4 L (u) ← pop (R) .wdep; 5 e ← (v, u); L (e) ← r.wdep; Insert 6 v, u et e TOG; Fonction nsubj (r, Γ, G) si une r.wgov est un verbe, puis 2 R ← FindDobj (r, r.wgov, Γ); 3 Whiler 6 = ∅ do 4 γ ← pop (R); 5 L (v) ← r.wdep; L (u) ← γ.wdep; e ← (v, u); L (e) ← r.wgov; 6 V ← V ∪ {v}; V ← V ∪ {u}; E ← E ∪ {e}; 7 else if r.wgov est un nom puis 8 L (v) ← r.wdep; L (u) ← r.wgov; 9 e ← (v, u); L (e) ← soit; 10 V ← V ∪ {v}; V ← V ∪ {u}; E ← E ∪ {e}; Fonction xsubj (r, Γ, G) 1 R1 ← FindPrep (r, r.wgov, Γ); 2 whileR1 6 = ∅ faire 3 L (v) ← r.wdep; 4 L (u) ← pop (R1) .wdep; 5 e ← (v, u); L (e) ← pop (R1) .wgov; Insert 6 v, u et e TOG; 7 R2 ← FindDobj (r, r.wgov, Γ); 8 whileR2 6 = ∅ faire 9 L (v) ← r.wdep; 10 L (u) ← pop (R2) .wdep; 11 e ← (v, u); L (e) ← r.wgov; 12 Insertion v, u et e TOG; Fonction iobj (r, Γ, G) 1 R ← rFindNsubj (r, r.wgov, Γ); 2 Whiler 6 = ∅ faire 3 L (v) ← pop (R) .wdep; 4 L (u) ← r.wdep; 5 e ← (v, u); L (e) ← r.wgov; Insert 6 v, u et e TOG; Fonction prepc (r, Γ, G) si une r.wgov est un verbe, puis 2 R ← rFindDobj (r, r.wgov, Γ); 3 R ← R ∪ rFindNsubj (r, r.wgov, Γ); 4 R ← R ∪ rFindNsubjpass (r, r.wgov, Γ); 5 R '← FindDobj (r, r.wdep, Γ); 6 Whiler 6 = ∅ do 7 γ1 ← pop (R); 8 Whiler '6 = ∅ do 9 γ2 ← pop (R'); 10 L (v) ← γ1.wdep; 11 L (u) ← γ2.wdep; 12 e ← (v, u); L (e) ← r.wdep; 13 Insertion v, u et e TOG; 14 else if r.wgov est un nom puis 15 R ← FindDobj (r, r.wdep, Γ); 16 Whiler 6 = ∅ faire 17 L (v) ← r.wgov; 18 L (u) ← pop (R) .wdep; 19 e ← (v, u); L (e) ← r.wdep; FIGUE. 3 Règles pour l'agent de fonctions, partmod, nsubj, iobj, xsubj, prepc Remerciements. Ce travail a été soutenu par la JSPS KAKENHI Grant Numéro 24800049, 21300053. Références de Marneffe, M.-C. et C. D. Manning (2008). Le Stanford dactylographié dépendances repré- sentation. Dans Proc. CrossParser, p 18.. Grman, J. et R. Ravas (2011). La mise en œuvre améliorée pour trouver Texte dans Similitudes grands ensembles de données - Bloc-notes pour PAN à CLEF 2011. Dans Proc. LA POÊLE. Détection académique Plagiat avec des graphiques Gustafson, N., S. M. Pera, et Y.-K. Ng (2008). Nowhere to Hide: Trouver plagié docu- ments Basé sur la peine similarité. Dans Proc. WI-IAT, pp. 690696. Hoad, T. C. et J. Zobel (2003). Les méthodes d'identification et Versioned ments. Plagié Docu Confiture. Soc. Inf. Sci. Technol. 54 (3), 203215. Howard, R. M. (1995). Plagiats, Authorships, et la peine de mort académique. Collège Anglais 57 (7), 788806. Klein, D. et C. D. Manning (2003). Précis Parsing Unlexicalized. Dans Proc. ACL, p. 423430. Liu, C., C. Chen, J. Han, et P. S. Yu (2006). GPLAG: Détection des logiciels Plagiat par la dépendance du programme d'analyse de graphe. Dans Proc. KDD, p. 872881. Miller, G. A. (1995). WordNet: Une base de données lexicales pour l'anglais. Commun. ACM 38, 3941. Potthast, M., B. Stein, A. Barrón-Cedeño, et P. Rosso (2010). Un cadre d'évaluation pour la détection Plagiat. Dans Proc. COLING, p. 9971005. Raghunathan, K., H. Lee, S . Rangarajan, Chambers N., M. Surdeanu, D. Jurafsky et C. ning Homme- (2010). Un multi-passes pour Sieve Coréférence résolution. Dans Proc. EMNLP, p. 492501. Rosamond, B. (2002). Plagiat, normes académiques et la gouvernance de la profession. Politique 22 (3), 167174. Schleimer, S. (2003). Vanner: Algorithmes local pour le document Fingerprinting. Dans Proc. SIGMOD, p. 7685. Seo, J. et B. Croft (2008). Détection réutilisation Texte local. Dans Proc. SIGIR, p. 571578. Shi, J. et J. Malik (2000). Coupes et Normalisé Segmentation d'images. IEEE Trans. PAMI, 888 905. Stamatatos, E. (2011). Sur la base de détection Plagiat Information sur la structure. Dans Proc. CIKM, p. 12211230. Tang, J., J. Zhang, L. Yao, J. Li, L. Zhang et Z. Su (2008). ArnetMiner: Extraction et exploitation minière des réseaux sociaux universitaires. Dans Proc. KDD, p. 990998. Dans cet article résumé, nous nous intéressons au probléme de la plagiats des détection in the world académique, Qui est un véritable including en raison EAÜ de la d'Accès aux facilité Internet de publications. Les methods de recherche d'classiques informations en couramment utilisées Detection of plagiarism se sur les mots basent VIDES et l'identication de signatures, et les utilisent des mots Séquences soi Presentent Tels articles Qu'ils Dans Les. CÉS approaches ne par détectent pas les situations qui en découlent de plagiarism un lorsqu'un auteur ar- ticle reconstruit en réordonnant et réorganisant les phrases. Dans CE Contexte, la structure de juin, plus graphè is Adaptée representer les relations verser Entre les Entités. Nous proposons AINSI Une nouvelle méthode de détection de nous plagiarism Dans Laquelle des Graphes répandrai utilisons representer des documents en modélisant les relations grammaticales Entre les mots. Les Résultats expéri- Que la Taux montrent Que nous proposons méthode Depasse deux methods de n-grammes et le AUGMENTE par des descendeur facts de 10 à Allant 20%.