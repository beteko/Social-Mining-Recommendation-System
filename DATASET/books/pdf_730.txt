 actes_non_num\351rotes pdf Binary Sequences and Association Graphs for Fast Detection of Sequential Patterns Selim Mimaroglu Dan A Simovici Bahcesehir University Istanbul Turkey selim mimaroglu gmail com University of Massachusetts Boston Massachusetts 02125 USA dsim cs umb edu Abstract We develop an efficient algorithm for detecting frequent patterns that occur in sequence databases under certain constraints By combining the use of bit vector representations of sequence databases with association graphs we achieve superior time and low memory usage based on a considerable reduction of the number of candidate patterns 1 Introduction Mining sequential patterns was originally proposed in Agrawal and Srikant 1995 where three algorithms AprioriAll AprioriSome and DynamicSome were introduced PrefixSpan based on the prefix projection idea was introduced in Pei et al 2001 SPADE Zaki 2001 performs space efficient joins on prefix based equivalence classes PRISM Gouda et al 2007 uses prime number encoding for support counting A related but distinct problem discussed in Mannila et al 1997 is finding frequent episodes in very long sequences SPAM Ayres et al 2002 finds sequential patterns using a bitmap representation An extension of SPAM which incorporates gap and regular expression constraints was achieved in Ho et al 2005 The GSP algorithm Srikant and Agrawal 1996 is similar to AprioriAll additionally it can handle three types of constraints minimum and maximum gap between consecutive elements of a sequence referred to as min_gap and max_gap and window size between rows When min_gap = 0 max_gap = ∞ and window_size = 0 the sequential patterns found by GSP are the classical sequential patterns as introduced in Agrawal and Srikant 1995 The algorithm cSPADE Zaki 2000 introduces similar constraints and it is implemented on top of SPADE SPIRIT Garofalakis et al 1999 is more general than both GSP and cSPADE as it deals with regular expression constraints In this note we describe SPAG an algorithm that combines the dual use of bit vector rep resentations of sequence databases with association graphs to achieve superior performance in identifying patterns in sequences 2 Apriori Frameworks on Sequence Sets We refer the reader to Simovici and Djeraba 2008 for mathematical concepts and nota tions Let I be a set of items and let Seq I be the set of sequences of items of I We consider a a graded poset P ≤ h where P ⊆ Seq I and h P −→ N referred to as the set of pat terns and a data set D defined as a sequence of sequences D = {s1 sn} ⊆ Seq Seq I A sequence Apriori framework is a triple P ≤ h D σ where σ is a relation between pat terns and data such that t ≤ t′ and t′ s ∈ σ implies t s ∈ σ Fast Detection of Sequential Patterns If x is a subsequence of y we denote this by x v y For y ∈ D and t ∈ P we define several partial functions form φ Seq I 2 −→ R such that Dom φ = { t y ∈ Seq I 2 | t v y} α t y = ` y − `y t β t y = `y t − ` t and ω t y as the number of occurrences of t in y for t y ∈ Seq I The function α t y measures the outer gap of t in y while β t y measures the inner gap of t in y For a fixed y if t is scattered in y then α t y is relatively small and β t y is relatively large On another hand if t is condensed in y then α t y is relatively large and β t y is relatively small For example if t = a1a2 and y = a1a3a4a5a2 we have α t y = 0 and β t y = 3 If y′ = a3a4a1a2a5 then α t y′ = 3 and β t y′ = 0 The values of both functions α and β are changed as expected because t is condensed in y′ Let y be a database sequence u v be two sequences such that u is an infix of v and suppose that v v y If φ is any of the partial functions α or ω then φ u y ≥ φ v y We also have β v y ≥ β u y Let σmin k be the relation that consists of those pairs v y for which there exists an oc currence of v in y such that the least gap between two consecutive symbols of v is at least k Similarly if σmax k consists of pairs v y for which there is an occurrence of v in y such that the largest gap between two consecutive symbols of v is at most k These relations were introduced in Srikant and Agrawal 1996 The relationsσα k and σβ k are given by σα k = { v y ∈ Seq I 2 | v v y and α v y ≥ k} and by σβ k = { v y ∈ Seq I 2 | v v y and β v y ≤ k} It is easy to see that σmin k σmax k σα k and σβ k are Apriori relations If σ is an Apriori relation and u is an infix of v then supp D σ v ≤ suppD σ u This allows a straightforward extension of the well knownApriori algorithm to an algorithm defined on sequences 3 Association Graphs and Bit Vectors Storing bit vectors is very space efficient and bitwise operations are very fast which allows storing large databases into memory Each distinct item i in the database is represented by a bit vector denoted by ibvi item bit vector which contains as many bits as the number of rows in the database If i is present in the jth row the jth entry of ibvi is 1 and is 0 otherwise Each row of a table that contains m distinct items is represented by a collection of m row bit vectors rbv1 rbvm whose length l equals the length of the row If rbvj = bj1 bjl then bjh = { 1 if item ij occurs at position h 0 otherwise for 1 ≤ h ≤ l The dual use of item and row bit vectors speeds up the mining process considerably by providing fast support count A similar bit vector representation is used in PRISM Gouda et al 2007 where prime number encoding and integer operations are used instead of binary operations Next we define the association graph of a sequence database Definition 3 1 Let D = s1 sN be a sequence database on the set of items I min_sup be the minimum support count and σ be an Apriori relation The association graph of D S Mimaroglu and D A Simovici AG = V E is a labeled directed graph defined as follows The set of vertices V consists of those items i such that |{j| i sj ∈ σ and i v sj sj ∈ D for 1 ≤ j ≤ N}| ≥ min_sup The set of edges E consists of those pairs i i′ ∈ V × V such that |{j| ii′ sj ∈ σ and ii′ v sj sj ∈ D for 1 ≤ j ≤ N}| ≥ min_sup An edge i i′ is labeled by a se quence L i i′ = τ1 τN where τp = 1 if ii′ sp ∈ σ and ii′ v sp and τp = 0 otherwise for 1 ≤ p ≤ N Input Database D in ibv and rbv format minimum support count min_sup Apriori relation σ Output The Association graph AG = V E Create the vertices foreach item i do1 On each row such that ibvi is 1 check constraint if suppcount D σ i ≥ min_sup then2 V = V ∪ {i} 3 Create the edges with labels foreach i ∈ V do4 foreach i′ ∈ V do5 ibvT = ibvi ∩ ibvi′ 6 if ibvT count ≥ min_sup then7 On each row such that ibvT is 1 use the row bit vectors of i and i′ to compute if suppcount D σ ii ′ ≥ min_sup then8 E = E ∪ { i i′ } 9 label i i′ by ibvii′ 10 On each row such that ibvT is 1 use the row bit vectors of i and i′ to compute if suppcount D σ i ′i ≥ min_sup then11 E = E ∪ { i′ i } 12 label i′ i by ibvi′i 13 output AG 14 FIG 1 Association Graph Construction Algorithm In the C++ implementation of SPAG KFrequentC class represents the frequent sequences and stores the members of the sequence a bit vector which is set to 1 at the row indexes containing this sequence and for each row containing this sequence there may be more than one occurrence the end position s and the length s To extend a sequence p ∈ Fi there must be an edge from the last member of p to a frequent item in the association graph Since p ∈ Fi the length of p is i If there exists an edge from pi the last component of p to some other frequent item z then pi z ∈ E in the association graph AG Initially ibvpz is obtained as ibvpz = ibvp ∩ ibvpiz We must have count ibvpz ≥ min_sup Fast Detection of Sequential Patterns Input Database D minimum support count min_sup Apriori relation σ Output Frequent Sequences Read the database D convert the items in ibv format and convert the rows in rbv format1 Create the association graph AG = V E by using the Association Graph Construction2 Algorithm F1 = V 3 F2 = {ii ′| i i′ ∈ E} 4 i = 2 5 while Fi 6= ∅ do6 Ci+1 = {pz|p ∈ Fi pi z ∈ E |ibvpz = ibvp ∩ ibvpiz | ≥ min_sup pruneσ pz } 7 Use row bit vectors of z and information at KFrequentC of p to compute following Compute Fi+1 from Ci+1 8 i + + 9 FIG 2 Sequential Pattern Mining with Association Graph SPAG Algorithm Since σ is an Apriori relation all sequences q such that q is an infix of pz must be frequent If any q violates this condition it means that pz can not be frequent either so pruneσ pz returns false In Figure 2 these steps are represented in line 7 Following this actual frequent sequences are computed from the candidate set as shown in line 8 of Figure 2 Row bit vectors of z and the end positions of p are used to make sure that z follows p Rows violating this order or the constraint σ are set to 0 in ibvpz Checking the order and the constraint σ has to be done on every row of the database where ibvpz is initially set to 1 At the end of this procedure if the count ibvpz ≥ min_sup then pz is placed into Fi+1 Both Ayres et al 2002 and Ho et al 2005 use bit vectors and operations on bit vectors SPAG combines the use of bit vectors with association graphs and allows the use of vital global information Finding all occurrences of the items in a data set is immediate by using item bit vectors In addition association graphs handle what can follow an item in a data set this improves the candidate pattern generation process considerably Neither Ayres et al 2002 nor Ho et al 2005 have the global information provided by our dual use of item bit vectors and association graphs therefore they must keep track of each row Moreover the tremendous amount of bit vector transformations make both Ayres et al 2002 and Ho et al 2005 memory inefficient SPAG avoids these difficulties by working on the original bit vectors without modifying them 4 Experimental Results Extensive experiments were conducted on synthetically generated sequential data sets us ing a Pentium 3 0GHz computer having 4GB of main memory running on Linux The results of SPAG are compared with SPADE Zaki 2001 the implementation of Ho et al 2005 which we refer to as cSPAM and with cSPADE Zaki 2000 It is shown in Zaki 2001 that SPADE outperforms GSP by using space efficient joins Although cSPAM is not very space efficient it is fast because it uses bit vectors cSPAM S Mimaroglu and D A Simovici can also handle constraints cSPADE is implemented on top of SPADE it can handle some constraints Experimental results show that SPAG outperforms SPADE cSPADE and cSPAM in almost every support level for every data set In Figures 3 a 3 b and 3 c we show execution times a On a small database b On a medium database c On a large database d On a very large database e Minimum Gap f Maximum Gap FIG 3 Time comparison of cSPAM SPADE and SPAG for cSPAM SPADE and SPAG are shown for synthetic databases that range from 1 000 to 100 000 rows having 7 items per row on average and a total of 30 distinct items SPAG has superior performance on this data set for every support level On all these data sets SPAG out performs SPADE For only one support level cSPAM outperforms SPAG cSPAM and SPAG are comparable in two cases and for the remaining 13 cases SPAG performs much better than Fast Detection of Sequential Patterns cSPAM Experiments are expanded to include a larger data set of 100 000 rows having 1 000 unique items and 50 items per row on average Test results for this data set are shown in Fig 3 d In most cases SPAG outperforms SPADE by a factor of 10 Fig 3 e shows that SPAG and cSPADE perform similarly for the minimum gap constraint SPAG is 4 times faster than cSPAM in most cases SPAG clearly outperforms both cSPAM and cSPADE considerably for the maximum gap constraint as illustrated in Figure 3 f 5 Conclusions and Future Work We present SPAG an efficient algorithm for detecting frequent patterns which combines the dual use of bit vector representations of sequence databases with association graphs Ex perimental results show that SPAG is faster than the other state of the art algorithms cSPAM SPADE and cSPADE both with constraints and without constraints We believe that the SPAG has a broader applicability and its use for determining variability patterns or to frequency pat terns shall be investigated References Agrawal R and R Srikant 1995 Mining sequential patterns Proceedings of the Eleventh International Conference on Data Engineering 3–14 Ayres J J Flannick J Gehrke and T Yiu 2002 Sequential pattern mining using a bitmap representation In KDD pp 429–435 Garofalakis M N R Rastogi and K Shim 1999 Spirit Sequential pattern mining with regular expression constraints In VLDB pp 223–234 Gouda K M Hassaan andM J Zaki 2007 Prism A prime encoding approach for frequent sequence mining IEEE Int Conference on Data Mining Ho J L Lukov and S Chawla 2005 Sequential pattern mining with constraints on large protein databases In Proceedings of the 12th International Conference on Management of Data COMAD 2005b pp 89–100 Computer Society of India Mannila H H Toivonen and A Inkeri Verkamo 1997 Discovery of Frequent Episodes in Event Sequences Data Mining and Knowledge Discovery 1 3 259–289 Pei J J Han B Mortazavi Asl H Pinto Q Chen U Dayal andM Hsu 2001 PrefixSpan Mining Sequential Patterns Efficiently by Prefix Projected Pattern IEEE Int Conference on Data Engineering Simovici D A and C Djeraba 2008 Mathematical Tools for Data Mining – Set Theory Partially Ordered Sets Combinatorics London Springer Verlag Srikant R and R Agrawal 1996 Mining sequential patterns Generalizations and perfor mance improvements In EDBT pp 3–17 Zaki M J 2000 Sequence mining in categorical domains Incorporating constraints In CIKM pp 422–429 Zaki M J 2001 Spade An efficient algorithm for mining frequent sequences Machine Learning 42 1 2 31–60 Résumé Nous développons un algorithme efficace pour détecter des motifs fréquents qui se pro duisent dans des bases de données séquentielles sous certaines contraintes En combinant l’utilisation des représentations des bases de données séquentielles par séquences binaires avec des graphes d’association nous obtenons un meilleur temps et une utilisation moins grande de la mémoire basée sur une réduction considérable du nombre des motifs candidates 