(Actes_non_num \ 351rotes.pdf) séquences binaires et graphiques Association pour la détection rapide des motifs séquentiels Selim Mimaroglu *, Dan A. Simovici ** * Université Bahcesehir, Istanbul, Turquie, selim.mimaroglu@gmail.com ** Université du Massachusetts à Boston, Massachusetts 02125, Etats-Unis, dsim@cs.umb.edu Résumé. Nous développons un algorithme efficace pour détecter des motifs fréquents qui se produisent dans des bases de données de séquence sous certaines contraintes. En combinant l'utilisation des représentations de vecteur de bits de bases de données de séquences avec des graphiques d'association nous atteignons le temps supérieure et une faible utilisation de la mémoire basée sur une réduction considérable du nombre de motifs candidats. 1 Introduction Les mines motifs séquentiels a été initialement proposé dans Agrawal et Srikant (1995), où trois algorithmes, (AprioriAll, AprioriSome et DynamicSome) ont été introduits. PrefixSpan, basé sur l'idée de projection de préfixe, a été introduit dans Pei et al. (2001). SPADE Zaki (2001) l'espace PerForm efficace rejoint sur les classes d'équivalence à base de préfixe. PRISM Gouda et al. (2007), utilise le codage des nombres premiers pour le comptage de soutien. Un problème connexe mais distinct (discuté dans Mannila et al. (1997)) est de trouver des épisodes fréquents dans des séquences très longues. SPAM Ayres et al. (2002) trouve des motifs séquentiels en utilisant une représentation en mode point. Une extension de SPAM, qui intègre les contraintes d'espacement et d'expression régulière a été obtenue à Ho et al. (2005). L'algorithme GSP Srikant et Agrawal (1996) est similaire à AprioriAll; en outre, il peut gérer trois types de contraintes: écart minimum et maximum entre les éléments consécutifs d'une séquence (appelée min_gap et max_gap), et la taille de la fenêtre entre les rangées. Lorsque min_gap = 0, max_gap = ∞ et window_size = 0, les motifs séquentiels trouvés par GSP sont les motifs séquentiels classiques comme introduit dans Agrawal et Srikant (1995). L'algorithme cSPADE Zaki (2000) introduit des contraintes similaires, et il est mis en œuvre sur le dessus de SPADE. SPIRIT Garofalakis et al. (1999) est plus générale que les deux GSP et cSPADE car il traite des contraintes d'expression régulière. Dans cette note, nous décrivons SPAG, un algorithme qui combine la double utilisation du bit vecteur RESENTATIONS sentants des bases de données de séquences avec des graphiques d'association pour obtenir des résultats supérieurs dans l'identification des motifs dans les séquences. 2 cadres Apriori Sequence Définit Nous renvoyons le lecteur à Simovici et Djeraba (2008) pour des concepts mathématiques et nota- tions. Soit I un ensemble d'éléments, et laissez-Seq (I) l'ensemble des séquences d'éléments de I. Nous considérons aa poset graduée (P, ≤, h), où P ⊆ Seq (I), et h: P - → N, dénommés ensemble de sterne PAT-, et un ensemble de données D défini comme une séquence de séquences , D = {s1,. . . , Sn} ⊆ Seq (Seq (I)). Une séquence est un cadre Apriori triple ((P, ≤, h), D, σ), où σ est une relation entre sterne PAT- et des données, de telle sorte que t ≤ t 'et (t', s) ∈ σ implique ( t, s) ∈ σ. Détection rapide des motifs séquentiels Si x est une séquence de y, on note ceci en x v y. Pour y ∈ D, et t ∈ P on définit plusieurs fonctions partielles forment φ: (Seq (I)) 2 - → R tel que Dom (φ) = {(t, y) ∈ (Seq (I)) 2 | TVY}: α (t, y) = '(y) - `y (t), β (t, y) =' y (t) -` (t), et ω (t, y) que le nombre de occurrences de t à y, pour t, y ∈ Seq (I). L'α de la fonction (t, y) mesure l'écart externe de t en y, tandis que β (t, y) mesure l'écart interne de t y. Pour un y fixe, si t est dispersée en y alors α (t, y) est relativement faible, et β (t, y) est relativement grande. D'autre part, si t est condensé en y alors α (t, y) est relativement grande, et β (t, y) est relativement faible. Par exemple, si t = A1A2, et y = a1a3a4a5a2, nous avons α (t, y) = 0 et β (t, y) = 3. Si y '= a3a4a1a2a5, alors α (t, y') = 3 et β (t, y ') = 0. Les valeurs des deux fonctions a et β sont modifiés comme prévu, parce que t est condensé en y'. Soit y une séquence de base de données, u, v deux séquences telles que u est un infix de v et supposons que v v y. Si φ est l'une des fonctions partielles a ou ω alors φ (u, y) ≥ φ (v, y). Nous avons aussi β (v, y) ≥ β (u, y). Laisser σmin, k est le rapport qui se compose de ces paires (v, y) pour lesquels il existe une Currence OC- de v en y tels que le moindre écart entre deux symboles consécutifs de v est d'au moins k. De même, si amax, k est constituée de couples (v, y) pour lesquels il existe une occurrence de v en y de telle sorte que le plus grand écart entre deux symboles consécutifs de v est d'au plus k. Ces relations ont été introduites dans Srikant et Agrawal (1996). Le relationsσα, k et σβ, k sont donnés par σα, k = {(v, y) ∈ (Seq (I)) 2 | v v y et α (v, y) ≥ k} et par σβ, k = {(v, y) ∈ (Seq (I)) 2 | v v y et β (v, y) ≤ k}. Il est facile de voir que σmin, k, amax, k, σα, k et σβ, k sont des relations Apriori. Si σ est une relation Apriori et u est un infix de v, puis Supp D, σ (v) ≤ suppD, σ (u). Cela permet une extension directe de l'algorithme bien knownApriori un algorithme défini sur les séquences. 3 graphiques Association et Bit vecteurs vecteurs est bit Stockage des opérations spatiales très efficaces et sont très rapides au niveau du bit, ce qui permet de stocker de grandes bases de données en mémoire. Chaque i de l'article distinct dans la base de données est représenté par un vecteur de bits, noté ibvi (point vecteur de bits), qui contient autant de bits que le nombre de lignes dans la base de données. Si i est présent dans la ligne jème, l'entrée est jème ibvi 1, et 0 sinon. Chaque ligne d'une table qui contient des éléments distincts m est représenté par un ensemble de vecteurs de bits m rangée rbv1,. . . , Rbvm dont la longueur est égale à la longueur l de la ligne. Si rbvj = (BJ1,..., BJL) puis bjh = {1 si le point ij se produit à la position h, 0 sinon, pour 1 ≤ h ≤ l. La double utilisation des vecteurs de bits articles et ligne accélère le processus d'extraction considérablement en fournissant nombre de réponses rapides. Une représentation vectorielle de bits similaire est utilisée dans PRISM Gouda et al. (2007), où les opérations de codage des nombres premiers, et entiers sont utilisés à la place des opérations binaires. Ensuite, nous définir le graphe d'association d'une base de données de séquence. Définition 3.1 Soit D = (s1,..., Sn) est une base de données de séquence sur l'ensemble des éléments I, min_sup le nombre de support minimal, et σ est une relation Apriori. Le graphique de l'association de D, S. Mimaroglu et D. A. Simovici AG = (V, E) est un graphe orienté étiqueté défini comme suit. L'ensemble des sommets V est composé de ces éléments de telle sorte que i | {j | (i, sj) ∈ a et i v sj sj ∈ D, pour 1 ≤ j ≤ N} | ≥ min_sup. L'ensemble d'arêtes E est constitué des couples (i, i ') ∈ V × V tel que | {j | (ii', sj) ∈ σ et ii 'sj v, sj ∈ D, pour 1 ≤ j ≤ N} | ≥ min_sup. Un bord (i, i ') est marqué par une sé- quence L (i, i') = (τ1,..., ΤN), où τp = 1 si (ii ', sp) ∈ σ, et ii' v sp, et τp = 0, sinon, pour 1 ≤ p ≤ N. Entrée: Base de données: D IBV et format RBV, le nombre minimum de soutien: min_sup, relation Apriori: σ sortie: Le graphique Association, AG = (V, E) // Créer les sommets foreach point i dO1 // Sur chaque ligne de telle sorte que ibvi est égal à 1, contrainte de vérification si suppcount D, σ (i) ≥ min_sup lors2 V = V ∪ {i}; // 3 Insérer les bords des étiquettes foreach i ∈ V do4 foreach i 'V ∈ do5 ibvT = ibvi ∩ ibvi' ; 6 si ibvT .count () ≥ min_sup then7 // sur chaque rangée de telle sorte que ibvT est 1, en utilisant les vecteurs de bits de ligne de i et i 'pour calculer si suppcount D, σ (ii') ≥ min_sup then8 E = E ∪ {(i, i ')}; 9 étiquette (i, i') par ibvii '; 10 // sur chaque rangée de telle sorte que ibvT est 1, en utilisant les vecteurs de bits de ligne de i et i' pour calculer si suppcount D, σ (i 'i) ≥ min_sup then11 E = E ∪ {(i', i)}; 12 étiquette (i ', i) par ibvi'i; 13 sortie AG; 14 la Fig. 1: Association Graph Construction Algorithm Dans la mise en œuvre de C ++ de SPAG, classe KFrequentC représente les séquences fréquentes et stocke les membres de la séquence, un vecteur de bits qui est mis à 1 au niveau des indices de ligne contenant cette séquence, et pour chaque rangée contenant cette séquence (il peut y avoir plus d'une occurrence), la position d'extrémité (s) et la longueur (s). Pour prolonger une séquence p ∈ Fi il doit y avoir un avantage du dernier membre de p à un élément fréquent dans le graphe d'association. Depuis Fi p, la longueur de p est i. S'il existe un bord de pi, le dernier élément de p, à un autre élément fréquent z, puis (pi, z) ∈ E dans le graphique de l'association AG. Dans un premier temps, ibvpz est obtenu comme ibvpz = ibvp ∩ ibvpiz. Nous devons avoir le nombre (ibvpz) ≥ min_sup. Détection rapide des modèles d'entrée séquentielle: Base de données: D, le nombre minimum de soutien min_sup, relation Apriori: Sortie σ: séquences fréquentes Lire la base de données D, convertir les éléments en IBV format et convertir les lignes rbv format1; Créer le graphe d'association AG = (V, E) à l'aide de l'association graphique Construction2 algorithme; F1 = V; 3 F2 = {ii '| (i, i') ∈ E}; 4 i = 2; 5 tandis Fi 6 = ∅ DO6 Ci + 1 = {pz | p ∈ Fi, (pi, z) ∈ E, | ibvpz = ibvp ∩ ibvpiz | ≥ min_sup, pruneσ (pz)}; // 7 utiliser des vecteurs de bits de ligne de z, et des informations à KFrequentC de p pour calculer suivant Compute Fi + 1 à partir de Ci + 1; i + 8 + 9; la Fig. 2: Modèle séquentiel Mining avec l'Association Graphique (SPAG) algorithme Comme σ est une relation Apriori, toutes les séquences q tel que q est un infix de pz doit être fréquente. Si une q viole cette condition, cela signifie que pz ne peut être fréquent non plus, donc pruneσ (pz) retourne false. Sur la figure 2, ces étapes sont représentées à la ligne 7. Après cela, les séquences fréquentes réelles sont calculées à partir de l'ensemble candidat comme représenté sur la ligne 8 de la figure 2. vecteurs Row bits de z et les positions d'extrémité de P sont utilisés pour faire en sorte que z suit p. Les lignes violant cet ordre ou la contrainte σ sont à 0 dans ibvpz. Vérification de l'ordre et la contrainte σ doit être fait sur chaque ligne de la base de données où ibvpz est initialement fixé à 1. A la fin de cette procédure, si le nombre (ibvpz) ≥ min_sup, puis pz est placé dans Fi + 1. Les deux Ayres et al. (2002) et Ho et al. (2005) l'utilisation des vecteurs bit et les opérations sur les vecteurs de bits. SPAG combine l'utilisation de vecteurs de bits avec des graphiques d'association et permet l'utilisation de l'information mondiale vitale. Trouver toutes les occurrences des éléments dans un ensemble de données est immédiate en utilisant des vecteurs de bits de l'élément. En outre, des graphiques d'association gérer ce qui peut suivre un élément dans un ensemble de données; ce qui améliore le processus de génération de motif candidat considérablement. Ni Ayres et al. (2002), ni Ho et al. (2005) ont l'information globale fournie par notre double utilisation de vecteurs de bits de l'élément et des graphiques d'association; par conséquent, ils doivent garder une trace de chaque ligne. En outre, l'énorme quantité de transformations de vecteur de bits à la fois faire Ayres et al. (2002) et Ho et al. (2005) mémoire inefficace. SPAG évite ces difficultés en travaillant sur les vecteurs de bits d'origine sans les modifier. 4 Résultats expérimentaux Des expériences approfondies ont été menées sur des ensembles de données séquentielles générées synthétiquement US- un ordinateur Pentium ing 3.0GHz ayant 4 Go de mémoire principale sur Linux. Les résultats de SPAG sont comparés à SPADE Zaki (2001), la mise en œuvre de Ho et al. (2005) (que nous appelons cSPAM), et avec cSPADE Zaki (2000). Il est montré dans Zaki (2001) qui surclasse SPADE GSP en utilisant l'espace efficace rejoint. Bien que cSPAM n'est pas très efficace de l'espace, il est rapide, car il utilise des vecteurs de bits. cSPAM S. et D. Mimaroglu A. Simovici peuvent également gérer les contraintes. cSPADE est mis en oeuvre au-dessus de pique; il peut gérer certaines contraintes. Les résultats expérimentaux montrent que SPAG surclasse SPADE, cSPADE et cSPAM dans presque tous les niveaux de soutien pour chaque ensemble de données. Dans les figures 3 (a), 3 (b) et 3 (c), nous montrons les délais d'exécution (a) Sur une petite base de données (b) Sur une base de données de moyenne (c) Sur une grande base de données (d) Sur une base de données très importante ( e) écart minimal (f) Ecart maximal Fig. 3: Temps de comparaison de cSPAM, pelle, et SPAG pour cSPAM, pelle et SPAG sont présentées pour les bases de données synthétiques qui vont de 1, 000 à 100, 000 lignes, comportant 7 articles par rangée en moyenne, et un total de 30 articles distincts. SPAG a de meilleures performances sur cet ensemble de données pour tous les niveaux de soutien. Sur tous ces ensembles de données SPAG OUT- effectue SPADE. Pour un seul niveau de soutien cSPAM surclasse SPAG. cSPAM et SPAG sont comparables dans deux cas, et pour les 13 autres cas de les plus performant que la détection rapide des motifs séquentiels cSPAM. Des expériences sont élargies pour inclure un ensemble de données plus de 100.000 lignes ayant 1000 des objets uniques et 50 articles par rangée en moyenne. Les résultats des tests pour cet ensemble de données sont représentés sur la figure 3 (d). Dans la plupart des cas SPAG surpasse SPADE par un facteur de 10. Fig. 3 (E) montre que SPAG et cSPADE effectuer de même pour la contrainte de l'écart minimum. SPAG est 4 fois plus rapide que dans la plupart des cas cSPAM. SPAG surpasse clairement à la fois cSPAM et cSPADE considérablement pour la contrainte de l'écart maximum, comme illustré sur la figure 3 (f). 5 Conclusions et travaux futurs Nous présentons SPAG, un algorithme efficace pour détecter des motifs fréquents qui combine la double utilisation des représentations de vecteur de bits de bases de données de séquences avec des graphiques d'association. les résultats montrent que Perimental Ex- SPAG est plus rapide que les autres algorithmes état de l'art (cSPAM, Spade, et cSPADE) à la fois avec des contraintes et sans contraintes. Nous croyons que le SPAG a une application plus large et son utilisation pour la détermination des profils de variabilité ou à des modèles de fréquence doit être étudiée. Références Agrawal, R. et R. Srikant (1995). Exploitation minière motifs séquentiels. Compte rendu de la onzième Conférence internationale sur l'ingénierie des données, 3-14. Ayres, J., J. Flannick, J. Gehrke et T. Yiu (2002). extraction de motifs séquentiels en utilisant une représentation en mode point. En KDD, pp. 429-435. Garofalakis, M. N., R. Rastogi et K. Shim (1999). Esprit: extraction de motifs séquentiels avec des contraintes d'expressions régulières. En VLDB, pp. 223-234. Gouda, K., M. Hassaan, etM. J. Zaki (2007). Prism: Une approche premier codant pour l'extraction de séquences fréquentes. Int IEEE. Conférence sur l'exploration de données. Ho, J., L. Lukov et S. Chawla (2005). extraction de motifs séquentiels avec des contraintes sur grandes bases de données de protéines. Dans Actes de la 12e Conférence internationale sur la gestion des données (COMAD 2005b), pp. 89-100. Computer Society de l'Inde. Mannila, H., H. Toivonen et A. Inkeri Verkamo (1997). Découverte de épisodes fréquents dans les séquences d'événements. Data Mining et Knowledge Discovery 1 (3), 259-289. Pei, J., J. Han, B. Mortazavi-Asl, H. Pinto, Q. Chen, U. Dayal, etM. Hsu (2001). PrefixSpan: Exploitation minière motifs séquentiels par Pattern-Efficiently projeté Prefix. Int IEEE. Conférence sur l'ingénierie des données. Simovici, D. A. et C. Djeraba (2008). Outils mathématiques pour l'exploration de données - la théorie des ensembles, ensembles, Combinatoire partiellement commandé. London: Springer-Verlag. Srikant, R. et R. Agrawal (1996). Exploitation minière motifs séquentiels: Généralisations et l'amélioration des performances indiquées. En EDBT, p. 3-17. Zaki, M. J. (2000). l'extraction de séquences dans les domaines catégoriques: L'intégration de contraintes. En CIKM, pp. 422-429. Zaki, M. J. (2001). Spade: Un algorithme efficace pour l'extraction de séquences fréquentes. Machine Learning 42 (1/2), 31-60. Nous résumé de l'un algorithme des Efficace verser des motifs Détecter Fréquents Qui se pro- duisent des Dans Bases de données sous séquentielles CONTRAINTES CERTAINES. En Combinant L'utilisation des bases de des Représentations Données par séquentielles Avec des Séquences Graphes binaires d'association, NOUS ONU obtenons Temps et Une Meilleur ont utilisation MoiNs Grande de La Memoire basée Sur une réduction considérable des motifs du Nombre candidats.