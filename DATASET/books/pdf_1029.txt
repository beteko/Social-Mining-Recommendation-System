 Des motifs séquentiels généralisés aux contraintes de temps étendues Céline Fiot Anne Laurent Maguelonne Teisseire Laboratoire d’Informatique de Robotique et de Microélectronique de Montpellier 161 rue Ada 34392 Montpellier Cedex 5 {fiot laurent teisseire} lirmm fr Résumé Dans de nombreux domaines la recherche de connaissances tempo relles est très appréciée Des techniques ont été proposées aussi bien en fouille de données qu’en apprentissage afin d’extraire et de gérer de telles connaissances en les associant également à la spécification de contraintes temporelles e g fe nêtre temporelle maximale notamment dans le contexte de la recherche de mo tifs séquentiels Cependant ces contraintes sont souvent trop rigides ou néces sitent une bonne connaissance du domaine pour ne pas extraire des informations erronées C’est pourquoi nous proposons une approche basée sur la construction de graphes de séquences afin de prendre en compte des contraintes de temps plus souples Ces contraintes sont relâchées par rapport aux contraintes de temps précédemment proposées Elles permettent donc d’extraire plus de motifs per tinents Afin de guider l’analyse des motifs obtenus nous proposons également un niveau de précision des contraintes temporelles pour les motifs extraits 1 Introduction Dans un certain nombre de domaines détection de fraudes de défaillances analyse de comportements la recherche de connaissances temporelles est non seulement utile mais né cessaire Certaines techniques d’apprentissage permettent de gérer et de raisonner sur de telles connaissances Allen 1990 a notamment défini des opérations sur des règles associées à des intervalles de temps Des techniques d’extraction de connaissances cherchent quant à elles à extraire des épisodes récurrents à partir d’une longue séquence Mannila et al 1997 Raissi et al 2005 ou de bases de séquences Agrawal et Srikant 1995 Masseglia et al 1998 La recherche de telles informations devient d’autant plus intéressante qu’elle permet de prendre en compte un certain nombre de contraintes entre les évènements comme par exemple la durée minimale ou maximale séparant deux évènements C’est dans ce cadre qu’a été introduite la recherche de motifs séquentiels généralisés dans Srikant et Agrawal 1996 Cette technique de fouille de données permet d’obtenir des sé quences fréquentes respectant des contraintes spécifiées par l’utilisateur à partir d’une base de données de séquences par exemple les achats successifs de différents clients d’un supermar ché Différents algorithmes ont été proposés afin de gérer ces contraintes soit directement dans 603 RNTI E 6 Des motifs séquentiels généralisés aux contraintes de temps étendues le processus d’extraction GSP Srikant et Agrawal 1996 soit à l’aide d’un pré traitement sur les séquences proposé dans GTC Graph for Time Constraint Masseglia et al 1999 Toutefois si ces méthodes sont efficaces et robustes elles ont pour principal inconvénient d’être spécifiées par l’utilisateur et nécessitent donc une bonne connaissance a priori des don nées et des durées à spécifier sous peine d’obtenir des connaissances peu pertinentes Des travaux ont été proposés afin de déterminer de manière automatique la fenêtre optimale d’ob servation pour la recherche d’épisodes dans une séquence Meger et Rigotti 2004 mais ils sont difficilement adaptables à l’extraction de motifs séquentiels et dans ce domaine aucun tra vail à notre connaissance ne propose une détermination automatique des contraintes de temps optimales Par ailleurs pour certaines applications il pourrait également être intéressant d’as souplir les contraintes spécifiées par les experts du domaine afin de compléter leurs connais sances Enfin le nombre de motifs séquentiels extraits selon les contraintes de temps utilisés peut rapidement devenir trop important pour que leur analyse soit efficace Une mesure per mettant l’exploitation des motifs séquentiels généralisés serait donc d’une grande utilité C’est pourquoi nous proposons d’étendre les contraintes de temps proposées pour l’ex traction de motifs séquentiels généralisés en utilisant certains principes de la théorie des sous ensembles flous Notre méthode permet en effet à partir de contraintes de temps initiales et d’un degré de respect de ces valeurs d’extraire des motifs séquentiels respectant des contraintes étendues et de fournir pour chacun d’eux sa précision temporelle Nous offrons ainsi à l’uti lisateur une flexibilité dans la spécification de ses contraintes ainsi qu’un outil d’analyse des nombreuses séquences fréquentes extraites Après avoir présenté les concepts fondamentaux associés aux motifs séquentiels et aux mo tifs séquentiels généralisés dans la section 2 nous présentons dans la section 3 notre définition des contraintes de temps étendues La section 4 présente notre proposition d’algorithme met tant en oeuvre la gestion des contraintes de temps étendues lors du prétraitement des données La section 5 présente ensuite quelques expérimentations montrant la faisabilité et l’efficacité de notre approche Enfin la section 6 conclut sur les perspectives qu’ouvrent nos travaux 2 Des motifs séquentiels aux motifs séquentiels généralisés 2 1 Motifs séquentiels Les motifs séquentiels ont initialement été proposés par Agrawal et Srikant 1995 et re posent sur la notion de séquence fréquente maximale Prenons par exemple une base de données DB d’achats pour un ensemble C de clients c Une transaction t est un triplet <id_client id_date itemset> qui caractérise le client qui a réalisé l’achat la date d’achat et les items achetés Soit I = {i1 i2 · · · im} l’ensemble des items de la base Un itemset est un ensemble non vide et non ordonné d’items noté i1 i2 · · · ik Une séquence se définit alors comme une liste ordonnée non vide d’itemsets si qui sera notée < s1s2 · · · sp > Une n séquence est une séquence de taille n c’est à dire composée de n items Exemple 1 Si un client achète les produits a b c d et e selon la séquence < a b c d e > cela signifie qu’il a d’abord acheté le produit a puis les produits b et c ensemble ensuite seulement le produit d et finalement le produit e 604 RNTI E 6 C Fiot et al Une séquence S′ =< s′1s′2· · · s′m > est une sous séquence de S =< s1s2· · · sp > s’il existe des entiers a1 < a2 <· · ·< am tels que s′1 ⊆ sa1 s ′ 2 ⊆ sa2 · · · s ′ m ⊆ sam S ′ est incluse dans S Exemple 2 La séquence S ′ =< b e > est une sous séquence de S car b ⊆ b c et e ⊆ e Par contre < b c > n’est pas une sous séquence de < b c > ni l’inverse Les transactions de la base sont regroupées par client et ordonnées chronologiquement dé finissant ainsi des séquences de données Un client c supporte une séquence S si elle est incluse dans la séquence de données du client c Le support d’une séquence est alors défini comme le pourcentage de clients de la base DB qui supporte S Une séquence est dite fréquente si son support est au moins égal à une valeur minimale minSupp spécifiée par l’utilisateur La recherche de motifs séquentiels dans une base de séquences telle que DB consiste alors à trouver toutes les séquences maximales non incluses dans d’autres dont le support est su périeur à minSupp Chacune de ces séquences fréquentes maximales est un motif séquentiel 2 2 Motifs séquentiels généralisés Telle qu’elle a été introduite ci dessus la notion de séquence présente une certaine rigidité pour de nombreuses applications En effet si l’intervalle de temps entre deux transactions suc cessives est très court on pourrait envisager de les considérer comme simultanées A l’inverse deux évènements trop éloignés peuvent ne pas avoir de lien entre eux C’est pourquoi la no tion de séquence généralisée a été proposée par Srikant et Agrawal 1996 afin de pallier ces restrictions en introduisant la prise en compte de contraintes temporelles Ces contraintes sont au nombre de trois mingap est une durée minimale que l’on doit res pecter entre deux itemsets successifs d’une même séquence maxgap est l’écart maximal dans lequel doivent se trouver deux itemsets successifs windowSize est la fenêtre dans laquelle les items de deux transactions différentes peuvent être regroupés dans un même itemset On modifie alors la notion d’inclusion décrite précédemment pour tenir compte de ces contraintes Une séquence de données d =< d1 · · · dm > supporte une séquence s =< s1 · · · sn > s’il existe des entiers l1 ≤ u1 < l2 ≤ u2 < · · · < ln ≤ un donnant les dates de début et de fin des itemsets d1 · · · dn tels que si ⊂ ∪ ui k=li dk 1 ≤ i ≤ n et – date dui date dli ≤ windowSize 1 ≤ i ≤ n 1 – date dli date dui−1 > mingap 2 ≤ i ≤ n 2 – date dui date dli−1 ≤ maxgap 2 ≤ i ≤ n 3 Exemple 3 Soit les contraintes windowSize=1 mingap=0 et maxgap=7 les séquences d1 et d2 présentées TAB 1 et la séquence candidate s=< 1 2 3 4 > d1 et d2 supportent elles s Date 1 2 3 4 5 6 7 d1 Client 1 1 2 3 4 5 6 7 8 9 d2 Client 2 1 2 3 4 5 6 7 8 TAB 1 – base exemple s apparaît en regroupant les trois premiers itemsets de la séquence du client 1 FIG 1 a On a alors date dl1 =1 et date du1 =3 on ne respecte pas la contrainte 1 Donc s n’est pas 605 RNTI E 6 Des motifs séquentiels généralisés aux contraintes de temps étendues incluse dans la séquence d1 du client 1 Pour le client 2 FIG 1 b en regroupant les dates 1 et 2 date dl1 =1 et date du1 =2 on respecte les trois contraintes s est incluse dans d2 1 1 2 2 3 3 4 5 5 6 7 6 8 7 9 ws = 1 l1 = 1 u1 = 3 l2 = u2 = 5 l3 = u3 = 6 l4 = u4 = 7 a séquence du client 1 1 1 2 2 3 4 3 5 6 4 7 8 ws = 1 mg = 0 MaxG = 7 l1 = 1 u1 = 2 l2 = u2 = 3 l3 = u3 = 4 b séquence du client 2 FIG 1 – Représentation des contraintes de temps windowSize ws minGap mg et maxGap MaxG sur les séquences des clients 1 et 2 3 Vers des contraintes de temps étendues Dans cette section nous allons examiner la mise en œuvre des contraintes de temps éten dues par analogie avec la théorie des sous ensembles flous pour ensuite proposer leur définition et celle de la précision temporelle des séquences soumises à de telles contraintes 3 1 Mise en œuvre La théorie des sous ensembles flous introduite par Zadeh 1965 autorise l’appartenance partielle à une classe et donc la gradualité de passage d’une situation à une autre Cette théorie constitue une généralisation de la théorie ensembliste classique des situations intermédiaires entre le tout et le rien étant admises Dans ce cadre un objet peut donc appartenir partiellement à un ensemble et en même temps à son complément On considère par exemple l’univers des tailles possibles d’un individu Un sous ensemble flou A Petit ou Grand par exemple est défini par une fonction d’appartenance µA qui décrit le degré avec lequel chaque élément de l’univers considéré appartient à A ce degré étant compris entre 0 et 1 Ainsi un individu de 1m63 pourra à la fois être grand et petit avec par exemple un degré de 0 7 pour le sous ensemble flou Grand et 0 3 pour le sous ensemble flou Petit Les opérateurs en logique floue sont une généralisation des opérateurs classiques On consi dère notamment la négation l’intersection et l’union L’opérateur> ou t norme norme trian gulaire est l’opérateur binaire d’intersection µA∩B x = > µA x µB x L’opérateur⊥ t conorme conorme triangulaire est l’opérateur d’union µA∪B x = ⊥ µA x µB x Nous noterons> resp ⊥ l’opérateur> resp ⊥ généralisé au cas n aire Notre proposition d’extension des contraintes de temps pour les motifs séquentiels est fondée sur une analogie avec la théorie des sous ensembles flous Ainsi on ne souhaite plus simplement qu’une séquence respecte des contraintes spécifiées mais permettre à l’utilisateur de relaxer ces contraintes jusqu’à un certain seuil Ce seuil correspond à un degré minimal de satisfaction des contraintes temporelles Il sera spécifié par l’utilisateur pour chacune des contraintes de même que leur valeur initiale Soit ws g et G ces valeurs initiales pour les 606 RNTI E 6 C Fiot et al contraintes windowSize minGap et maxGap On considère ρws ρmg et ρMG les niveaux de précision associés à chacune d’elles ces niveaux étant compris entre 0 et 1 0 indique alors que l’on souhaite parcourir l’ensemble des valeurs possibles et 1 que le paramètre corres pondant est fixe L’utilisation de tels degrés implique de considérer plusieurs valeurs pour les paramètres windowSize mingap et maxgap Il est alors possible de considérer plusieurs “chemins” ou séquences dans les achats des clients pour reconstruire un motif Cependant cha cune de ces séquences respecte “plus ou moins” la contrainte initiale ce qui est évalué par les niveaux de précision ρws ρmg et ρMG dont le calcul est détaillé au paragraphe 3 3 3 2 Extension des contraintes de temps La définition des contraintes de temps étendues est basée sur les valeurs limites utiles que les différents paramètres peuvent prendre Ces valeurs utiles correspondent aux valeurs limites au delà desquelles on ne pourra générer de séquences candidates respectant les contraintes Prenons l’exemple de windowSize Dans le cas classique windowSize prend une valeur fixe ws et la condition 2 2 signifie que date dui −date dli ∈ J0 aK 1 ≤ i ≤ n Reprenons l’ensemble des clients C Pour chaque client c ses transactions ont des dates comprises entre Dcmin et Dcmax La contrainte 2 2 impose alors en considérant que date dui ≤ Dcmax et date dli ≥ Dcmin que windowSize ≤M = max c∈C Dcmax −Dcmin au plus windowSize vaut l’écart maximum pour tous les clients entre les dates minimales et maximales des tran sactions L’idée est donc de faire varier la valeur de windowSize entre sa valeur spécifiée ws et sa valeur maximum utile M Deux cas peuvent alors se présenter soit a ≥M dans ce cas l’algorithme classique suffit soit a < M et dans ce cas il faut compléter les parcours effectués dans le cas classique Afin de générer d’autres séquences candidates on va donc faire varier ici linéairement la valeur de windowSize entre ws et M comme le montre la FIG 2 Pour une valeur x de windowSize la précision des séquences générées sera donnée par une fonc tion d’appartenance µws x = 1ws−M x − M ws−M pour x ≥ a et 1 sinon La valeur maximale wsρ de windowSize pour un seuil de précision ρws est donc wsρ = b ws−M ρws + Mc FIG 2 – Variation de la précision selon la valeur de windowSize De même on a pour maxgap µMG x = 1G−M x− M G−M et Gρ = b G − M ρMG + Mc ainsi que µmg x = 1g−mx − m g−m et gρmg = d g − m ρmg + me pour mingap Le détail des calculs pour ces deux contraintes sont présentés dans Fiot et al 2005a Exemple 4 Reprenons l’exemple 3 On cherche à savoir si la séquence s=< 1 2 3 4 > est incluse dans les séquences des clients C1 et C2 en utilisant cette fois les paramètres ws=1 g=0 et G=7 avec ρws=0 5 ρmg=1 et ρMG=1 Seul le paramètre windowSize varie Avec M=6 et ws=1 on obtient aρ=2 windowSize prend donc successivement les valeurs 1 et 2 607 RNTI E 6 Des motifs séquentiels généralisés aux contraintes de temps étendues Pour windowSize=1 on retombe sur l’exemple 3 s est incluse dans d2 mais pas dans d1 Pour windowSize=2 pour le client 1 on a date dl1 =1 et date du1 =3 qui respecte bien la contrainte 2 2 Donc s est incluse dans d1 et toujours dans d2 3 3 Précision temporelle d’une séquence Pour chacune des séquences fréquentes trouvées à la fin du processus d’extraction on calcule la précision avec laquelle chacune d’elles respecte les contraintes de temps On définit la précision d’une séquence s pour un client c comme le degré de respect simultané des trois contraintes de temps 1 2 et 3 calculé à l’aide d’une t norme > Pour chaque client on cherche parmi toutes les séquences d’achats ςc l’occurrence de s qui respecte au mieux les contraintes de temps en utilisant une t conorme ⊥ La précision temporelle d’une séquence s =< s1 · · · sn > pour le client c est donnée par % s c = ⊥ s∈ςc “ >i∈[1 n] ` µws date sui − date sli ´ >i∈[2 n] ` µmg date sli − date sui−1 µMG date sui − date sli−1 ´” 4 Pour l’ensemble de la base le degré de respect des contraintes de temps est donné par la moyenne des degrés de chacun des clients c’est à dire Υ s = 1 |C| ∑ c∈C % s c 5 4 GETC Graph for Extended Time Constraints L’algorithme GTC proposé dans Masseglia et al 1999 permet de transformer une sé quence d’un client en un graphe de séquences respectant les contraintes de temps Les graphes de séquences des différents clients sont ensuite utilisés pour déterminer les séquences fré quentes par un algorithme d’extraction de motifs séquentiels tel que PSP Masseglia et al 1998 L’efficacité de cette approche ayant été démontrée dans Masseglia et al 1999 nous avons choisi de nous en inspirer pour développer la nôtre Nous proposons donc un algorithme permettant de construire un graphe de séquences pour les contraintes de temps étendues et également de calculer la précision des motifs séquentiels généralisés extraits 4 1 GETC les algorithmes A partir d’une séquence d’entrée d l’algorithme GETC construit son graphe de séquences Gd Cet algorithme regroupe un certain nombre de sous fonctions addEdge propagate pruneMarked et convertEdges non détaillées ici qui sont présentées de manière plus ap profondies dans Fiot et al 2005a GETC commence par créer les sommets correspondant aux itemsets de la séquence puis ajoute à l’ensemble des sommets l’ensemble des combinaisons d’itemsets permises selon les différentes valeurs de windowSize Pour cela l’algorithme addWindowSize non présenté ici parcourt chaque sommet x et détermine pour chacun d’entre eux quels autres sommets y peuvent être “fusionnés” avec x si y date x date ≤ ws Chaque sommet correspond 608 RNTI E 6 C Fiot et al GETC Input d une séquence de données Ouput Gd S A le graphe de séquences associé à d S l’ensemble des sommets de Gd A l’ensemble des arêtes Pour chq itemset i ∈ d faire S = S ∪{i} newLevel Fin Pour addWindowSize S Tant que x 6= S first faire l← x level prec mg ← g Tant que x begin l end ≤ mg faire contmg ← FALSE Si x begin > l end Alors [sinon sommet inclus] Tant que mg ≥ gρ faire Si x begin l end > mg Alors contmg ← TRUE mg ← gρ 1 Sinon mg Fin Si Fin Tant que Fin Si Si contmg == FALSE Alors propagate x l l← l prec Fin Si Fin Tant que Pour chq w ∈ l faire included← TRUE MG← G Tant que MG ≤ Gρ faire Si x end w begin ≤MG Alors addEdge w x MG← Gρ + 1 Sinon MG++ Fin Si Fin Tant que Fin Pour x← S next x Fin Tant que pruneMarked Gd S A convertEdges Gd S A Retourner Gd S A ALG 1 GETC alors à un itemset x itemset qui possède une date de début x begin et une date de fin x end Ces sommets sont regroupés en niveau par date de fin des itemsets Cela permet de tester le respect des contraintes pour un niveau et non pour chaque sommet On accède à l’ensemble des prédécesseurs d’un sommet x par x prev et à ces successeurs par x succ Ensuite pour chacun des sommets du graphe de séquences GETC ajoute les arcs respec tant les contraintes minGap et maxGap Ainsi pour chaque sommet on cherche le premier niveau accessible pour la contrainte minGap ie l begin x end > gρ et pour chaque sommet z de ce niveau on construit les arcs x z pour chaque sommet z tel que z end x begin ≤ maxGap La fonction addEdge permet d’éviter les inclusions de chemins grâce à la construction d’arcs temporaires dans des cas d’inclusions possibles L’algorithme addEdge construit les arcs entre des sommets qui respectent les contraintes de temps sur minGap et maxGap Il crée un arc définitif si les sommets ne sont pas déjà liés par une séquence ou une inclusion de leurs successeurs ou prédécesseurs Dans ce cas l’arc construit est temporaire et ne devient définitif que si la séquence qu’il forme est maximale C’est également lors de l’exécution de cet algorithme que les sommets inclus sont marqués pour pouvoir ensuite être supprimés s’ils sont inutiles Dans le cas où pour un sommet x on ne peut atteindre le niveau l à cause du non respect de la contrainte mingap on utilise la fonction propagate pour “propager ce saut” Pour chacun des sommets y de ce niveau inaccessible on ajoute si nécessaire et si on respecte les contraintes minGap et maxGap un arc entre chacun des successeurs de x et ce sommet y Comme dans addEdge on construit des arcs temporaires ou définitifs selon que la séquence construite peut 609 RNTI E 6 Des motifs séquentiels généralisés aux contraintes de temps étendues éventuellement être incluse ou au contraire n’a aucune chance de l’être Enfin l’algorithme pruneMarked élimine les sommets de sous séquences incluses Puis convertEdges supprime les arcs de sous séquences incluses pour tout arc temporaire de x vers y si y est inclus dans un successeur z de x et si les successeurs de y sont également tous des successeurs de z alors il existe une sous séquence incluse l’arc est supprimé Sinon l’arc est indispensable pour obtenir toutes les séquences maximales GETC étant utilisé comme prétraitement pour la prise en compte de contraintes temporelles en vue de l’extraction de motifs séquentiels il doit générer absolument toutes les séquences issues d’une séquence de données Par ailleurs afin d’améliorer le temps d’extraction il est nécessaire que GETC n’extraie que les séquences maximales nous avons donc montré dans Fiot et al 2005a que l’algorithme GETC construit exactement toutes les séquences de la plus grande taille possible pour les séquences respectant windowSize minGap et maxGap 4 2 Construction du graphe de séquences Nous utilisons GETC comme prétraitement pour la prise en compte des contraintes de temps étendues et PSP Masseglia et al 1998 pour l’extraction des motifs séquentiels Cette approche du type générer élaguer utilise une structure d’arbre prefixé pour organiser les sé quences candidates et permettre de trouver plus efficacement l’ensemble des candidats inclus dans une séquence de données En utilisant ainsi le graphe de séquences obtenu par GETC la vérification des contraintes de temps est rendue inutile pendant le parcours des candidats seule l’inclusion devant être vérifiée Cette méthode est similaire à celle proposée dans Mas seglia et al 1999 qui permet d’optimiser l’extraction de motifs séquentiels généralisés grâce à un parcours pour les contraintes de temps indépendant et sans retour arrière de l’arbre des séquences candidates et ainsi la vérification du moins de combinaisons possibles Exemple 5 On dispose de la base exemple TAB 2 et des paramètres suivants pour les contraintes de temps pour windowSize ws=2 et ρws = 0 87 donc aρ=4 pour maxGap G=4 et ρMG = 0 85 donc Gρ=6 pour minGap g=2 et ρmg = 0 5 donc gρ=1 Date 1 3 4 5 6 8 9 10 12 17 18 Client 1 1 2 3 3 4 4 4 5 6 7 8 Client 2 2 3 4 5 6 Client 3 1 2 3 3 4 4 5 6 TAB 2 – Base exemple Nous allons présenter ici la construction du graphe de séquences pour la séquence de données du client 1 La première étape consiste en la création de l’ensemble des sommets initiaux correspondants aux itemsets des transactions présentés dans la base de données TAB 2 La deuxième étape consiste à prendre en compte windowSize et les dates des différentes transactions afin de créer des sommets combinaisons grâce à la fonction addWindowSize La troisième étape est celle de la construction des arcs respectant les contraintes minGap et maxGap grâce à l’algorithme principal ainsi que les fonctions propagate et addEdge On obtient le graphe FIG 3 La fonction pruneMarked supprime ensuite les sommets mar qués Enfin les arcs temporaires sont convertis en arcs définitifs ou supprimés par la fonction convertEdges La FIG 4 présente le graphe de séquences final 610 RNTI E 6 C Fiot et al 1 2 3 3 4 * 4 4 5 6 7 * 8 * 1 2 3 1 2 3 4 2 3 4 4 5 5 6 4 5 6 7 8 |{z} I |{z} II |{z} III |{z} IV |{z} V |{z} VI |{z} VII |{z} VIII |{z} IX 1 2 3 4 5 6 7 8 910 11 12 13 14 15 16 17 18 19 FIG 3 – Graphe de séquence après la deuxième étape prise en compte de mingap et maxgap étendus 1 2 3 4 4 5 6 1 2 3 1 2 3 4 2 3 4 4 5 5 6 4 5 6 7 8 FIG 4 – Graphe de séquences fi nal pour le client 1 4 3 Calcul de la précision temporelle d’une séquence Une fois le graphe de séquences construit on connaît toutes les séquences autorisées par les contraintes de temps et celles qui sont interdites Cependant certaines séquences respectent les contraintes fortes de l’utilisateur alors que d’autres ont été construites en appliquant les contraintes étendues elles ne sont donc pas équivalentes On calcule alors la précision de cha cun des chemins séquences maximales et on l’affecte aux sous séquences qui le composent Afin de déterminer l’appartenance du chemin vis à vis des contraintes de temps on value chaque arc x y par > µmg y begin x end µMG y end x begin Chaque sommet est valué par windowSize La précision d’une sous séquence et donc le degré de respect des contraintes de temps est alors donnée par la formule 5 Grâce à l’algorithme valueGraph non présenté ici le graphe est alors parcouru et à chaque sommet s on attribue la va luation µws s end s begin et à chaque arc entre s et t la valuation > µmg t begin s end µMG t end s begin Exemple 6 A partir de la base de données TAB 2 et des contraintes de temps spécifiées dans l’exemple 5 on construit les trois graphes de séquences correspondants En prenant minSupp=70% on obtient six séquences maximales fréquentes < 2 3 4 > < 2 3 4 5 6 > < 2 4 5 > < 3 4 5 > < 3 4 6 > et < 3 4 5 > Elles ont toutes un support de 1 Il reste à déterminer la précision de respect des contraintes de temps initiales Pour cela chacun des graphes de séquences est valué comme précisé dans la section précédente Les sommets construits avec windowSize=0 1 2 ont un degré de 1 avec windowSize=3 un degré de 0 93 et avec windowSize=4 un degré de 0 87 De même les arcs construits avec mingap=1 ont un degré pour mingap de 0 5 et de 1 pour mingap=2 En ce qui concerne maxgap le degré est de 1 pour maxgap ≤4 de 0 92 pour maxgap=58 et 0 85 pour maxgap=6 La FIG 5 présente le graphe valué de la séquence du client 2 On utilise ensuite ces valuations pour calculer le degré de respect des contraintes de temps par les motifs extraits TAB 3 611 RNTI E 6 Des motifs séquentiels généralisés aux contraintes de temps étendues 2 3 1 4 1 5 1 6 1 2 3 4 1 4 5 0 93 5 6 1 0 51 1 0 5 0 5 0 5 1 FIG 5 – Graphes de séquences valués pour le client 2 Motifs séquentiels %Cl1 %Cl2 %Cl3 Υ < 2 3 4 > 1 1 0 87 0 96 < 2 3 4 5 6 > 0 5 0 5 0 5 0 5 < 2 4 5 > 0 85 0 5 1 0 78 < 3 4 5 > 0 85 1 1 0 95 < 3 4 6 > 0 5 0 5 1 0 67 < 3 4 5 > 0 85 0 5 0 5 0 62 TAB 3 – Calcul de la précision pour les motifs séquentiels extraits 5 Expérimentations Ces expérimentations ont été réalisées sur un PC équipé d’un processeur 2 8GHz et de 2Go de mémoire DDR sous systèmes Linux noyau 2 6 Le but de ces mesures est de comparer le comportement de GETC par rapport à GTC Pour certaines comparaisons nous utilisons également une implémentation de PSP intégrant ou non la gestion des contraintes de temps Les résultats présentés ici ont été obtenus à partir du traitement de plusieurs jeux de données synthétiques comportant environ 1000 séquences de 20 transactions en moyenne Chacune de ces transactions comportant en moyenne 15 items choisis parmi 1000 La première étape a consisté à comparer les temps d’exécution en l’absence de contrainte de temps c’est à dire en prenant windowSize = 0 minGap = 0 et maxGap = ∞ pour GTC ainsi que pour GETC avec une précision de 1 pour les trois paramètres Ainsi nous avons pu comparer le temps d’exécution de notre algorithme avec ceux de PSP et GTC La figure FIG 6 a montre que le comportement de GETC est similaire à celui de GTC et que les temps d’exécution sont quasiment identiques pour des motifs extraits qui sont les mêmes Nous avons ensuite répété ces mesures en introduisant le traitement de contraintes de temps toujours avec une précision de 1 afin de comparer le comportement de GETC et GTC pour la gestion de contrainte de temps non étendues La FIG 6 b montre l’évolution du temps d’extraction en fonction de la valeur de windowSize GETC a un comportement linéaire proche de celui de GTC La différence provient de la phase de traitement de la précision dont le temps augmente légèrement avec windowSize puisque si ce paramètre augmente on augmente le nombre de sommets dans le graphe de séquences La deuxième partie de nos expérimentations a porté sur l’analyse des motifs séquentiels extraits par GETC en fonction de la précision des différentes contraintes La figure FIG 6 c présente les temps d’extraction comparés de GTC et GETC en fonction du support minimum selon des valeurs choisies des différents paramètres Ces valeurs ont été calculées afin que les contraintes de temps utilisées pour GTC et GETC avec une précision de 1 correspondent aux valeurs limites de GETC avec une précision différentes de 1 Les paramètres retenus sont – GETC avec windowSize=0 minGap=1 et maxGap=5 avec une précision de 0 75 qui nous donne wsρ = 4 mgρ = 0 et MGρ = 10 – GETC avec windowSize=4 minGap=0 et maxGap=10 avec une précision de 1 – GTC avec windowSize=4 minGap=0 et maxGap=10 On peut constater que l’utilisation de GETC avec des contraintes de temps étendues n’est pas plus coûteuse que celle de GTC avec les valeurs limites des contraintes tout en permettant d’obtenir les mêmes motifs séquentiels accompagnés de leur précision temporel Il est inté 612 RNTI E 6 C Fiot et al ressant dans le cas où on ignore la valeur optimale d’une ou plusieurs contraintes de temps d’utiliser GETC avec une précision différente de 1 pour certains paramètres afin de balayer un ensemble de possibilités plus large L’analyse des motifs obtenus et de leur précision pourra renseigner sur une valeur plus adéquate des contraintes de temps Enfin la FIG 6 d montre l’évolution du temps d’extraction en fonction de la précision pour un support minimum de 0 37 On constate que le temps d’extraction atteint une valeur limite qui correspond à la valeur maximale utile des trois paramètres de contraintes de temps 0 50 100 150 200 250 300 350 0 3 0 4 tim e s ec minSupp Running time according to the minSupp value PSP GTC GETC a 0 20 40 60 80 100 120 1 2 3 4 5 6 tim e s ec windowSize Running time according to the windowSize value PSP GTC GETC b 0 500 1000 1500 2000 2500 3000 3500 4000 0 3 0 32 0 34 0 36 0 38 0 4 0 42 tim e s ec minSup Running time according to the minSup value GTC GETC 4 0 10 1 GETC 0 1 5 0 75 c 0 100 200 300 400 500 0 4 0 5 0 6 0 7 0 8 0 9 1 tim e s ec accurracy Running time according to the accurracy value GETC mg=1 MG=5 wS=1 GETC mg=1 MG=5 wS=0 GETC mg=0 MG=5 wS=2 GETC mg=0 MG=30 wS=30 d FIG 6 – Temps d’extraction a en fonction de minSupp en ne considérant aucune contrainte temps i e windowSize=0 minGap=0 maxGap=∞ and ρws = ρMG = ρmg = 1 b en fonction de windowSize avec minGap=2 maxGap=∞ and minSup=0 35 pour GETC ρws = ρMG = ρmg = 1 c en fonction de minSupp en considérant des contraintes de temps avec une précision de 1 ou non d en fonction de la précision selon différentes valeurs des contraintes de temps minSupp=0 37 6 Conclusion et perspectives Les motifs séquentiels généralisés présentés par Srikant et Agrawal 1996 permettent une définition plus large de l’inclusion en introduisant l’utilisation de contraintes de temps Toute fois cette définition reste encore trop rigide notamment dans le cas où l’utilisateur n’a qu’une vague idée des contraintes temporelles qui lient ses données Dans cet article nous proposons donc une extension des contraintes de temps pour les motifs séquentiels généralisés qui per met plus de souplesse dans la spécification des paramètres de contraintes temporelles Notre approche se base sur la construction de graphes de séquences pour intégrer les contraintes de temps dans le processus d’extraction de motifs séquentiels La faisabilité et la robustesse de cette méthode ont été montrées pour GTC dans Masseglia et al 1999 Le principe de GETC étant le même nous avons pu montrer son efficacité pour résoudre le probléme de la recherche de séquences généralisées avec des contraintes de temps étendues ou non et la similitude de son comportement avec celui de GTC Nous avons également pu mettre en évidence la flexi bilité offerte par la mise en place des contraintes étendues il nous reste encore à en valider la robustesse Enfin nous envisageons d’étendre les motifs séquentiels flous présentés dans Fiot et al 2005b à des motifs séquentiels généralisés avec contraintes de temps étendues ou non 613 RNTI E 6 Des motifs séquentiels généralisés aux contraintes de temps étendues Références Agrawal R et R Srikant 1995 Mining Sequential Patterns In 11th International Conference on Data Engineering Taipei Taiwan pp 3–14 IEEE Computer Society Press Allen J F 1990 Maintaining knowledge about temporal intervals Readings in qualitative reasoning about physical systems 361–372 Fiot C A Laurent et M Teisseire 2005a Contraintes de temps étendues pour les motifs séquentiels Technical Report 5056 LIRMM Fiot C A Laurent et M Teisseire 2005b Motifs séquentiels flous un peu beaucoup passionnément In 5èmes journées d’Extraction et Gestion des Connaissances EGC ’05 pp 507–519 Mannila H H Toivonen et A I Verkamo 1997 Discovery of frequent episodes in event sequences Data Mining and Knowledge Discovery 1 3 259–289 Masseglia F F Cathala et P Poncelet 1998 The PSP Approach for Mining Sequential Patterns In Principles of Data Mining and Knowledge Discovery pp 176–184 Masseglia F P Poncelet et M Teisseire 1999 Extraction efficace de motifs séquentiels généralisés le prétraitement des données In 15 ème Journée Bases de Données Avancées BDA ’99 pp 341–360 Meger N et C Rigotti 2004 Constraint based mining of episode rules and optimal window sizes In 8th European Conference on Principles and Practice of Knowledge Discovery in Databases PKDD’04 pp 313–324 Springer Verlag Raissi C P Poncelet et M Teisseire 2005 Need for speed Mining sequential patterns in data streams In 21 ème Journée Bases de Données Avancées BDA ’05 Srikant R et R Agrawal 1996 Mining sequential patterns Generalizations and perfor mance improvements In 5th International Conference on Extending Database Technology EDBT ’96 London UK pp 3–17 Springer Verlag Zadeh L 1965 Fuzzy sets Information and Control 3 8 338–353 Summary Mining temporal knowledge can be really useful in lots of fields Some methods have been proposed as well in data mining as in machine learning in order to extract and manage such knowledge using temporal constraints In particular some works have been proposed to mine generalized sequential patterns However these constraints are often too crisp or need a very precise assessment to avoid erroneous information Within this context we propose an approach based on graph of sequence built from extended temporal constraints These relaxed constraints enable us to find more generalized sequential patterns We also propose to measure the temporal accuracy of extracted sequences compared to the initial constraints 614 RNTI E 6