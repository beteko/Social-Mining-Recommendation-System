18 RNTI E33Extraction de chroniques discriminantes Yann Dauxais David Gross Amblard Thomas Guyet et André Happe Université Rennes 1 IRISA prenom nom irisa fr Agrocampus Ouest IRISA CHRU Brest équipe REPERE Résumé L’extraction de motifs séquentiels vise à extraire des comportements récurrents dans un ensemble de séquences Lorsque ces séquences sont étique tées l’extraction de motifs discriminants engendre des motifs caractéristiques de chaque classe de séquences Cet article s’intéresse à l’extraction des chro niques discriminantes où une chronique est un type de motif temporel représen tant des durées inter évènements quantitatives L’article présente l’algorithme DCM dont l’originalité réside dans l’utilisation de méthodes d’apprentissage automatique pour extraire les intervalles temporels Les performances compu tationnelles et le pouvoir discriminant des chroniques extraites sont évalués sur des données synthétiques et réelles 1 Introduction La fouille de données temporelles e g séries temporelles ou des séquences est dédiée à l’analyse de données portant une information temporelle De telles données sont largement ren contrées dans les domaines tels que la médecine l’ingénierie ou la finance Pour ces domaines l’aspect temporel est primordial et il est crucial de proposer des approches capables d’analyser ces données en tenant compte de cette spécificité Dans cet article nous nous concentrons sur l’extraction de motifs dans des séquences d’évènements datés Nous cherchons à extraire des motifs pouvant servir à discriminer précisément des comportements associés aux séquences Fradkin et Mörchen 2015 Il s’agit par exemple d’associer une suite d’évènements à l’état pathologique d’un patient L’extraction de motifs séquentiels i e tenant compte de la séquentialité des évènements mais pas de leurs dates a été largement étudiée et fait l’objet de plusieurs états de l’art Mas seglia et al 2004 Mooney et Roddick 2013 L’extraction de motifs séquentiels est efficace pour une contrepartie non négligeable l’information temporelle n’est pas prise en compte dans son intégralité Les motifs décrivant une information temporelle riche tels que les mo tifs d’intervalles Guyet et Quiniou 2011 ou les chroniques Dousson et Duong 1999 Cram et al 2012 Huang et al 2012 captent une information plus riche De ce fait leur utilisation permet des prédictions plus précises D’autre part et bien que l’objectif d’extraction de motifs séquentiels soit la prédiction d’évènements la plupart des approches de fouille se sont intéressées à extraire des motifs fréquents i e qui apparaissent fréquemment dans la base d’exemples L’extraction de motifs 165 Extraction de chroniques discriminantes fréquents et discriminants semble être une approche plus intéressante en vue de proposer des motifs qui permettront une prédiction plus précise De plus les motifs discriminants sont inté ressants pour réduire le nombre de motifs à extraire Face au problème bien connu du déluge de motifs cette approche semble pertinente pour se focaliser uniquement sur des motifs d’intérêt Dans l’objectif de proposer aux utilisateurs des motifs qui permettent une discrimination précise de séquences nous nous intéressons à la fouille de motifs temporels fréquents et dis criminant Pour la grande expressivité des chroniques et leurs propriétés algorithmiques nous nous intéressons plus précisément à l’extraction de chroniques fréquentes et discriminantes Cet article propose l’algorithme DCM pour extraire des chroniques discriminantes d’un jeu de données temporelles étiqueté Sa contribution majeure réside dans l’utilisation d’un algorithme d’apprentissage de règles relationnelles pour extraire les contraintes temporelles discriminantes 2 Travaux antérieurs Fradkin et Mörchen 2015 ont comparé plusieurs méthodes d’extraction de motifs séquen tiels discriminants allant du post traitement de l’ensemble des motifs fréquents à la construc tion d’un arbre de décision utilisant les motifs séquentiels Ce sont les algorithmes auxquels nous nous sommes comparés par la suite voir section 5 Des ordres partiels discriminants fermés sont extraits par Fabrègue et al 2014 pour fouiller des données liées à des écosystèmes aquatiques pollués Pour extraire ces motifs les ordres partiels fermés sont d’abord extraits de chacune des bases de données puis un post traitement est effectué pour ne retenir que ceux qui sont discriminants L’ensemble des ordres partiels discriminants est un sous ensemble de celui des chroniques discriminantes La défini tion d’ordre partiel correspond à celle d’épisode Mannila et al 1997 Des chroniques discriminantes ont déjà été extraites par Carrault et al 2003 Ces chro niques permettaient de décrire des problèmes d’arythmies cardiaques sur les données ECG L’inconvénient majeur de cette approche réside dans l’apport de connaissances expertes pour l’extraction et la reconnaissance des chroniques En particulier les intervalles temporels dis criminants ne sont pas directement extraits mais spécifiés initialement suivant différentes éti quettes tels que court normal et long Les motifs utilisés dans ces travaux n’apportent pas la richesse d’information contenue par les chroniques ou ne l’extrait pas directement des données De plus ces travaux utilisent des approches basées principalement sur un post traitement c’est à dire que l’ensemble des motifs discriminants est extrait à partir d’un plus gros ensemble de motifs et non directement comme ce qui a pu être fait avec les motifs émergents Dong et Li 1999 3 Définitions Cette section commence par introduire les définitions utiles puis définit le problème d’ex traction de chroniques discriminantes 166 Y Dauxais et al 3 1 Séquences et chroniques Soit E un ensemble de types d’évènement et T un domaine temporel tel que T ⊆ R un évènement est un couple e t tel que e ∈ E et t ∈ T L’ensemble E est supposé totalement ordonné et est noté ≤E Une séquence est un triplet 〈SID 〈 e1 t1 e2 t2 en tn 〉 C〉 tel que SID est l’indice de la séquence 〈 e1 t1 e2 t2 en tn 〉 est une séquence finie d’évènements et L ∈ L est une étiquette Les éléments de la séquence sont ordonnés selon un ordre ≺ défini par ∀i j ∈ [1 n] ei ti ≺ ej tj ⇔ i < j ∧ ti < tj ∨ i = j ∧ ei <E ej Exemple 1 Ensemble de séquences S Le tableau 1 représente un ensemble de 6 séquences contenant 5 types d’évènement A B C D et E et étiquetées par deux labels différents L = {+ −} Ce jeu de données sera réutilisé pour les exemples suivants SID Séquence Label 1 A 1 B 3 A 4 C 5 C 6 D 7 + 2 B 2 D 4 A 5 C 7 + 3 A 1 B 4 C 5 B 6 C 8 D 9 + 4 B 4 A 6 E 8 C 9 5 B 1 A 3 C 4 6 C 4 B 5 A 6 C 7 D 10 TAB 1 – Ensemble de six séquences appartenant à deux classes Une contrainte temporelle est un quadruplet e1 e2 t − t+ noté e1[t − t+]e2 tel que e1 e2 ∈ E e1 ≤E e2 et t − t+ ∈ T t− ≤ t+ Une contrainte temporelle e1[t − t+]e2 est dite satisfaite par un couple d’évènements e t e′ t′ ssi e = e1 e ′ = e2 et t ′ − t ∈ [t− t+] On notera e1[a b]e2 ⊆ e ′ 1[a ′ b′]e′2 ssi e1 = e ′ 1 e2 = e ′ 2 et [a b] ⊆ [a ′ b′] Une chronique est un couple E T tel que E = {{e1 en}} ei ∈ E et ∀i j 1 ≤ i < j ≤ n ei ≤E ej et tel que T est un ensemble de contraintes temporelles tel qu’il existe une contrainte temporelle dans T pour chaque paire d’éléments de E i e ∀e e′ ∈ E e ≤E e′ e[a b]e′ ∈ T L’élément E sera appelé un multiset i e E peut contenir plusieurs occurrences d’un même type d’évènement Dans la mesure où la contrainte e[a b]e′ est équivalente à e′[−b −a]e on utilise l’ordre sur les items ≤E pour orienter la contrainte entre deux évènements d’une chronique A B [ 1 3] C [ 3 5] [ 2 2 ] D [4 5] C [1 3] A B [2 3] C [4 5] [ 2 2 ] A C [ 3 1] C [2 4 ] FIG 1 – Exemple de trois chroniques apparaissant dans le tableau 1 cf exemples 2 et 3 L’absence d’arc entre deux évènements traduit une contrainte de la forme [−∞ ∞] Exemple 2 La figure 1 illustre sous forme de graphe trois chroniques La chronique C = E T où E = {{e1 = A e2 = B e3 = C e4 = C e5 = D}} et T ={e1[−1 3]e2 e1[−3 5]e3 e2[−2 2]e3 e2[4 5]e5 e3[1 3]e4} y est représentée à gauche On remarque que ce graphe n’est pas complet En l’absence d’arc entre deux évènements traduit une contrainte de la forme [−∞ ∞] i e qu’il n’y a pas de contrainte 167 Extraction de chroniques discriminantes 3 2 Support d’une chronique Soient s = 〈 e1 t1 en tn 〉 une séquence et C = E = {{e ′ 1 e ′ m}} T une chro nique Une occurrence de C dans s est une sous séquence d’évènements s̃ = 〈 ef 1 tf 1 ef m tf m 〉 tel qu’il existe une fonction f [1 m] 7→ [1 n] injective telle que 1 ∀i e′i = ef i et 2 ∀i j tf j − tf i ∈ [a b] où e ′ i[a b]e ′ j ∈ T Il faut noter que f n’est pas nécessairement croissante Ceci résulte de la différence entre i l’ordre du multiset d’une chronique défini sur les items et ii l’ordre des évènements dans une séquence ≺ définie par le domaine temporel La chronique C apparaît dans s noté C ∈ s s’il existe au moins une occurrence de C dans s Le support d’une chronique C dans un ensemble de séquences S est le nombre de séquences dans lesquelles C apparaît support C S = |{S | S ∈ S et C ∈ S}| Exemple 3 La chronique C à gauche de la figure 1 apparaît dans les séquences 1 3 et 6 du tableau 1 On remarque qu’il existe deux occurrences de C dans la séquence 1 On a support C S = 3 et cette chronique est fréquente dans S pour tout seuil de fréquence mini mal σmin inférieur ou égal à 3 Les deux autres chroniques de la figure 1 que l’on nommera C1 et C2 de gauche à droite apparaissent respectivement dans les séquences 1 et 3 et dans la séquence 6 On a donc support C1 S = 2 et support C2 S = 1 3 3 Extraction de chroniques discriminantes Soient deux bases de séquences S+ et S− et deux paramètres σmin et gmin donnés Une chronique est dite discriminante pour S+ ssi support C S+ ≥ σmin et support C S + ≥ gmin × support C S − Le taux de croissance g C S d’une chronique est défini comme égal à support C S+ support C S− si support C S − > 0 et égal à +∞ si support C S− = 0 Exemple 4 En reprenant la chronique C de la figure 1 support C S+ = 2 support C S− = 1 donc g C S = 2 c’est à dire que cette chronique est discriminante si gmin ≤ 2 Pour les chroniques C1 et C2 support C1 S + = 2 et support C1 S − = 0 donc g C1 S = +∞ et support C2 S + = 0 et support C2 S − = 1 donc g C2 S = 0 Donc pour toute valeur de gmin C1 est discriminante mais pas C2 L’utilisation d’une contrainte de fréquence en complément de la contrainte de discrimi nance évite des chroniques trop peu fréquentes et donc insignifiantes Par exemple une chro nique telle que C∞ pour laquelle support C S + = 1 et support C S− = 0 est considérée comme discriminante mais n’a que peu d’intérêt Le second avantage de cette contrainte de fréquence minimale est de réduire fortement le nombre de motifs à extraire en tronquant une partie généralement importante de l’espace de recherche contenant les motifs non fréquents Cette contrainte de fréquence est monotone et en particulier si une chronique 1 E T∞ n’est pas fréquente alors aucune chronique de la forme E T ne le sera Extraire l’ensemble complet des chroniques discriminantes n’est pas intéressant à cause de nombreuses chroniques discriminantes similaires Dans ce cas il est préférable d’extraire les chroniques pour lesquelles les contraintes temporelles sont les plus larges i e plus géné ralisatrices L’approche proposée dans la section suivante est incomplète Elle se focalise sur l’extraction efficace d’un sous ensemble des chroniques discriminantes que nous cherchons à être signifiant 1 T∞ est l’ensemble de contraintes temporelles dont toutes les bornes sont fixées à∞ 168 Y Dauxais et al 4 Algorithme DCM Cette section présente l’algorithme DCM pour l’extraction des chroniques discriminantes Algorithme 1 Algorithme DCM pour l’extraction de chroniques discriminantes Require S+ S− ensembles de séquences σmin fréquence minimum gmin croissance minimum 1 M← FINDMULTISET S+ σmin ⊲ M est l’ensemble des multisets fréquents 2 C← ∅ ⊲ C est l’ensemble des chroniques discriminantes 3 for all ms ∈ M do 4 if support S+ ms T∞ > gmin × support S− ms T∞ then 5 C← C ∪ { ms T∞ } ⊲ La chronique sans contrainte temporelle est discriminante 6 else 7 for all T ∈ EXTRACTDISCRCONSTRAINTS S+ S− ms gmin σmin do 8 C← C ∪ { ms T } ⊲ Ajout d’une nouvelle chronique discriminante 9 return C L’algorithme 1 illustre la procédure d’extraction des chroniques fréquentes discriminantes Cette dernière comporte deux étapes l’extraction des multisets fréquents puis la spécification des contraintes temporelles des multisets Dans un premier temps ligne 1 FINDMULTISET extrait les multisets d’items fréquents M Ceci est réalisé par un algorithme de fouille d’itemsets fréquents en construisant un jeu de données pour lequel chaque occurrence d’un même item a été numérotée Un item a ∈ E apparaissant n fois dans une séquence est encodé par n items Ia1 I a n Un itemset fréquent de taille m Iekik 1≤k≤m extrait à partir de ce jeu de données est transformé en le multiset contenant pour tout k ik occurrences de l’évènement ek Tous les itemsets fréquents contenant plusieurs occurrences d’un même item i e ∃i j ∈ [1 m] i 6= j tq ei = ej avec une cardinalité différente ont été préalablement supprimés car redondants Dans un second temps les lignes 3 à 11 extraient les contraintes temporelles de chaque multiset L’approche naïve dans laquelle les contraintes temporelles discriminantes sont ex traites pour chaque multiset fréquent a l’inconvénient de générer un grand nombre de chro niques L’information de la discriminance du multiset est considérée plus généralisatrice et seule cette chronique est conservée Aucune contrainte temporelle n’est spécifiée pour ces multisets discriminants Pour cela la ligne 4 teste si le multiset ms est discriminant Si tel est le cas ms est ajouté à l’ensemble des motifs discriminants Et seulement dans le cas contraire les lignes 7 à 9 engendrent des chroniques à partir des contraintes temporelles discriminantes identifiées par EXTRACTDISCRCONSTRAINTS 4 1 Extraction de contraintes temporelles L’idée générale de EXTRACTDISCRCONSTRAINTS est de ramener l’extraction des inter valles décrivant les contraintes temporelles à une tâche classique d’apprentissage relationnel Pour chaque extraction on construit un jeu de données relationnelles tel que ses attributs sont les paires d’évènements du multiset et tel que ses exemples sont les occurrences du mul tiset Les valeurs d’un attribut pour un exemple sont les durées inter évènements de la paire d’évènements au sein d’une occurrence Un exemple est étiqueté par le SID séquence Cette étiquette est conservée afin de faire correspondre la définition de support d’une chronique avec la comparaison de ces occurrences 169 Extraction de chroniques discriminantes SID A→B B→C A→C Label 1 2 2 4 + 1 −1 2 1 + 2 5 −2 3 + 3 3 0 3 + 5 −1 3 1 6 6 −1 5 TAB 2 – Jeu de données associé au multiset {A B C} Exemple 5 Le tableau 2 correspond au jeu de données obtenu à partir des occurrences du multiset {{A B C}} dans le tableau 1 L’attribut A→B désigne les durées entre A et B On remarque sur cet exemple que plusieurs exemples peuvent provenir de la même séquence Ce jeu de données relationnelles est traitable par un algorithme d’apprentissage relationnel dont les résultats seront des conjonctions de règles de la forme e1 → e2 ≥ x ou e1 → e2 ≤ y où e1 e2 sont des évènements et x y ∈ R Ces règles sont alors traduites comme des contraintes temporelles e1[x y]e2 Exemple 6 La conjonction de règles A → B ≤ 5 ∧ B → C ≤ 2 =⇒ + caractéri sant parfaitement les exemples étiquetés par + dans le tableau 2 est traduite par l’ensemble de contraintes temporelles T = {A[−∞ 5]B B[−∞ 2]C} ce qui donne la chronique discrimi nante C = E = {{e1 = A e2 = B e3 = C}} T = {e1[−∞ 5]e2 e2[−∞ 2]e3} Apprentissage de règles Ripperk L’apprentissage de règles est effectué en pratique par l’algorithme Ripperk Cohen 1995 Cet algorithme a été choisi parmi l’état de l’art des algo rithmes d’apprentissage de règles relationnelles d’une part parce qu’il est l’un des plus per formants et d’autre part parce qu’il permet l’extraction de règles non ordonnées Le problème des extracteurs de règles ordonnées e g CN2 C4 5 est qu’ils extraient une liste de conjonc tions de règles dont la discriminance de la règle ordonnée à la position n n’est valable qu’en dehors des cas décrits par n−1 règles précédentes La discriminance d’une chronique obtenue à partir de l’une de ces règles ne serait valide que pour un sous ensemble des séquences du jeu de données Ceci ne correspond pas à notre définition de discriminance Pour une classe à apprendre Ripperk sépare le jeu de données en deux Grow et Prune Le premier permet de construire la conjonction de règles discriminant les exemples d’une classe aux autres La construction s’arrête lorsqu’il n’est plus possible d’ajouter une règle à la conjonction qui améliore la discriminance Le second est utilisé pour élaguer la règle construite Si la conjonction est plus discriminante sans sa dernière règle on lui retire et on réessaie jusqu’à ce qu’elle ne puisse plus être améliorée Si la discriminance n’est pas satis faite pour cette conjonction la recherche s’arrête pour cette étiquette Sinon la conjonction est retournée les exemples associés à celle ci sont retirés de Grow et la recherche recommence Les étapes précédentes sont répétées pour chaque étiquette présente dans le jeu de données Le choix d’utiliser un algorithme d’apprentissage basé sur une heuristique incomplète en l’occurrence une heuristique basée sur le principe MDL Minimum Description Length se montre ici indispensable pour des raisons calculatoires Néanmoins Ripperk combine 1 une complexité algorithmique raisonnable – les temps de calculs restent donc raisonnables 2 des performances en classification intéressantes – les chroniques extraites sont donc bien 170 Y Dauxais et al représentatives du jeu de données – et 3 des ensembles de règles réduits – les chroniques extraites restent facilement interprétables Lattner et al Limite des instances multiples Le problème des instances multiples Foulds et Frank 2010 désigne les problèmes de comptage rencontrés lorsqu’un motif apparaît plusieurs fois dans un objet Dans notre cas un objet est une séquence Cette situation est rencontrée lors de la constitution du jeu de données cf table 2 et fausse le comptage du nombre d’objets validant une conjonction de règles fait par Ripperk Lorsque les lignes 1 et 2 de la table 2 sont couvertes par une règle elle ne doivent ici compter que pour un objet i e un SID Ce cas d’utilisation n’est pas prévu par Ripperk La solution choisie est celle consistant à post traiter les conjonctions de règles de Ripperk et à ne conserver que celles qui valident effectivement les contraintes de fréquence minimale et de discriminance Cette solution n’assure pas que des chroniques discriminantes soient ex traites mais ne rajoute pas de lourdeur calculatoire Une seconde solution à ce problème serait de modifier le système de comptage de Ripperk afin qu’il évalue une conjonction de règles en comptant les SID distincts Mais l’heuristique de Ripperk n’est pas faite pour écarter des exemples après en avoir sélectionné d’autres et donc l’efficacité serait faible dans le cas de jeux de données contenant de nombreux exemples portant les mêmes SID La troisième solution serait d’utiliser des méthodes adaptées à ce type de problème Par exemple Doran et Ray 2014 sélectionnent un exemple témoin pour chaque objet afin de se ramener à une tâche d’apprentissage de règles classique Le jeu de données fourni à Ripperk peut être prétraité suivant ces méthodes afin de ne lui transmette qu’un seul exemple par sé quence Cette solution paraît être la plus fiable mais ajoute une complexité importante au pro cessus d’extraction de contraintes temporelles La prise en compte des instances multiples se ferait donc nécessairement au prix d’un ajout de complexité calculatoire Les instances multiples étant rarement rencontrées dans nos appli cations nous avons privilégié l’efficacité calculatoire en ne mettant pas en place de solution spécifique à ce problème Satisfaction de la contrainte de discriminance Pendant le post traitement des règles pour le problème précédent l’algorithme filtre les règles selon notre seuil de croissance En effet l’utilisation du paramètre gmin comme seuil de croissance pour Ripperk risque d’élaguer des règles intéressantes Les erreurs peuvent survenir lorsque les jeux Grow et Prune ne sont pas répartis de manière équilibrées et que la proportion des exemples d’un jeu n’est pas représen tatif de l’ensemble 5 Expériences et résultats L’implémentation de DCM écrite en C++ repose sur les implémentations préexistantes de LCM Uno et al 2004 et de Ripperk Cohen 1995 5 1 Données synthétiques Les bases de données sont générées par un simulateur qui introduit des chroniques fré quentes aux séquences Le simulateur gère des bases contenant deux classes L = {S+ S−} 171 Extraction de chroniques discriminantes C − Base1 Base2 Base3 Base4 Base5 ∆c\∆g 1 1 1 0 96 0 89 0 86 1 0 96 0 93 0 89 0 1 0 93 0 91 0 1 31 40 30 2 5 3 30 3 3 1 0 15 1 1 0 0 9 6 0 85 1 0 72 1 0 66 2 0 5 1 0 47 1 0 1 2 TAB 3 – Nombre de motifs extraits par couple ∆c ∆g pour chaque motifs discriminants introduits L’absence de chiffre correspond à une valeur 0 Les expérimentations sur données synthétiques permettent de valider l’extraction des chro niques discriminantes au sein d’un jeu de données Le principe général du simulateur est de générer des séquences basées sur deux chroniques C+ et C− puis de les bruiter aléatoirement Afin de générer un jeu de données dont il est possible de discriminer les classes positives et négatives C+ et C− sont majoritairement intro duites dans deux ensembles respectivement S+ et S− Deux paramètres gèrent l’introduction de ces chroniques fDmin et g D min f D min définit le pourcentage de séquences de la classe ma joritaire dans lesquelles une chronique apparaîtra gDmin définit le rapport entre les nombres de séquences des deux classes dans lesquelles apparaît cette chronique On ne cherche pas à extraire C+ et C− on cherche à extraire les motifs décrivant le plus d’occurrences de C+ et le moins d’occurrences de C− Le simulateur est paramétré pour générer par défaut des jeux de données contenant 800 séquences de chaque classe de longueur moyenne 10 La taille du vocabulaire est fixée à 50 items et fDmin et g D min sont fixés respectivement à 80% et 10% Les jeux de données BaseN ont été créés à partir de chroniques basées sur le même multi set {{A B}} de taille 2 Elles comportent donc chacune un unique intervalle temporel Les deux intervalles se chevauchent plus ou moins Ainsi pour tous ces jeux C+ = {{A B}} A[3 10]B et C− = {{A B}} A[7 8]B puis les contraintes A[6 8]B A[4 8]B A[4 9]B et A[4 10]B ont été utilisées pour générer respectivement Base1 Base2 Base3 Base4 et Base5 Pour chaque jeu de données les résultats sont moyennés sur 20 exemplaires de bases Les résultats présentés regrouperont donc jusqu’à 40 motifs du fait de ces 20 générations La capacité de l’extracteur à extraire les bons motifs peut être évaluée en comparant les ensembles des motifs extraits et des motifs recherchés puisque les motifs discriminants recherchés sont connus à l’introduction des chroniques Deux mesures ont pour cela été utilisées ∆c m mt et ∆g m mt ∆c m mt le rapport de couverture représente le rapport entre le nombre de séquences de la classe S+ contenant une occurrence partagée par m et mt et le nombre de celles contenant mt ∆g m mt le rapport de croissance représente le rapport entre les taux de croissance de m et de mt Si support m S− = support mt S− = 0 alors ∆g m mt = 1 sinon si support mt S− = 0 alors ∆g m mt = 0 Pour chacun des motifs recherchés m t un seul couple ∆c m mt ∆g m mt est retenu tel que ∆c m mt soit le plus élevé pour tout motif extrait m et que ∆g m mt soit le plus élevé s’il existe plusieurs ∆c m mt maximaux Le tableau 3 présente les résultats d’extraction de DCM sur les 20 jeux de données générés pour chaque BaseN Le rapport de couverture est donné en ligne et celui de croissance en colonne Chaque cellule du tableau correspond au nombre de motifs extraits pour un rapport de couverture un rapport de croissance et un type d’expérience donnés 172 Y Dauxais et al On remarque sur le tableau 3 que DCM extrait pour au moins 75% des motifs discrimi nants introduits dans chaque jeu de données un motif discriminant dont les rapport de cou verture et de croissance sont parfaits = 1 De plus il n’y a que pour les jeux de données Base4 et Base5 que notre extracteur n’extrait aucun motif pour certains motifs discriminants introduits 1 sur 40 pour Base4 et 2 sur 20 pour Base5 Afin d’expliquer ces erreurs l’extraction a été relancée avec un taux de croissance minimal de 1 1 Avec cette configuration tous les motifs de Base4 sont extraits avec ∆c = 1 et ∆g = 0 83 Il est à noter que le motif correspondant à ∆c = 0 47 pour la première extraction des motifs de Base4 obtient les mêmes rapports ∆c et ∆g Ces résultats sur des données synthétiques simples montrent que notre extracteur extrait effectivement les motifs discriminants avec une certaine robustesse 5 2 Expérimentations sur données réelles Deux types de jeux de données réelles ont été utilisés nous utilisons tout d’abord les jeux de données utilisés pour évaluer BIDE D Fradkin et Mörchen 2015 afin de nous comparer à cette approche Nous illustrons ensuite la qualité des chroniques extraites à partir de jeux de données ECG i e électrocardiogrammes Comparaison avec BIDE D Les premières données réelles utilisées pour tester notre ex tracteur sont les données proposées pour tester les algorithmes de BIDE D Ces données pro viennent d’applications variées Afin de se comparer avec BIDE D sur un sous ensemble des jeux de données utilisés ni trop simples comme blocks où les taux de prédiction approchent les 100% ni trop difficiles comme Auslan2 où les approches de BIDE D dépassent difficile ment les 30% nous avons choisi de nous concentrer sur asl bu asl gt et context L’évaluation des résultats se fera en comparaison avec ceux présentés pour BIDE D cf annexe à Fradkin et Mörchen 2015 Les résultats suivants comparent les performances en classification des chroniques dis criminantes avec les séquences discriminantes extraites par BIDE D Les paires 〈C L〉 de chroniques discriminantes C et d’étiquettes L ont été utilisées pour prédire l’étiquette d’une séquence On prédira donc une étiquette L pour une séquence dans le cas où cette séquence contiendrait la chronique C Dans le cas de plusieurs chroniques apparaissant dans la séquence on retiendra l’étiquette associée à la chronique ayant le taux de croissance le plus élevé Cette méthode naïve a été jugée plus juste que l’utilisation d’un classifieur pour évaluer les chro niques extraites Les résultats commentés ci dessous sont présentés dans le tableau 4 Une contrainte de taille maximale des motifs a été fixée à 5 pour faciliter leur extraction et limiter leur nombre asl bu asl gt context σmin \gmin 2 3 4 5 2 3 4 5 2 3 4 5 6 0 2 0 09 0 07 0 07 0 06 0 06 0 58 0 57 0 59 0 55 0 3 0 66 0 65 0 63 0 08 0 06 0 05 0 04 0 58 0 56 0 56 0 52 0 52 0 4 0 66 0 66 0 65 0 04 0 04 0 03 0 02 0 58 0 54 0 49 0 48 0 45 0 5 0 66 0 64 0 58 0 50 0 03 0 03 0 02 0 02 0 58 0 55 0 52 0 48 0 43 0 6 0 65 0 55 0 51 0 37 0 03 0 02 0 02 0 01 0 55 0 56 0 49 0 42 0 43 TAB 4 – Évolution de la précision en fonction de σmin de gmin et du jeu de données 173 Extraction de chroniques discriminantes Sur asl bu les résultats sont quelque peu meilleurs que ceux de BIDE D On remarque que ce soit pour σmin = 0 3 ou σmin = 0 6 que le taux de prédiction pour gmin = 2 est équivalent alors que le nombre de motifs extraits est réduit de plus de 30000 à 1600 Sur asl gt les résultats sont malheureusement très mauvais Là où les taux de prédictions vont de 0 27 pour σmin = 0 6 à 0 83 pour σmin = 0 2 pour BIDE D ceux ci n’atteignent pas 0 1 pour les chroniques discriminantes De nombreux motifs sont extraits mais sont mal ré partis entre les étiquettes du jeu de données Ces résultats proviennent peut être de la contrainte de taille maximale des chroniques ou montrent la limite de l’utilisation de Ripperk dans un contexte d’instances multiples Finalement pour context les résultats sont similaires à ceux de asl bu pour notre ap proche Ce sont donc nos meilleurs résultats puisque les résultats présentés par BIDE D oscillent entre 0 26 et 0 53 On remarque que les faibles résultats de BIDE D sont sûrement liés à l’utilisation de seuils de support minimaux différents pour ce jeu de données L’écart du nombre de motifs extraits par les paramètres σmin = 0 2 ou σmin = 0 6 est beaucoup moins important que pour asl bu Il va de 360 motifs pour σmin = 0 2 et gmin = 2 à 145 motifs pour σmin = 0 6 et gmin = 4 Analyse d’électrocardiogrammes Ces mêmes expériences ont été réalisées sur les données ECG des données d’électrocardiogramme contenant majoritairement des cycles cardiaques problématiques Chaque jeu de données concerne le patient et ses cycles cardiaques Le jeu de données présenté dans les résultats est celui concernant le patient 214 dont les cycles car diaques sont étiquetés bloc de branches et extrasystole deux problèmes cardiaques Ces données ont déjà été utilisées pour extraire des chroniques discriminantes par Carrault et al 2003 Ces données ont été prétraitées afin que chaque séquence corresponde à un cycle car diaque L’intérêt de ces données est la très faible diversité d’événements et l’équivalence de la plupart des séquences quelle que soit leur classe en terme d’items Elles ne contiennent que quatre types d’évènements les ondes cardiaques p et qrs annotées des mentions normal ou abnormal En effet aucun multiset d’items ne peut être discriminant dans de telles conditions et les évènements cardiaques se déroulant toujours dans le même ordre un motif purement séquentiel ne pourrait pas non plus être discriminant L’aspect temporel devient donc le seul moyen d’établir une discriminance 2 Ceci met en évidente l’utilité des chroniques discrimi nantes face à d’autres types de motifs moins riches p_wave normal p_wave normal [733 +∞] p_wave normal [733 +∞] FIG 2 – Chronique discriminant les blocs de branche des extrasystoles du patient 214 Pour des jeux de données ECG rééquilibrés le taux de prédiction est toujours supérieur à 80% pour un taux de croissance minimal fixé à 2 Le bloc de branche est un problème car diaque qui rend les cycles anormalement longs et l’extrasystole correspond à une contraction prématurée du cœur On remarque que la chronique discriminante de la Figure 2 représente un cycle cardiaque anormalement long dont les bornes inférieures 733 correspondent finalement 2 Ces données correspondent à un cas réel des jeux de données synthétiques de la section 5 1 174 Y Dauxais et al à des cycles normaux Cette chronique est un exemple de l’intérêt de l’information temporelle pour la discriminance Les trois évènements sont les mêmes leur ordre n’a aucune importance 6 Conclusion et perspectives L’extraction de chroniques était déjà connue mais il n’existait pas de travaux concernant l’extraction de chroniques discriminantes L’algorithme DCM a été proposé pour résoudre ce problème Il ajoute d’une part la prise en compte d’une information temporelle riche par rapport aux algorithmes d’extraction de motifs séquentiels discriminants et il ajoute d’autre part la contrainte de discriminance à l’extraction de chroniques Cet algorithme se base sur les travaux antérieurs d’apprentissage de règles relationnelles Les expérimentations réalisées utilisant l’algorithme Ripperk ont montré que DCM était capable d’extraire efficacement des chroniques discriminantes Les comparaisons en terme de pouvoir de prédiction entre DCM et les algorithmes de BIDE D Fradkin et Mörchen 2015 ont montré que les chroniques discriminantes extraites par DCM étaient capables de concurrencer les méthodes de l’état de l’art et ce sans avoir à entraîner de classifieur Le modèle global permettant la classification n’est pourtant pas la finalité de l’extraction de chroniques discriminantes comme le serait un algorithme inspiré du framework LeGo Knobbe et al 2008 L’extraction de chroniques discriminantes a été pensée dans un contexte de gé nération d’hypothèses d’associations de motifs à une classe où chaque motif extrait doit être compréhensible indépendamment des autres La classification n’intervient que pour évaluer la capacité de notre extracteur à couvrir l’ensemble des données à l’aide de motifs représentatifs des sous groupes de séquences L’évaluation de l’intérêt des chroniques discriminantes pour faire émerger de nouvelles hypothèses est actuellement en cours sur des données médicales Pour certains jeux de données DCM n’extrait pas de chroniques suffisamment discrimi nantes pour prédire au moins aussi bien que les algorithmes de BIDE D Une perspective d’amélioration serait d’extraire des contraintes temporelles avec une approche gérant les ins tances multiples L’ensemble des motifs extraits reste important L’extraction de représenta tions condensées de chroniques e g des chroniques minimales ou un post traitement identi fiant des chroniques similaires permettraient une meilleure lecture des résultats Finalement les extractions de contraintes temporelles étant indépendantes les unes des autres la perfor mance computationnelle de DCM pourrait être améliorée au travers du parallélisme Remerciements Ce travail a été financé par l’ANSM dans le cadre de la plate forme PEPS Références Carrault G M O Cordier R Quiniou et F Wang 2003 Temporal abstraction and in ductive logic programming for arrhythmia recognition from electrocardiograms Artificial intelligence in medicine 28 3 231–263 Cohen W W 1995 Fast effective rule induction In Machine Learning Proceedings of the International Conference on Machine Learning pp 115–123 Cram D B Mathern et A Mille 2012 A complete chronicle discovery approach applica tion to activity analysis Expert Systems 29 4 321–346 175 Extraction de chroniques discriminantes Dong G et J Li 1999 Efficient mining of emerging patterns Discovering trends and differences In Proceedings of ACM SIGKDD pp 43–52 Doran G et S Ray 2014 A theoretical and empirical analysis of support vector machine methods for multiple instance classification Machine Learning 97 1 79–102 Dousson C et T V Duong 1999 Discovering chronicles with numerical time constraints from alarm logs for monitoring dynamic systems In Proceedings of the IJCAI pp 620–626 Fabrègue M A Braud S Bringay C Grac F Le Ber D Levet et M Teisseire 2014 Dis criminant temporal patterns for linking physico chemistry and biology in hydro ecosystem assessment Ecological Informatics 24 210–221 Foulds J et E Frank 2010 A review of multi instance learning assumptions The Knowledge Engineering Review 25 01 1–25 Fradkin D et F Mörchen 2015 Mining sequential patterns for classification Knowl Inf Syst 45 3 731–749 Guyet T et R Quiniou 2011 Extracting temporal patterns from interval based sequences In Proceedings of the IJCAI pp 1306–1311 Huang Z X Lu et H Duan 2012 On mining clinical pathway patterns from medical behaviors Artificial Intelligence in Medicine 56 1 35–50 Knobbe A B Crémilleux J Fürnkranz et M Scholz 2008 From local patterns to global models the LeGo approach to data mining LeGo 8 1–16 Lattner A D S Kim G Cervone et J J Grefenstette Experimental comparison of sym bolic learning programs for the classification of gene network topology models Center for Computing Technologies–TZI 2 1 Mannila H H Toivonen et A I Verkamo 1997 Discovery of frequent episodes in event sequences Data mining and knowledge discovery 1 3 259–289 Masseglia F M Teisseire et P Poncelet 2004 Recherche des motifs séquentiels Revue Ingénierie des Systemes d’Information ISI 9 3 4 183–210 Mooney C H et J F Roddick 2013 Sequential pattern mining – approaches and algorithms ACM Journal of Computing Survey 45 2 1–39 Uno T M Kiyomi et H Arimura 2004 LCM ver 2 Efficient mining algorithms for frequent closed maximal itemsets In FIMI Volume 126 Summary Sequential pattern mining attempts to extract frequent behaviours from sequential dataset When sequences are labeled it is interesting to extract characteristic behaviors for each se quence class This task is called discriminant pattern mining In this paper we introduce discriminant chronicle mining Conceptually a chronicle is a graph whose vertices are events and edges represent quantitative time constraints between events We also propose DCM an algorithm dedicated to mining of discriminant chronicles It is based on rule learning methods to extract the temporal constraints Computational performances and discriminant power of extracted chronicles are evaluated on synthetic and real data 176 