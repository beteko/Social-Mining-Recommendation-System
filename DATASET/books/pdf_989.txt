ICDM NDSP FR dviVers une nouvelle approche d’extraction des motifs séquentiels non dérivables Chedy Raïssi Pascal Poncelet LIRMM 161 rue Ada 34392 Montpellier Cedex 5 France raissi lirmm fr EMA LGI2P Parc Scientifique Georges Besse 30035 Nîmes Cedex France prénom nom ema fr Résumé L’extraction de motifs séquentiels est un défi important pour la com munauté fouille de données Même si les représentations condensées ont mon tré leur intérêt dans le domaine des itemsets à l’heure actuelle peu de travaux considèrent ce type de représentation pour extraire des motifs Cet article pro pose d’établir les premières bases formelles pour obtenir les bornes inférieures et supérieures du support d’une séquence S Nous démontrons que ces bornes peuvent être dérivées à partir des sous séquences de S et prouvons que ces règles de dérivation permettent la construction d’une nouvelle représentation conden sée de l’ensembles des motifs fréquents Les différentes expérimentations me nées montrent que notre approche offre une meilleure représentation condensée que celles des motifs clos et cela sans perte d’information 1 Introduction Motivée par de nombreux domaines d’applications e g marketing web analyses finan cières détections d’anomalies dans les réseaux traitements de données médicales l’extraction de motifs séquentiels fréquents est un domaine de recherche très actif Mobasher et al 2002 Ramirez et al 2000 Lattner et al 2005 Les travaux menés ces dernières années ont montré que toutes les approches qui visent à extraire l’ensemble des motifs séquentiels deviennent ce pendant inefficaces dès que le support minimal spécifié par l’utilisateur est trop bas ou lorsque les données sont fortement corrélées En effet dans ce cas et plus encore que pour les item sets les recherches sont pénalisées par un espace de recherche trop important Par exemple avec i attributs appelés aussi items il y a potentiellement O ik séquences fréquentes de taille k Zaki 2001 Pour essayer de gérer au mieux ces problèmes de complexités spatiale et temporelle deux grandes tendances se distinguent à l’heure actuelle Dans le premier cas les propositions comme PrefixSPAN Pei et al 2004 ou SPADE Zaki 2001 se basent sur de nouvelles structures de données et une génération de candidats efficace Les approches de la seconde tendance considèrent l’extraction d’une représentation condensée Mannila et Toi vonen 1996 Même si l’utilisation d’une représentation compacte a montré son intérêt dans le domaine de l’extraction d’itemsets la complexité structurelle des motifs séquentiels fait qu’il existe cependant peu de travaux utilisant une représentation condensée dans ce contexte Extraction de motifs séquentiels non dérivables Ainsi seuls Clospan Yan et al 2003 et Bide Wang et Han 2004 ont abordé ce problème en cherchant à extraire des motifs clos Le problème que nous cherchons à résoudre dans cet article est le suivant Est il possible de trouver une nouvelle représentation condensée pour répondre à la problématique de l’extraction de motifs séquentiels Notre objectif est d’établir les premières bases formelles pour calculer les bornes supérieures et inférieures de la valeur du support d’un motif en utilisant le principe de l’inclusion exclusion Knuth 1973 Ce principe nous permet d’obtenir des règles de dérivations via lesquelles nous pouvons déduire le support d’une séquence sans avoir à compter son support dans la base de données Nous montrons également que ces règles peuvent être utilisées pour construire une représentation condensée de certains types de motifs Cet article est organisé de la manière suivante La section 2 introduit les concepts liés aux mo tifs séquentiels ainsi que les notions formelles utilisées dans le reste de l’article Nous discutons l’utilisation de règles de déductions dans la section 3 L’approche NDSP est introduite dans la section 4 La section 5 présente les premières expérimentations menées qui confirment l’inté rêt de notre approche et en discute les limites Dans la section 6 nous présentons les travaux connexes autour des représentations condensées et des motifs séquentiels Enfin la section 7 conclut et présente les principales perspectives associées à ce travail 2 Concepts préliminaires Dans cette section nous définissons le problème d’extraction des motifs séquentiels initia lement proposé par Srikant 1995 Srikant et Agrawal 1996 et nous introduisons la notion de S Apparition une notion similaire est proposée dans Calders et Goethals 2002 pour l’ex traction des itemsets fréquents Soit D une base de données contenant des transactions regroupées par client où chaque transaction T consiste en un identifiant de client noté Cid une estampille temporelle notée time et un ensemble d’items appelé itemset noté it Définition 1 Sequence Inclusion et Support Soit I = {i1 i2 im} un ensemble fini de littéraux appelés items Un itemset est un ensemble non vide d’items Une séquence S est une liste ordonnée selon les estampilles temporelles d’itemsets notée < it1 it2 itn > où itj j ∈ 1 n est un itemset Une k séquence est une séquence de k items ou de taille k Une séquence S′ =< s′1 s ′ 2 s ′ n > est une sous séquence de S =< s1 s2 sm > notée S ′ � S si ∃ i1 < i2 < ij < in tels que s′1 ⊆ si1 s ′ 2 ⊆ si2 s ′ n ⊆ sin Si S 6� S ′ et S′ 6� S les séquences sont dites incomparables et sont notées S ≺≻ S′ De plus une séquence est dite régulière si chaque itemset itj contient le même unique item i Par exemple 〈 a a a 〉 et 〈 b b 〉 sont des motifs séquentiels réguliers Soit Ctrans la liste ordonnée des transactions pour un client C i e la séquence maximale supportée par C Le support d’une séquence S dans une base transactionelle D noté Support S D est défini tel que Support S D = |{C ∈ D|S � Ctrans}| Définition 2 Extension de séquence Soit S une séquence et α un item S∪α veut dire que α est rajouté dans le dernier itemset de la séquence S De même S⋄α définit la concaténation de α dans un nouvel itemset introduit à la fin de la séquence Par exemple soit S = 〈 abcd ab 〉 S ∪ c = 〈 abcd abc 〉 et S ⋄ c = 〈 abcd ab c 〉 C Raïssi et al Avec ces définitions nous pouvons maintenant décrire formellement le problème d’extrac tion des motifs séquentiels et sa solution Définition 3 Problème de l’extraction des motifs séquentiels fréquents SoitSP la séquen ce maximale théorique pouvant être générée à partir des clients dans D La solution au pro blème d’extraction des motifs séquentiels fréquents est définie telle que FreqSeqSet S D σ = {S � SP|Support S D ≥ σ} où σ est un seuil de support minimal défini par l’utilisateur 0 ≤ σ ≤ |C| et C est l’ensemble des clients dans D Définition 4 S Apparition Pour chaque séquence S A S D représente l’ensemble de clients contenant exactement dans leurs transactions la séquence S A S D = {C ∈ D|Ctrans = S} Exemple 1 Considérons la base de données D suivante avec I = {a b c d} C1 T1 a b c d T2 a b C2 T3 a b C3 T1 a d T4 c La séquence maximale SP qui peut être générée est 〈 abcd abcd 〉 Dans D A 〈 ab 〉 D = {C2} A 〈 ad c 〉 D = {C3} A 〈 abcd ab 〉 D = {C1} Pour toutes les autres séquences S A S D = ∅ Soit aSPS le cardinal de l’ensemble A S D La notation aS sera préferée quand le contexte n’est pas ambigue A partir de la définition 4 nous pouvons exprimer le support d’une séquence en fonction de aS S ≺ SP Lemme 1 Pour chaque séquence S � SP Support S D = ∑ S�J�SP aJ Par manque de place les preuves de ce lemme des prochaines propositions et des théorèmes ne sont pas détaillés dans cet article Le lecteur peut se référer à Raissi et Poncelet 2006 Le lemme 1 sera utilisé dans la prochaine section afin de générer les règles de déductions 3 Règles de déductions Dans cette section nous étendons la définition d’expression de support introduite dans Calders et Goethals 2002 pour l’extraction d’itemsets fréquents Cette expression sert à mo déliser les informations du support dans les séquences Ces informations sont formalisées en implications logiques et nous soulignons les liens entre ces expressions de support et un sys tème d’équations linéaires Définition 5 Expression de support pour les séquences Une expression de support pour une séquence S est une égalité Support S = s avec S � SP et s ∈ N Une base de données D "satisfait" l’expression de support Support S = s si et seulement si Support S D = s Soit S un ensemble d’expressions de support Une base de données D "satisfait" S si et seule ment si toutes les expressions dans S sont satisfaites Extraction de motifs séquentiels non dérivables S =                    Support {} = 3 Support a = 3 Support b = 2 Support c = 2 Support d = 2 Support 〈ab〉 = 2 Support 〈 a a 〉 = 1 Support 〈 a b 〉 = 1 Support 〈 a c 〉 = 1 Support 〈ac〉 = 1 Support 〈ad〉 = 1 Support 〈 b b 〉 = 1 Support 〈 b a 〉 = 1 Support 〈bc〉 = 1 Support 〈bd〉 = 1 Support 〈 c a 〉 = 1 Support 〈 c b 〉 = 1 Support 〈cd〉 = 1 Support 〈 d a 〉 = 1 Support 〈 d b 〉 = 1 Support 〈 d c 〉 = 1                    FIG 1 – Expressions de support dans la base de données D de l’exemple 1 Ces expressions de support sont présentes dans chaque algorithme de type Apriori utilisé pour l’extraction de motifs séquentiels Ainsi l’ensemble des expressions de support s’agrandit après chaque étape de comptage des séquences Néanmoins seul un sous ensemble de S est uti lisé pour déduire des contraintes sur les supports des séquences candidates est il alors possible d’utiliser tout l’ensemble des expressions de support afin d’obtenir de meilleurs contraintes sur les supports Définition 6 Extension de Calders et Goethals 2002 Soit S � SP une séquence et u l ∈ R Soit S un ensemble d’expressions de support S implique un intervalle [l u] sur le support de S noté S |= Support S ∈ [l u] si et seulement si pour chaque transaction de la base de données D satisfaisant S on a l ≤ Support S ≤ u Cet intervalle [l u] est minimal noté S |=min Support S ∈ [l u] si et seulement si 6 ∃[l′ u′] ⊂ [l u] | S |= Support S ∈ [l′ u′] Nous montrons maintenant comment générer l’intervalle minimal pour chaque séquence candidate en utilisant l’ensemble des expressions de support c’est à dire utiliser toute l’in formation disponible dans l’ensemble des expressions de support Pour cela nous présentons les liens théoriques entre l’implication logique définie ci dessus et un système d’équations linéaires Lemme 2 Soit S une expression de support pour la séquence S Il existe une base de données D qui satisfait S si et seulement le système d’équations linéaires suivant possède une solution dans N pour chaque variable xs avec S � SP Sys S = { xS ≥ 0 ∀S � SP ∑ S�J�SP xJ = sJ ∀ Support J = sJ ∈ S En utilisant ce type d’inégalités nous pouvons définir un théorème permettant de déduire directement des règles sur les bornes de l’intervalle de support des séquences candidates S Ceci est possible car les algorithmes construits niveaux par niveaux contiennent l’information Support J = sJ pour chaque sous séquence de S L’utilisation de la séquence théorique maximale SP n’est pas possible d’un point de vue pratique Pour cela nous limitons la portée de notre lemme à la séquence S uniquement en utilisant un principe de projection de séquence sur la base de données D Contrairement au problème d’extraction d’itemsets cette projection modifie le support des sous séquences de S puisque certaines séquences peuvent être incomparables à S tout en ayant des sous séquences en commun C Raïssi et al Définition 7 Projection de séquence Soit S une séquence et I S l’ensemble des items contenus dans cette séquence La projection des transactions d’un client sur S notée πS Ctrans est une liste ordonnée de transactions définie comme suit – I πS Ctrans ⊆ I S élimination de tous les items de Ctrans qui ne sont pas dans S – If Ctrans ≺ S πS Ctrans = Ctrans – If S � Ctrans πS Ctrans = S – If S ≺≻ Ctrans πS Ctrans = Ctrans si un ensemble de transactions d’un client est incomparable avec la séquence projetée il est inchangé La projection de la base de données D sur S notée πS D est définie telle que πS D = {πS Ctrans |C ∈ D} Lemme 3 SoitD une base de données pour chaque sous séquence X de S Support X D = Support X πS D D’après le lemme 2 il existe une variable xS pour chaque sous séquence S � SP Le lemme 3 permet de réduire considérablement le système d’équations Sys S associé à l’en semble des expressions de support S Donc avec une projection sur la séquence S nous pou vons restreindre les variables xX à uniquement celles dont X � S Lemme 4 Soit S l’ensemble des expressions de support pour la séquence S Il existe une base de données D qui satisfait S si et seulement si le système d’équations suivant possède une solution dans N pour chaque variable xX avec X � S Sys S = { xX ≥ 0 ∀X � S ∑ X�J�S xJ = sJ ∀ Support J = sJ ∈ S Pour résoudre Sys S nous séparons les coefficients en une matrice booléenne      a11 a12 a1S a21 a22 a2S aS1 aS2 aSS           xX xJ xS      =      sX sJ sS      Si nous représentons chaque matrice par un symbole Ax = S avec A une matrice de contraintes de taille n × n n étant le cardinal de l’ensemble contenant S et toutes ses sous séquences x un vecteur colonne avec n entrées et S un vecteur colonne avec n entrées la solution générale en utilisant la méthode d’élimination de Gauss Jordan A−1 S est xX = ∑ X�J�S −1 |J−X|∆JX sJ 1 où ∆JX est la valeur absolue de l’élément xj de la matrice inverse A −1 Soit sS un entier choisi arbitrairement d’après le lemme 4 l’ensemble des supports d’ex pression S pour la séquence S est satisfiable si et seulement si il existe une solution entière au système d’équations Sys S Donc d’après 1 Sys S est satisfiable si et seulement si xX = ∑ X�J�S −1 |J−X|∆JX sJ ≥ 0 ∀X � S 2 Extraction de motifs séquentiels non dérivables Notons que 2 est similaire à la formule d’inclusion exclusion de Knuth 1973 En isolant −1 |S−X|∆SX sS et ss de la somme nous avons −1 |S−X|∆SX sS ≥ − ∑ X�J≺S −1 |J−X|∆JX sJ Comme ∀X � J ≺ S nous obtenons Théorème 1 Soit X � S � SP Support S ≤ ∑ X�J≺S −1 |S−J|+1∆JX sJ ∆SX si|S − X | impair 3 Support S ≥ ∑ X�J≺S −1 |S−J|+1∆JX sJ ∆SX si|S − X | pair 4 Les règles déduites de 3 sont les bornes supérieures de la valeur du support de la séquence S et les règles déduites de 4 sont les bornes inférieures Ces règles seront notées RX S comme dans Calders et Goethals 2002 et la borne notée δX S est définie telle que δX S = ∑ X�J≺S −1 |S−J|+1∆JX sJ ∆SX 5 Nous pouvons alors pour chaque séquence S déduire des règles de chaque sous séquence X � S Ces règles peuvent être utilisées pour définir un intervalle sur la valeur du support de S avec US respectivement LS la valeur minimale des bornes supérieures respectivement la valeur maximale des bornes inférieures et donc Ls ≤ Support S ≤ Us Exemple 2 Considérons la base de données D suivante C1 T1 a b c T2 a b c C2 T3 a b C2 T6 a b C3 T1 a c T4 a Support 〈 a b 〉 1 R{} 〈 a b 〉 Support 〈 a b 〉 ≥ −Support {} + Support a + Support b = 2 2 Ra 〈 a b 〉 Support 〈 a b 〉 ≤ Support a = 2 Remarquons pour cette séquence que nous pouvons directement inférer le support sans avoir à le compter 〈 a b 〉 est égal à 2 2 ≤ Support 〈 a b 〉 ≤ 2 Corollaire 1 Soit X � S la différence entre la borne δSX et la valeur réelle du support de S multipliée par ∆SX est égale au cardinal des S Apparitions de S aX = ∆ S X |sS − δX S | 6 L’extraction des motifs séquentiels est fortement limitée par son aspect combinatoire Afin de résoudre ce problème il est souvent nécessaire et plus efficace d’extraire un sous ensemble de motifs contenant ou pouvant permettre l’extraction des mêmes informations que l’ensemble C Raïssi et al des motifs séquentiels Les règles de déductions peuvent être utilisées afin de construire une nouvelle représentation condensée des motifs séquentiels Si les règles permettent de déri ver exactement la valeur du support i e US = LS d’une séquence S en utilisant ces sous séquences cf exemple 2 avec la séquence 〈 a b 〉 alors il n’est pas nécessaire de garder S Dans ce cas S est appelée une séquence dérivable notée DS De la même façon les séquences non dérivables notées NDS sont les séquences qui ne peuvent pas avoir leur support dérivé de manière exacte Nous allons montrer que l’ensemble des NDS permet la construction de tout l’ensemble des motifs séquentiels Théorème 2 Soit S une séquence et soit α un item l’intervalle calculé par les règles de dé rivations pour la valeur du support de la séquence S ∪ α respectivement S ⋄ α est 2∆S∪αX respectivement 2∆S⋄αX plus petit que l’intervalle calculé pour la valeur du support de la séquence S Corollaire 2 Monotonie Soit X � S une séquence Si X est une DS alors S est aussi une DS Preuve Si X est une DS alors UX −LX = 0 En utilisant le théorème 2 nous savons que US − LS ≤ 1 2∆S X UX − LX d’où US = LS � 4 L’algorithme NDSP Dans cette section nous présentons notre approche afin de construire une représentation condensée des motifs séquentiels à partir des règles de déductions extraite du théorème 1 et du corollaire 2 L’avantage d’une représentation condensée est qu’elle est souvent plus petite que l’ensemble des motifs séquentiels noté F ce qui rend cette représentation adéquate dans le cadre d’extractions de motifs à partir de données fortement corrélées ou très denses Les motifs séquentiels non dérivables sont donc adéquats pour l’extraction de grands ensembles de motifs séquentiels qui ne pourraient pas être obtenus à l’aide d’algorithmes classiques Théorème 3 Soit D une base de données σ un seuil de support minimal Soit NDSF D σ un ensemble défini tel que NDSF D σ = { S Support S |Support S ≥ σ ∧ US 6= LS} NDSF D σ est une représentation condensée de l’ensemble F Pour chaque séquence X 6∈ NDSF D σ nous pouvons dériver Support X à partir de ses sous séquences conte nues dans NDSF D σ Preuve Extension de Calders 2003 La preuve est construite par induction sur la taille de la séquence S Raissi et Poncelet 2006 Dans notre approche la valeur ∆SX utilisée afin de calculer nos règles de déductions n’est pas extraite d’une matrice inversée afin d’optimiser les calculs mais calculée par la fonction Proposition 1 Let X � J ≺ S ∆JX = { 1 if |J − X | < 2 φ − 1 if |J − X | ≥ 2 Où φ est le nombre de sous séquences de taille |S − 1| tel que X � S Pour le cas spécial où J = S Si X = {} alors ∆S{} = 1 Extraction de motifs séquentiels non dérivables Corollaire 3 Soit S une séquence régulière alors S est non dérivable Preuve Notons qu’une séquence régulière possède une unique sous séquence X avec |S− X | = 1 A partir de l’équation 5 et 1 si |S − X | > 1 alors ∆SX = φ − 1 = 0 donc δX S est indéfinie � Nous avons developpé un algorithme NDSP Non Derivable Sequential Patterns qui per met de de construire la représentation condensée NDSF D σ NDSP est un algorithme par niveau et est complétement indépendant de la structure de données utilisée pour la représen tation des séquences L’algorithme 1 est basé sur la stratégie classique du générer élaguer et est divisé en 3 étapes distinctes i la génération de candidats ligne 1 et 15 avec la fonc tion CandidateGeneration ii Le comptage de support ligne 5 iii Déterminer les séquences non dérivables dans Flevel grâce à la fonction ComputeBounds ligne 8 les séquences dérivables sont élaguées ligne 11 Le processus s’arrête quand il n’y a plus de can didats générés Algorithme 1 algorithme NDSP Data Une base de données D σ un seuil de support minimal Result NDSF D σ NDSF D σ ← ∅ 1 level← 1 2 C1 ← {{i}|i ∈ I} 3 while Clevel 6= ∅ do4 CountSupport Clevel 5 Flevel ← {S ∈ Clevel | Support S ≥ σ} 6 foreach S ∈ Flevel do7 LS US ← ComputeBounds S 8 if LS = US and LS = Support S then9 S est une séquence dérivable 10 Flevel ← Flevel \ S 11 else12 S est une séquence non dérivable LS 6= US 13 NDSF D σ ← NDSF D σ ∪ S 14 Clevel+1 = CandidateGeneration Flevel 15 level = level + 1 16 return NDSF D σ 17 ComputeBounds Algorithme 2 est appelé par NDSP afin de calculer les bornes supérieures et inférieures pour une séquence S ComputeBounds vérifie aussi que les règles restent cohérentes par rapport à la base de données D lignes 8 et 13 Le test de cohérence est obligatoire car la projection doit prendre en compte les séquences incomparables qui peuvent amener à des règles du type US < LS ou US = LS ∧ LS 6= Support S La dernière fonction IE Algorithme 3 appelée par ComputeBounds est la fonction qui calcule la formule d’inclusion exclusion 5 d’une manière exhaustive De plus l’évaluation de ∆JX est faite dans le corps de la fonction IE C Raïssi et al Algorithme 2 algorithme COMPUTEBOUNDS Data Une séquence S Result les bornes sur la valeur du support de la séquence S l u 1 foreach X ≺ S do2 l← 0 3 u← |C| 4 Calcul des bornes à partir du théorème 1 5 delta← IE S X 6 if |S −X| est impair then7 Test de cohérence 8 if delta ≥ l then9 u← min u delta 10 |S −X| est impair 11 else12 Test de cohérence 13 if delta < u then14 l← max l delta 15 if l = u then16 return l u 17 return l u 18 Algorithme 3 algorithme IE Data Les séquences S et X pour calculer RX S Result V valeur de la règle RX S level← |X| 1 V ← −1 |S−X|+1 ×∆X X × Support X 2 while level < |S| − 1 do3 SuperSeq← X getSuperSequences level + 1 4 foreach J ≺ SuperSeq do5 V ← V + −1 |S−J|+1 ×∆J X × Support J 6 if |X| 6= 0 then7 ∆S X = S getSubContain X − 1 8 else9 ∆S X = 1 10 return V ← V ∆S X 11 Extraction de motifs séquentiels non dérivables 5 Expérimentations DataSet Items Taille moy des trans de transactions de clients CL10KTR1KIT1KI10 1000 10 1000 10000 CL1KTR10KIT500I40 500 40 10000 1000 CL5KTR10KIT100I20 100 20 10000 5000 FIG 2 – Les différents jeux de données pour les expérimentations de NDSP Les expérimentations ont été réalisées sur un ordinateur MacBookPro Core Du cadencé à 2 16 Ghz avec 1Gb de mémoire avec le système d’exploitation Mac OS X 10 4 6 Nous comparons notre algorithme NDSP avec 1 Un algorithme d’extraction de motifs séquentiels PrefixSpan Pei et al 2004 2 Un algorithme d’extraction de motifs séquentiels clos représentation condensée noté ClosF CloSpan Yan et al 2003 Les tests ont été faits sur plusieurs jeux de données synthétiques générés avec l’outil Dat Gen1 qui est une extension de l’outil IBM QUEST Les différentes caractéristiques des jeux de données sont représentées dans la figure 2 Les tests se concentrent principalement sur les performances au niveau de la représentation condensée L’algorithme NDSP a été implementé en JAVA et utilise une structure de données arborescente pour le stockage des séquences et des supports La figure 3 montre les résultats d’extraction et les performances pour les 2 premiers jeux de données Pour 0 05 ≤ σ ≤ 0 3 NDSP dépasse CloSpan et largement PrefixSpan au niveau de la condensation des motifs séquentiels extraits De plus pour σ = 0 1 le nombre des motifs séquentiels non dérivables décroît plus rapidement que les deux autres approches L’extraction s’arrête pour l’algorithme NDSP au niveau de profondeur 6 alors que les deux autres algorithmes s’arrêtent à la profondeur 8 Pour CL1000TR10000IT500I40 NDSP teste beaucoup moins de séquences candidates que PrefixSpan ou CloSpan De plus le nombre de motifs séquentiels non dérivables tend à décroître plus rapidement avec le jeu de don nées CL10000TR1000IT1000I10 En effet ceci est dû principalement à la taille des séquences puisque le jeu de données CL1000TR10000IT500I40 contient un ensemble de motifs séquen tiels très long avec très peu d’items différents sachant que les séquences longues ont plus de chance d’être dérivables puisqu’elles contiennent plus d’informations NDSP réalise donc un meilleur taux de compression avec des données denses contenant de longues séquences Le reste des jeux de données est documenté dans Raissi et Poncelet 2006 6 Etat de l’art Ces dernières années de nombreuses recherches se sont intéressées à des représentations condensées pour les itemsets Les représentations concises les plus importantes sont les item sets fréquents clos Boulicaut et Bykowski 2000 qui sont basés sur l’opérateur de ferme ture sur le treillis De nombreux algorithmes ont été développés comme CLOSET Pei et al 2000 et CHARM Zaki et Hsiao 2002 qui utilisent une stratégie de profondeur d’abord 1 datasetgenerator com C Raïssi et al 0 100 200 300 400 500 0 1 2 3 4 5 6 7 8 F re qu en t s eq ue nc e s Depth PrefixSpan NDSP CloSPAN a CL10000TR1000IT1000I10 0 2000 4000 6000 8000 10000 0 0 05 0 1 0 15 0 2 0 25 0 3 of F re qu en t s eq ue nc e s Support PrefixSpan NDSP CloSPAN b CL10000TR1000IT1000I10 0 500 1000 1500 2000 2500 2 4 6 8 10 12 F re qu en t s eq ue nc e s Length of Sequence PrefixSpan NDSP CloSPAN c CL1000TR10000IT500Q0I40 0 1000 2000 3000 4000 5000 0 65 0 7 0 75 0 8 0 85 0 9 F re qu en t s eq ue nc e s Support PrefixSpan NDSP CloSPAN d CL1000TR10000IT500Q0I40 FIG 3 – Taux de compression et nombres de séquences fréquentes pour différentes profon deurs et supports et considèrent que la base peut être chargée en mémoire Les ensembles fréquents libres Boulicaut et al 2003 considèrent qu’un itemset I est libre si et seulement si ∀X ⊂ I Support X 6= Support I Cette propriété est antimonotone ce qui la rend bien adaptée à une représentation concise Enfin les itemsets non dérivables proposés par Calders et Goethals 2002 Calders 2003 cherchent à détecter les redondances dans l’ensemble de tous les item sets fréquents à l’aide de règles de déduction basées sur le principe d’inclusion exclusion La propriété de non dérivabilité étant non monotone elle permet une représentation concise Dans le cas des motifs séquentiels il n’existe à notre connaissance que les algorithmes CloSpanYan et al 2003 et Bide Wang et Han 2004 qui s’intéressent à une représentation condensée Ce pendant Bide ne considère que des séquences dont les itemsets sont réduits à un seul item 7 Conclusion Dans cet article nous avons abordé la problématique des représentations condensées pour les motifs séquentiels Nos contributions principales sont les suivantes Premièrement nous avons jetés les bases formelles pour une nouvelle représentation Nous introduisons les concepts théoriques des motifs séquentiels non dérivables et prouvons que les bornes sur la valeur du support d’une séquence peuvent être déduites à partir de règles Celles ci sont calculées grâce au principe d’inclusion exclusion A notre connaissance ce travail est le premier travail à in troduire une nouvelle représentation condensée autre que la représentation close des motifs sé quentiels Deuxièmement nous avons developpé un algorithme NDSP qui dépasse en terme de taux de compressions les algorithmes actuels d’extractions de motifs séquentiels et de motifs séquentiels clos Ce travail offre de nombreuses perspectives Tout d’abord le lemme 4 doit être affiné afin de prouver la complétude et l’adéquation de notre méthode permettant ainsi l’extraction de motifs non dérivables sans avoir à tester les cohérences des règles et passer par l’actuelle étape de comptage De plus cette approche peut être couplée à des algorithmes très efficaces comme SPADE ou PrefixSPAN Ce couplage permettrait d’augmenter la vitesse Extraction de motifs séquentiels non dérivables d’extraction puisque ces algorithmes utilisent des structures de données déjà optimisées pour la génération de candidats et leur élagage La dernière perspective serait d’étendre la théorie de la non dérivabilité vers d’autres motifs tels que les arbres et les graphes Références Boulicaut J F et A Bykowski 2000 Frequent closures as a concise representation for binary data mining In T Terano H Liu et A L P Chen Eds PAKDD LNCS pp 62–73 Boulicaut J F A Bykowski et C Rigotti 2003 Free sets A condensed representation of boolean data for the approximation of frequency queries Data Min Knowl Discov 7 1 5–22 Calders T 2003 Axiomatization and Deduction Rules for the Frequency of Itemsets Ph D thesis University of Antwerp Belgium Calders T et B Goethals 2002 Mining all non derivable frequent itemsets In PKDD pp 74–85 Springer Knuth D E 1973 Fundamental Algorithms Addison Wesley Lattner A D A Miene U Visser et O Herzog 2005 Sequential pattern mining for situation and behavior predic tion in simulated robotic soccer In RoboCup International Symposium 2005 Mannila H et H Toivonen 1996 Multiple uses of frequent sets and condensed representations extended abstract In Knowledge Discovery and Data Mining pp 189–194 Mobasher B H Dai T Luo et M Nakagawa 2002 Using sequential and non sequential patterns in predictive web usage mining tasks In ICDM pp 669–672 Pei J J Han et R Mao 2000 CLOSET An efficient algorithm for mining frequent closed itemsets In ACM SIGMOD Workshop on Research Issues in Data Mining and Knowledge Discovery pp 21–30 Pei J J Han B Mortazavi Asl J Wang H Pinto Q Chen U Dayal et M Hsu 2004 Mining sequential patterns by pattern growth The prefixspan approach IEEE Trans Knowl Data Eng 16 11 1424–1440 Raissi C et P Poncelet 2006 Mining non derivable sequential patterns Technical Report 06037 University of Montpellier 2 LIRMM Ramirez J C G D J Cook L L Peterson et D M Peterson 2000 An event set approach to sequence discovery in medical data Intell Data Anal 4 6 513–530 Srikant R et R Agrawal 1996 Mining sequential patterns Generalizations and performance improvements In EDBT Srikant R A R 1995 Mining sequential patterns In Proceedings of the 11th International Conference on Data Engineering ICDE 95 Tapei Taiwan pp 3–14 Wang J et J Han 2004 Bide Efficient mining of frequent closed sequences In D Barbará et C Kamath Eds ICDE pp 79–90 IEEE Computer Society Yan X J Han et R Afshar 2003 Clospan Mining closed sequential patterns in large databases In D Barbará et C Kamath Eds SDM SIAM Zaki M J 2001 Spade An efficient algorithm for mining frequent sequences Machine Learning 42 1 2 31–60 Zaki M J et C J Hsiao 2002 Charm An efficient algorithm for closed itemset mining In R L Grossman J Han V Kumar H Mannila et R Motwani Eds SDM SIAM Summary Mining Sequential Patterns is one of the main challenges in data mining In this paper we establish the first basis for theoretical upper and lower bounds on the support of a candi date sequential pattern S We show how these bounds can be derived from S sub sequences These rules allow the construction of a concise representation of the frequent sequential pat terns We give the results of experiments and show that our proposal produces a better concise representation than the closed collection while keeping the same expression information 