Le FIA un nouvel automate permettant l'extraction efficace d'itemsets fréquents dans les flots de données Le FIA un nouvel automate permettant l’extraction efficace d’itemsets fréquents dans les flots de données Jean Émile SYMPHOR Alban MANCHERON Lionel VINCESLAS et Pascal PONCELET GRIMAAG Université des Antilles et de la Guyane Martinique France {je symphor alban mancheron lionel vinceslas} martinique univ ag fr EMA LG2IP site EERIE Parc Scientifique Georges Besse 30035 Nîmes Cedex France pascal poncelet ema fr Résumé Le FIA Frequent Itemset Automaton est un nouvel automate qui per met de traiter de façon efficace la problématique de l’extraction des itemsets fréquents dans les flots de données Cette structure de données est très compacte et informative et elle présente également des propriétés incrémentales intéres santes pour les mises à jour avec une granularité très fine L’algorithme déve loppé pour la mise à jour du FIA effectue un unique passage sur les données qui sont prises en compte tout d’abord par batch i e itemset par itemset puis pour chaque itemset item par item Nous montrons que dans le cadre d’une ap proche prédictive et par l’intermédiaire de la bordure statistique le FIA permet d’indexer les itemsets véritablement fréquents du flot en maximisant le rappel et en fournissant à tout moment une information sur la pertinence statistique des itemsets indexés avec la P valeur 1 Introduction L’extraction d’itemsets fréquents est une problématique de recherche qui intéresse la com munauté fouille de données depuis plus d’une dizaine d’années et intervient pour la recherche de règles d’association de motifs séquentiels ou encore d’itemsets maximaux Les premiers à traiter cette question furent Agrawal et Srikant 1994 ils ont été suivis en ce sens par Han et al 2000 Traditionnellement les différents algorithmes proposés dans la littérature reposent sur des structures de données de type arbre ou encore treillis e g A priori Agrawal et Srikant 1994 FP growth Han et al 2000 La problématique de re cherche de motifs i e une généralisation des itemsets apparaît dans des domaines aussi variés que la bioinformatique ou la fouille de textes En ce qui concerne ce dernier de nouvelles struc tures de données basées sur des automates sont apparues afin d’extraire les sous séquences communes à une ensemble de textes Troníček 2002 Par exemple Hoshino et al 2000 ont introduit un nouvel automate déterministe et acyclique le SA Subsequence Automaton qui permet de reconnaître toutes les sous séquences d’un ensemble de textes L’un des pro blèmes principaux auxquels doit faire face une approche d’extraction de motifs est de disposer de structures qui soient suffisamment compactes et informatives afin de minimiser l’explosion combinatoire liée à d’importants espaces de recherche En effet l’applicabilité des algorithmes Automate des Itemsets Fréquents le FIA proposés peut être remise en question en raison des coûts trop prohibitifs en temps de calcul et en espace mémoire utilisé Le premier objectif de cet article est d’apporter une réponse à la question suivante est il possible de trouver de nouvelles structures de données suffisamment informatives et compactes pour extraire de façon efficace les itemsets fréquents Récemment pour faire face au fait que les données peuvent être disponibles sous la forme de flots qui arrivent de manière continue et sont éventuellement en quantités infinies les cher cheurs de la communauté fouille de données se sont intéressés à l’extraction de connaissance dans de telles conditions De nombreuses applications e g transactions financières navigation sur le Web téléphonie mobile rentrent dans ce cadre et nécessitent d’obtenir des résul tats rapidement Dans le cas de la problématique d’extraction d’itemsets fréquents la prise en compte de données disponibles sous la forme de flots engendre de nouvelles problématiques En premier lieu il est indispensable de considérer les aspects liés à la mise à jour En effet étant donné que les données arrivent de manière continue la base de données est sujette à des mises à jour régulières et fréquentes Ainsi la connaissance obtenue pour une base à un moment donné n’est plus forcément valable lorsque de nouvelles données arrivent et il n’est pas envisageable de relancer l’algorithme sur toute la base mise à jour La maintenance de connaissance incré mentale a par exemple été étudiée dans Masséglia et al 2003 où les auteurs proposent de maintenir la connaissance au fur et à mesure des mises à jour successives Malheureusement tous les travaux de recherche basés sur une approche incrémentale ne sont pas adaptés aux flots dans la mesure où nous ne pouvons pas disposer de la base dans son intégralité Il est donc né cessaire en second lieu de disposer de nouveaux algorithmes qui effectuent une seule passe sur la base i e des algorithmes une passe Les travaux récents sur les flots ont montré qu’il n’était plus envisageable d’obtenir une réponse exacte i e les itemsets réellement fréquents sur le flot et qu’il fallait accepter une approximation quant à l’estimation de la fréquence des motifs les itemsets obtenus ne sont en fait que des itemsets fréquents observés Il faut donc prendre en compte l’incertitude engendrée par la connaissance toujours incomplète du flot de données Il est important de noter que dans les flots des itemsets classés comme non fréquents peuvent le devenir sur une plus longue période d’observation et inversement des itemsets ob servés fréquents peuvent ne plus l’être après un certain temps Dans Vapnik 1998 l’auteur a montré qu’il est statistiquement impossible de s’affranchir de ces deux sources d’erreurs à partir de la connaissance d’une partie même très grande du flot On peut toutefois chercher à minimiser l’une des sources d’erreurs tout en maintenant l’autre en dessous d’un seuil raison nable La seconde question à laquelle nous nous intéressons dans cet article est la suivante est il possible de trouver une structure de données ayant des propriétés incrémentales satisfai santes et qui permette de construire et de la maintenir de façon efficace l’ensemble des itemsets fréquents du flot de données tout en minimisant l’une ou l’autre des sources d’erreurs La suite de l’article est organisée de la manière suivante La Section 2 présente plus for mellement la problématique Dans la Section 3 nous proposons un aperçu d’autres travaux abordant cette problématique La Section 4 présente notre approche et nos solutions Les expé rimentations sont décrites dans la Section 5 et une conclusion est proposée dans la Section 6 2 Problématique Soit I = {i1 i2 im} un ensemble d’items muni d’une relation d’ordre utilisés dans une base de données DB de transactions où chaque transaction tr identifiée de manière unique est associée à un ensemble d’items de I Un ensemble X ⊆ I est appelé un p itemset et est RNTI E 2 J É SYMPHOR al représenté par {x1 x2 xp} L’entier p = |X | est la longueur de X et Sub X l’ensemble de tous les sous itemsets de X c’est à dire les itemsets obtenus en supprimant zéro ou plusieurs items de X Le support d’un itemset X noté supp X correspond au nombre de transactions dans lesquelles l’itemset apparaît Un itemset est dit θ fréquent si supp X ≥ σ où σ = ⌈θ × |DB|⌉ correspond au support minimal généralement spécifié par l’utilisateur avec θ ∈]0 1] et |DB| la taille de la base de données Le problème de la recherche des itemsets fréquents consiste à rechercher tous les itemsets dont le support est supérieur ou égal à σ dans DB Cette problématique étendue au cas des flots de données peut s’exprimer comme suit Soit un flot de données DS = Bbiai B bi+1 ai+1 · · · B bn an un ensemble infini de batches où chaque batch est associé à une période de temps [aj bj] i e B bj aj avec bj > aj et B bn an le plus récent batch obtenu Chaque batch Bbjaj correspond à un ensemble de transactions d’itemsets où B bj aj = [s1 s2 · · · sp] Nous supposons également que les batches n’ont pas nécessairement la même taille La cardinalité k du flot de données |DS| à un instant donné est définie par k = |Bbiai | + |B bi+1 ai+1 | + · · · + |B bn an | où |Bbjaj | correspond à la cardinalité du batch B bj aj La fréquence d’un itemset X à un instant donné t est défini comme étant le ratio du nombre de transactions qui contiennent X dans les différents batches sur le nombre total de transactions connu à l’instant t Ainsi pour un support minimal fixé par l’utilisateur le problème de la recherche des itemsets fréquents dans un flot de données consiste à rechercher tous les itemsets X qui vérifient ∑bi ai supp X ≥ ⌈θ × k⌉ dans le flot Dans l’exemple de la Table 1 |B10 | = 5 et k = 8 Dans |B10 | le support de l’itemset {bc} est 2 sa fréquence est 0 4 sur l’ensemble du flot son support est 5 et sa fréquence 0 625 Cet exemple de flot est repris dans la suite du papier B10 B 2 1 B 3 2 s1 s2 s3 s4 s5 s6 s7 s8 abcde bcef be abd cd abc abce bcef TAB 1 – Ensembles de batches B10 B 2 1 et B 3 2 construits sur I = {a b c d e f} 3 Travaux antérieurs Les différents travaux portant sur la problématique d’extraction d’itemsets fréquents dans les flots de données se déclinent selon trois axes en fonction du modèle de traitement des itemsets du flot Le premier utilise des fenêtres à point fixe où sont conservés tous les itemsets acquis du flot cf Manku et Motwani 2002 Li et al 2004 Le second axe est différent du pré cédent simplement par le fait que l’on introduit une distinction entre les itemsets récemment et moins récemment acquis Chang et Lee 2004b attribuent un poids décroissant aux tran sactions en fonction de l’ancienneté de leur acquisition Autrement dit les anciennes transac tions contribuent moins que les nouvelles au calcul de la fréquence des itemsets Par exemple Giannella et al 2004 utilisent une structure de type FP tree pour rechercher des itemsets fré quents à différents niveaux de granularité temporelle Le dernier axe concerne l’extraction à partir de fenêtres glissantes où l’on ne considère plus seulement l’acquisition mais aussi le retrait d’itemsets cf travaux de Chang et Lee 2004a L’approche que nous développons dans cet article s’inscrit dans le premier axe Aussi nous préciserons dans la suite de ce para RNTI E 3 Automate des Itemsets Fréquents le FIA graphe les caractéristiques des algorithmes ainsi que l’erreur et les types d’approximation sur les résultats relatifs à cet axe Manku et Motwani 2002 ont développé un algorithme Lossy counting basé sur la propriété d’antimonotonie du support Cet algorithme effectue un seul passage sur les données et utilise une structure à base d’arbres pour représenter les itemsets Les auteurs introduisent un paramètre d’erreur fixé par l’utilisateur et voulu très inférieur au support afin de minimiser le nombre de résultats faux positifs et afin d’améliorer la valeur de la fréquence obtenue des itemsets Ils donnent les garanties suivantes sur leurs résultats tous les itemsets réellement fréquents sont trouvés il n’y a pas de faux négatifs tous les itemsets considérés fréquents à tort i e les faux positifs ont une fréquence proche de la fréquence voulue l’incertitude sur la fréquence des itemsets est fonction du paramètre d’erreur Li et al 2004 proposent d’extraire les itemsets fréquents en partant des plus grands aux plus petits et utilisent une structure très compacte qui résulte d’une extension d’une représentation basée sur des arbres préfixés le CFI tree Candidate Frequent Itemset tree Toutefois l’algorithme développé DSM FI bien qu’effectuant un seul passage sur les données comprend une phase d’élagage du CFI tree et nécessite plusieurs parcours de la structure pour obtenir l’infor mation sur la fréquence des itemsets Les garanties apportées quant aux résultats indiquent qu’il n’y a pas de faux négatifs et que l’erreur sur la fréquence des itemsets est bornée 4 Notre Approche Dans un premier temps nous nous intéressons à l’extraction des itemsets fréquents dans une base de données Nous introduisons un nouvel automate le FIA Frequent Itemset Auto maton qui constitue une structure de données très compacte et informative permettant d’ex traire de façon efficace tous les itemsets fréquents d’une base de données Dans un second temps nous étendons cette approche à la prise en compte des flots de données et nous mon trons comment mettre à jour incrémentalement le FIA lors de l’ajout de nouveaux batches issus du flot Cependant pour tenir compte de l’incertitude engendrée par la connaissance toujours incomplète du flot nous étudions la représentation de la bordure statistique à l’aide du FIA afin de développer une approche prédictive Laur et al 2007 En effet plutôt que d’extraire des itemsets observés fréquents sur la partie connue du flot nous considérons qu’il est préférable de prédire les itemsets véritablement fréquents sur tout le flot à partir des itemsets connus 4 1 Rappels sur la théorie des automates Nous présentons dans cette section les principes fondamentaux de la théorie sur les auto mates finis cf Hopcroft et Ullman 1990 qui seront utilisés dans la suite Définition 1 Un automate à états finis A est un quintuple tel que A = Q Σ δ I F où Q est un ensemble fini d’états Σ un alphabet δ ⊆ Q × Σ × Q est un ensemble de transitions I ⊆ Q et respectivement F ⊆ Q sont l’ensemble des états initiaux et finaux L’étiquette d’une transition d passant d’un état q à un état q′ noté d = q α q′ est le symbole α Un chemin dans A est une suite c = d1 · · · dn de transitions consécutives avec pour étiquette |c| = α1 · · ·αn On écrit également si w = |c| c q0 w −→ qn Un chemin c i → f est dit réussi si i ∈ I et f ∈ F Un mot est reconnu s’il est l’étiquette d’un chemin réussi Le langage reconnu par l’automate A est l’ensemble des mots reconnus par A soit L A = {w ⊆ Σ|∃c i w −→ f i ∈ I l ∈ F} Un état q ∈ Q d’un automate RNTI E 4 J É SYMPHOR al A = Q Σ δ I F est accessible s’il existe un chemin c i → q avec i ∈ I De même l’état q est coaccessible s’il existe un chemin c q → f avec f ∈ F Un automate est émondé si tous ses états sont accessibles et coaccessibles Soit P l’ensemble des états accessibles et coaccessibles et soit A0 = P Σ δ∩ P ×Σ×P I ∩P F ∩P l’automate A0 est émondé par construction Comme tout chemin réussi de A ne passe que par des états accessibles et coaccessibles on a L A0 = L A Les automates A0 et A sont dits équivalents Définition 2 Un automate à états finis A = Q Σ δ I F est déterministe si et seulement s’il existe un unique état initial |I| = 1 et si ∀ p α q p α q′ ∈ δ ⇒ q = q′ Nous adaptons les Définitions 3 et 4 proposées initialement par Hoshino et al 2000 pour l’automate des sous séquences SA au cas des itemsets Définition 3 Étant donnés un ensemble S d’itemsets tel que S = {s1 sk} avec si ⊆ I pour tout i ∈ [1 k] ainsi qu’une relation d’ordre ℜ sur I un point position ou ppos de l’ensemble S est un k uplet [p1 pk] où pi ∈ [0 ni]∪{∞} est un numéro de position dans l’itemset si de longueur ni ordonné selon ℜ noté s̃i Si pi = 0 cette position correspond à celle de l’itemset vide noté ε se trouvant devant le premier item de s̃i Si pi = ∞ cette autre position correspond à celle de l’itemset vide ε se trouvant derrière le dernier item de s̃i Autrement cette position correspond à la position du pèmei item de s̃i pour tout i ∈ [1 k] La position particulière correspondant à pi = 0 pour tout i ∈ [1 k] est appelée point position initial noté qk0 L’autre position particulière correspondant à pi = ∞ pour tout i ∈ [1 k] est appelée point position puits noté qk∞ On note Pos S l’ensemble des ppos de S Définition 4 Étant donnés un ensemble S d’itemsets tel que S = {s1 sk} avec si ⊆ I pour tout i ∈ [1 k] un ppos [p1 pk] ∈ Pos S ainsi qu’un item ii ∈ I le point position atteint noté PPAS [p1 pk] ii est le ppos [p′1 p ′ 2 p ′ k] tel que ∀ i ∈ [1 k] p′i = min { j | j > pi ∧ si[j] = ii } ∪ { ∞ } 4 2 L’automate des itemsets fréquents le FIA Dans cette section nous introduisons la définition d’un nouvel automate le FIAθ qui in tègre la notion de fréquence et qui permet de reconnaître l’ensemble des itemsets fréquents d’une base de données Définition 5 Étant donnés un ensemble S d’itemsets S = {s1 sk} avec si ⊆ I pour tout i ∈ [1 k] ainsi qu’un entier σ correspondant à la valeur du support choisi tel que 1 ≤ σ ≤ k le ppos [p1 pk] ∈ Pos S satisfait la contrainte de support σ si et seulement si ∣∣∣ { pi | pi < ∞ }∣∣∣ ≥ σ Le cas échéant le ppos [p1 pk] est dit σ satisfaisant L’ensemble de tous les ppos qui sont σ satisfaisants est noté Posσ S C’est un sous ensemble de Pos S Exemple 1 Considérons le batch B10 de la Table 1 correspondant à l’ensemble d’itemsets S = {s1 s2 s3 s4 s5} À partir de l’état initial qk0 le ppos atteint par l’item a est selon la Définition 4 tel que PPAS [0 0] a = [1 ∞ ∞ 1 ∞] comme cela est schématique ment représenté ci dessous RNTI E 5 Automate des Itemsets Fréquents le FIA a b c d e b c e f b e a b d c d 0 1 2 3 4 5 ∞ 0 1 2 3 4 ∞ 0 1 2 ∞ 0 1 2 3 ∞ 0 1 2 ∞ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ p1 p ′ 1 p2 p ′ 2 p3 p ′ 3 p4 p ′ 4 p5 p ′ 5 Cela illustre pour les itemsets s1 et s4 que l’item a est à la première position donc numéroté 1 dans le point position atteint De même pour les itemsets s2 s3 s5 cela illustre que l’item a n’existe pas ce qui est exprimé par l’utilisation du symbole ∞ dans le point position atteint Le ppos [1 ∞ ∞ 1 ∞] est donc 2 satisfaisant en effet l’inéquation de la Définition 5 est vérifiée car pi est inférieur à ∞ 2 fois En revanche ce même ppos n’est pas 3 satisfaisant Définition 6 Étant donnés un ensemble S d’itemsets tel que S = {s1 sk} avec si ⊆ I pour tout i ∈ [1 k] une relation d’ordre ℜ sur I ainsi qu’un entier σ = ⌈θ k⌉ avec θ ∈ ]0 1] représentant le support seuil l’automate des itemsets fréquents est le quintuple FIAθ S = Q I δ I F où Q = Pos S I = {qk0} δ = PPAS et F = Posσ S Il est aisé de constater que les états qui ne sont pas σ satisfaisants ne sont pas coaccessibles le contraire signifierait qu’un itemset non fréquent est inclus dans un itemset fréquent Ainsi le FIAθ émondé s’obtient en ne construisant que les états σ satisfaisants accessibles Un simple algorithme glouton permet de le construire et ne requiert en aucun cas une phase d’élagage Le support d’un itemset étiquetant un chemin de l’état initial à un état q donné du FIAθ S s’obtient en calculant le nombre de valeurs qui ne sont pas égales à ∞ dans le ppos associé à q Ainsi un itemset étiquetant qk0 → q est θ fréquent dans S si et seulement si q est un état σ satisfaisant d’où la propriété suivante Propriété 1 Étant donnés un ensemble S d’itemsets tel que S = {s1 sk} avec si ⊆ I pour tout i ∈ [1 k] ainsi qu’un entier σ = ⌈θ k⌉ avec θ ∈ ]0 1] représentant le support seuil le langage reconnu par le FIAθ S est l’ensemble des itemsets θ fréquents de S On en déduit assez aisément que deux itemsets fréquents reconnus dans le même état ont nécessairement même support En outre par construction des ppos étant donnés deux itemsets X Y ⊆I étiquetant chacun un chemin de qk0 vers q dans le FIAθ S si |X | < |Y| alors X ⊂ Y si |X | = |Y| alors X ≡ Y et si |X | > |Y| alors X ⊃ Y d’où la propriété ci après Propriété 2 Étant donnés un ensemble S d’itemsets un entier σ = ⌈θ k⌉ avec θ ∈ ]0 1] ainsi que le FIAθ S correspondant pour tout état q tel qu’il n’existe pas de transition vers un état q′ de même support le plus long itemset reconnu en q est un itemset fermé il est unique Réciproquement tous les itemsets fermés sont reconnus dans des états q tels qu’il n’existe pas de transition menant à un état q′ de même support En considérant le batch B10 de la Table 1 nous montrons sur la Figure 1 le FIAθ émondé pour θ = 0 4 et donc σ = 2 Les états finaux sont repérés par un double cercle et l’état initial est représenté avec une flèche entrante sans label L’itemset vide est reconnu à l’état initial avec le support 5 Par ailleurs nous observons que les itemsets abd ad et bd avec une même valeur de support à 2 sont reconnus à l’état q7 Il en est de même pour les itemsets bce et ce de support 2 reconnus en q10 et pour be et e de support 3 en q5 Le FIAθ du fait de la Propriété 2 est une structure très compacte En effet seuls les états q1 q6 et q8 n’identifient pas un itemset fermé la Propriété 2 donne les équivalences suivantes pour les itemsets fermés q0 ⇔ ε RNTI E 6 J É SYMPHOR al q2 ⇔ b q3 ⇔ c q4 ⇔ d q5 ⇔ be q7 ⇔ abd q9 ⇔ cd et q10 ⇔ bce Enfin si l’on choisit la fréquence décroissante comme relation d’ordre ℜ sur les items à l’instar de l’algorithme FP growth le FP tree résultant compte 11 nœuds mais 10 états pour le FIA dans ce cas q0 q1 q2 q3 q4 q5 q6 q7 q8 q9 q10 a b c d e b d d c e e d d e avec    q0 = [0 0 0 0 0] q1 = [1 ∞ ∞ 1 ∞] q2 = [2 1 1 2 ∞] q3 = [3 2 ∞ ∞ 1] q4 = [4 ∞ ∞ 3 2] q5 = [5 3 2 ∞ ∞] q6 = [2 ∞ ∞ 2 ∞] q7 = [4 ∞ ∞ 3 ∞] q8 = [3 2 ∞ ∞ ∞] q9 = [4 ∞ ∞ ∞ 2] q10 = [5 3 ∞ ∞ ∞] FIG 1 – FIA40% {abcde bcef be abd cd} 4 3 Le FIA appliqué aux flots de données 4 3 1 Mise à jour incrémentale du FIA Hoshino et al 2000 ont exploité deux propriétés incrémentales du SA la première concer nant l’ajout d’une séquence vide tandis que la seconde concerne l’ajout d’un symbole à la der nière position de la dernière séquence traitée Ces deux propriétés s’appliquent sans difficulté au cas des itemsets pour effectuer la mise à jour incrémentale du FIA Ainsi la construction et la mise à jour du FIA se fait en une passe sur les données et par incrément Le nouveau batch est considéré itemset par itemset du premier au dernier et pour chaque itemset item par item également du premier au dernier Nous représentons sur la Figure 3 le FIA40% émondé mis à jour avec la valeur des ppos1 compte tenu du batch B21 En considérant le batch B 3 2 le FIA de la Figure 3 demeure inchangé car le sous itemset bce de s8 est déjà reconnu et la prise en compte de l’item f provoquerait la création d’un état non σ satisfaisant 4 3 2 Intégration des bordures statistiques dans le FIA Appliquée au cas des flots de données la mise à jour du FIA requiert de connaître l’en semble des états accessibles y compris des états non σ satisfaisants En effet mettre à jour le FIA émondé reviendrait à considérer que les itemsets non reconnus par l’automate ont tous un support à 0 ce qui engendrerait nécessairement un grand nombre de faux négatifs sur la totalité du flot À l’inverse en considérant les états non σ satisfaisants un grand nombre d’itemsets vrais négatifs seraient analysés inutilement Afin d’illustrer cet aspect considérons d’une part la représentation du FIA40% émondé de la Figure 1 et d’autre part la représentation de la Fi gure 2 du FIA40% non émondé avec tous ses états accessibles Les états q11 q12 q13 q14 ne sont pas 2 satisfaisants mais 1 satisfaisants et ne sont donc pas finaux La question revient à savoir quel est l’automate qu’il convient de considérer pour effectuer la mise à jour du FIA Il est donc nécessaire de trouver un compromis entre ne conserver aucun état non σ satisfaisant 1En pratique les ppos ne sont pas construits seul le support est calculé et mis à jour RNTI E 7 Automate des Itemsets Fréquents le FIA et tous les états accessibles Idéalement seuls les états qui correspondent à des itemsets vrais θ fréquents du flot devraient être construits quand bien même ils ne satisfont pas la contrainte de support à un instant donné La solution que nous avons adoptée est d’utiliser la bordure sta tistique supérieure présentée par Symphor et Laur 2006 dans laquelle est maximisé le rappel cf Définition 7 et Théorème 1 ci après q0 q1 q2 q3 q4 q5 q6 q7 q8 q9 q10 q11 q12 q13 q14a b c d e f b c d e c d e f d e f e f c d e e d e f ef d e e avec    q0 = [0 0 0 0 0] q5 = [5 3 2 ∞ ∞] q10 = [5 3 ∞ ∞ ∞] q1 = [1 ∞ ∞ 1 ∞] q6 = [2 ∞ ∞ 2 ∞] q11 = [3 ∞ ∞ ∞ ∞] q2 = [2 1 1 2 ∞] q7 = [4 ∞ ∞ 3 ∞] q12 = [4 ∞ ∞ ∞ ∞] q3 = [3 2 ∞ ∞ 1] q8 = [3 2 ∞ ∞ ∞] q13 = [∞ 4 ∞ ∞ ∞] q4 = [4 ∞ ∞ 3 2] q9 = [4 ∞ ∞ ∞ 2] q14 = [5 ∞ ∞ ∞ ∞] FIG 2 – FIA40% {abcde bcef be abd cd} non émondé Définition 7 La valeur θ′ est un support statistique pour θ 0 < θ′ < 1 si elle est utilisée pour approcher les motifs vrais θ fréquents du flot de données Le Théorème 1 ci dessous permet d’établir la valeur du support statistique qui permet la construction de la bordure statistique supérieure Théorème 1 Étant donné un flot de données observé DS = DS+ ⊎ DS− avec DS+ et DS− le nombre d’itemsets respectivement fréquents et non fréquent dans DS une valeur de θ ∈ ]0 1] ainsi qu’une probabilité appelée risque statistique δ ∈ ]0 1] pour tout ε tel que ε ≥ √ 1 2k ln |DS±| δ les supports statistiques θ′ = θ − ε avec DS± = DS− et θ′ = θ + ε avec DS± = DS+ sont respectivement tels que Rappel = 1 et Précision = 1 avec une probabilité au moins égale à 1 − δ Les fréquences obtenues θ′ = θ±ε sont statistiquement presque optimales cf Laur et al 2007 Celle ci repose sur l’utilisation d’inégalités de concentration de variables aléatoires qui dans ce cas précis permettent d’obtenir un résultat statistiquement presque optimal Par optimalité nous entendons que toute technique d’estimation obtenant de meilleures bornes RNTI E 8 J É SYMPHOR al est condamnée à se tromper le critère à maximiser n’est plus égal à un quel que soit son temps de calcul Dans le cas de la bordure statistique supérieure correspondant à θ′ = θ − ε il s’agit de réduire autant que possible le nombre de faux négatifs à savoir les itemsets véritablement fréquents du flot et qui ne sont pas retenus comme tels pour la partie observée du flot Lorsque seuls les états de la bordure statistique supérieure ont été conservés i e les états ⌊ θ−ε ×k⌋ satisfaisants l’automate obtenu après une mise à jour incrémentale est une approximation du FIAθ pour le flot observé nous le noterons F̂IAθ Toutefois le Théorème 1 permet d’affirmer au risque δ que F̂IAθ ≡ FIAθ De la sorte on minimise la première source d’erreurs cf Section 1 avec une forte probabilité 1 − δ Le langage L F̂IAθ est le plus petit ensemble possible qui contient tous les itemsets véritablement θ fréquents du flot pour sa partie observée Il n’y a pas de faux négatifs Rappel = 1 au risque δ Cet ensemble contient également des itemsets faux positifs c’est à dire θ fréquents pour la partie connue du flot mais qui ne le sont peut être plus sur tout le flot La Figure 3 représente le FIA40% émondé mis à jour qui est obtenu à partir du FIA40% non émondé de la Figure 2 compte tenu du batch B21 Les ppos des états q7 et q9 de la Figure 1 après mise à jour seraient égaux à q7 = [4 ∞ ∞ 3 ∞ ∞ ∞] q9 = [4 ∞ ∞ ∞ 2 ∞ ∞] et ne sont plus σ satisfaisants Ces états disparaissent du FIA40% émondé mis à jour Par contre le point position de l’état q11 vaut après mise à jour q11 = [3 ∞ ∞ ∞ ∞ 3 3] Cet état devient σ satisfaisant et apparaît comme état final du FIA40% émondé mis à jour de la Figure 3 C’est typiquement un état que nous n’aurions pas obtenu en effectuant la mise à jour à partir du FIA40% émondé de la Figure 1 En revanche il a fallu également traiter inutilement les états q12 q13 q14 alors qu’ils ne sont pas finaux et n’existent pas dans le FIA40% émondé mis à jour de la Figure 3 q0 q1 q2 q3 q4 q5 q6 q8 q10 q11 a b c d e b c c e e c e avec    q0 = [0 0 0 0 0 0 0] q1 = [1 ∞ ∞ 1 ∞ 1 1] q2 = [2 1 1 2 ∞ 2 2] q3 = [3 2 ∞ ∞ 1 3 3] q4 = [4 ∞ ∞ 3 2 ∞ ∞] q5 = [5 3 2 ∞ ∞ ∞ 4] q6 = [2 ∞ ∞ 2 ∞ 2 2] q8 = [3 2 ∞ ∞ ∞ 3 3] q10 = [5 3 ∞ ∞ ∞ ∞ 4] q11 = [3 ∞ ∞ ∞ ∞ 3 3] FIG 3 – FIA40% {abcde bcef be abd cd abc abce} Par ailleurs le Théorème 1 permet d’établir la propriété suivante Propriété 3 Étant donné un itemset X ⊆I de fréquence θ′ > θ sur la partie observée DS du flot DS avec DS+ l’ensemble des itemsets θ fréquents dans DS et |DS| = k alors la P valeur de l’itemset X i e la probabilité qu’il existe un itemset de fréquence observée θ′ qui ne soit pas θ fréquent sur la totalité du flot est inférieure à δ avec δ = |DS+| e2 k θ ′−θ 2 L’intérêt du calcul des P valeurs est clairement illustré dans Denise et al 2001 Ici la P valeur traduit littéralement que la probabilité qu’il existe un faux positif i e un itemset de fréquence observée θ′ qui ne soit pas θ fréquent sur tout le flot est inférieure à δ RNTI E 9 Automate des Itemsets Fréquents le FIA 5 Expérimentations 1 10 100 0 10 20 30 40 50 60 70 T e m p s e n s e c o n d e s Support en % kosarak FIA algorithm FP Growth Apriori FIG 4 – Temps de construction du FIAθ avec le jeu d’essai Kosarak 1000 10000 100000 0 10 20 30 40 50 60 70 M e m o ir e e n K o Support en % kosarak FIA algorithm FP Growth Apriori FIG 5 – Mémoire pour la construction du FIAθ avec le jeu d’essai Kosarak 30 35 40 45 50 0 2 4 6 8 10 12 14 16 18 20 T e m p s e n s e c o n d e s Batchs T10I4D100K FIA Online FIG 6 – Temps requis pour la mise à jour in crémentale du FIAθ avec θ = 1% pour le jeu d’essai T10I4D100K 100 150 200 250 300 350 400 450 500 0 2 4 6 8 10 12 14 16 18 20 M e m o ir e e n K o Batchs T10I4D100K FIA Online FIG 7 – Mémoire requise pour la mise à jour incrémentale du FIAθ avec θ = 1% pour le jeu d’essai T10I4D100K Nous présentons ici les expérimentations réalisées sur les jeux de données2 Kosarak et T10I4D100K Les tests ont été réalisés sur un ordinateur muni d’un processeur AMD ATHLON 3800+ 2 × 64 bits disposant de 1Go de RAM L’algorithme de construction du FIA a été écrit en C++ norme ANSI C99 Les Figures 4 et 5 illustrent le temps pris et la mémoire résidente re quise en fonction de la fréquence pour la construction du FIA sur le jeu de données Kosarak en se comparant aux algorithmes FP growth et A priori3 Notre algorithme de construc tion du FIA est en une passe mais pour la comparaison avec notamment FP growth nous avons utilisé une version deux passes le premier passage permettant uniquement de réordon ner les items par ordre de fréquences décroissantes Les résultats obtenus avec le FIA sont meilleurs sur une large plage de fréquence tant pour le temps pris que pour la mémoire re quise On observe effectivement au delà des valeurs de fréquence à 5% un écart en temps de l’ordre de 3 sec et de mémoire de 1Mo en faveur du FIA qui prend un temps total de 4 sec et consomme 3Mo par rapport à FP growth L’algorithme A priori qui effectue plusieurs passages sur les données donne de meilleurs résultats seulement à partir des fréquences dépas 2disponibles à l’URL fimi cs helsinki fi data 3Il s’agit de versions optimisées disponibles à l’URL adrem ua ac be ~goethals RNTI E 10 fimi cs helsinki fi data adrem ua ac be ~goethals J É SYMPHOR al sant 45% Toutefois les performances du FIA sont dépendantes des données indexées En effet cette structure est d’autant plus avantageuse que les itemsets fréquents sont grands En contre partie lorsque les itemsets fréquents sont majoritairement des singletons ce qui est le cas pour de très faibles fréquences le FIA tend à ressembler à un arbre lexicographique et l’algorithme de construction devient inadapté au regard des méthodes classiques de construction de tels arbres Le FIA est une structure d’autant plus efficace que les données sont denses en informa tions à extraire Sur les Figures 6 et 7 nous illustrons les résultats obtenus avec l’algorithme du FIA incrémental en représentant le temps pris et la mémoire requise en fonction de l’insertion de nouveaux batches nombre constant de transactions pour T10I4D100K Le temps pris et la mémoire consommée demeurent stables Cela montre l’applicabilité de l’algorithme du FIA incrémental dans le cas des flots de données 6 Conclusion Dans cet article nous apportons une contribution originale en élaborant un nouvel au tomate le FIA qui permet de traiter de façon efficace la problématique de l’extraction des itemsets fréquents dans les flots de données À notre connaissance les automates en tant que structure de données n’ont pas du tout été utilisés pour aborder cette question Nous montrons que le FIA est une structure très compacte et informative car plusieurs itemsets fréquents ayant la même valeur de support sont reconnus à un même état Par ailleurs la structure indexe di rectement tous les itemsets fréquents sans qu’il soit nécessaire de lui associer un tableau pour finalement obtenir les résultats Le FIA présente également des propriétés incrémentales qui fa cilitent grandement la mise à jour dans le cas des flots de données avec une granularité très fine par batch Utilisé dans le cadre d’une approche prédictive le FIA permet d’indexer les itemsets véritablement θ fréquents du flot en maximisant le rappel et en fournissant à tout moment une information sur leur pertinence statistique avec la P valeur Ces deux avantages permettent notamment de construire le FIA par incrément à partir d’une base initiale vide L’algorithme développé pour mettre à jour le FIA ne requiert qu’un seul passage sur les données qui sont prises en compte par batch itemset par itemset et pour chaque itemset item par item Lors de l’acquisition de nouveaux batches la connaissance du flot augmentant il est possible de mettre à jour la bordure supérieure Celle ci tend à diminuer la valeur de ε tends vers 0 donc θ′ tends vers θ au fur et à mesure des mises à jour Il devient donc possible de construire le F̂IAσ à partir de l’automate vide est les premiers résultats obtenus non présentés dans cet article faute de place essentiellement montrent clairement la robustesse de notre approche Ceci est également étayé par les expérimentations présentées avec une analyse en temps de calcul et en mémoire consommée qui donnent des résultats satisfaisants et qui prouvent l’applicabilité et le passage à l’échelle de l’algorithme Notre contribution ouvre donc une voie prometteuse avec le FIA quant à l’utilisation de nouvelles structures de données de type automate dans les problématiques d’extraction de motifs fréquents dans les flots de données Références Agrawal R et R Srikant 1994 Fast Algorithms for Mining Association Rules in Large Databases In Proc 20th Int Conf on Very Large Data Bases VLDB pp 487–499 RNTI E 11 Automate des Itemsets Fréquents le FIA Chang J H et W S Lee 2004a A Sliding Window Method for Finding Recently Frequent Itemsets over Online Data Streams Journ of Inf Sc and Eng 20 4 753–762 Chang J H et W S Lee 2004b Decaying Obsolete Information in Finding Recent Frequent Itemsets over Data Streams IEICE Trans on Inform and Syst 87 6 1588–1592 Denise A M Régnier et M Vandenbogaert 2001 Assessing the Statistical Significance of Overrepresented Oligonucleotides In Proc 1st Int Workshop on Alg in BioInf WABI Volume 2149 of LNCS pp 85–97 Giannella C J Han J Pei X Yan et P S Yu 2004 Next Generation Challenges and Future Directions Chapter Mining Frequent Patterns in Data Streams at Multiple Time Granulari ties pp 105–124 AAAI Press Han J J Pei et Y Yin 2000 Mining Frequent Patterns Without Candidate Generation SIGMOD Records 29 2 1–12 Hopcroft J E et J D Ullman 1990 Introduction to Automata Theory Languages and Computation Addison Wesley Longman Publishing Co Inc Hoshino H A Shinohara M Takeda et S Arikawa 2000 Online Construction of Subse quence Automata for Multiple Texts In Proc 7th Int Symp on String Processing Informa tion Retrieval SPIRE pp 146–152 Laur P A R Nock J É Symphor et P Poncelet 2007 Mining Evolving Data Streams for Frequent Patterns Pattern Recognition 40 2 492–503 Li H F S Y Lee et M K Shan 2004 An Efficient Algorithm for Mining Frequent Item sets over the Entire History of Data Streams In Proc 1st Int Workshop on Knowledge Discovery in Data Streams pp 20–24 Manku G S et R Motwani 2002 Approximate Frequency Counts over Data Streams In Proc 28th Int Conf on Very Large Data Bases VLDB pp 346–357 Masséglia F P Poncelet et M Teisseire 2003 Incremental Mining of Sequential Patterns in Large Databases Data Knowledge Engineering 46 1 97–121 Symphor J É et P A Laur 2006 Bordures statistiques pour la fouille incrémentale de données dans les data streams In Proc 6th EGC Volume E 6 2 of RNTI pp 615–626 Troníček Z 2002 Common Subsequence Automaton In Proc 7th Int Conf Impl Appl Automata Number 2608 in LNCS pp 270–275 Vapnik V N 1998 Statistical Learning Theory John WILEY – Interscience Summary We present in this paper a new automaton the FIA which allows to mine efficiently all frequent itemsets in a data stream The FIA is a summary and very informative data struc ture with incremental properties that make the update processing easier with fine granularity Our incremental algorithm for updating the FIA only needs one scan over the data which are considered per batch itemset per itemset and for each itemset item per item Used within the framework of a predictive approach and through the statistical border the FIA recognizes the truly frequent itemsets of the stream by maximizing the recall and by providing for each information on the statistical relevance of the indexed itemsets their P value RNTI E 12 Introduction Problématique Travaux antérieurs Notre Approche Rappels sur la théorie des automates L'automate des itemsets fréquents le FIA Le FIA appliqué aux flots de données Mise à jour incrémentale du FIA Intégration des bordures statistiques dans le FIA Expérimentations Conclusion 