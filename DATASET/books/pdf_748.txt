 actes_non_num\351rotes pdf Détection d’intrusions dans un environnement collaboratif sécurisé Nischal Verma François Trousset Pascal Poncelet Florent Masseglia IIT Guwahati Assam India nischaliit gmail com LGI2P Ecole des Mines d’Alès Parc Scientifique G Besse 30035 Nîmes France trousset ema fr LIRMM UMR CNRS 5506 161 Rue Ada 34392 Montpellier Cedex 5 France poncelet lirmm fr INRIA Sophia Antipolis route des Lucioles BP 93 06902 Sophia Antipolis France florent masseglia sophia inria fr Résumé Pour pallier le problème des attaques sur les réseaux de nouvelles ap proches de détection d’anomalies ou d’abus ont été proposées ces dernières an nées et utilisent des signatures d’attaques pour comparer une nouvelle requête et ainsi déterminer s’il s’agit d’une attaque ou pas Cependant ces systèmes sont mis à défaut quand la requête n’existe pas dans la base de signature Généra lement ce problème est résolu via une expertise humaine afin de mettre à jour la base de signatures Toutefois il arrive fréquemment qu’une attaque ait déjà été détectée dans une autre organisation et il serait utile de pouvoir bénéficier de cette connaissance pour enrichir la base de signatures mais cette information est difficile à obtenir car les organisations ne souhaitent pas forcément indiquer les attaques qui ont eu lieu sur le site Dans cet article nous proposons une nouvelle approche de détection d’intrusion dans un environnement collaboratif sécurisé Notre approche permet de considérer toute signature décrite sous la forme d’ex pressions régulières et de garantir qu’aucune information n’est divulguée sur le contenu des différents sites 1 Introduction Le déploiement des ordinateurs et des réseaux a considérablement augmenté les risques causés par les attaques sur les systèmes informatiques qui deviennent un réel problème pour les entreprises et les organisations Alors qu’auparavant de nombreuses attaques se focalisaient sur les serveurs Web car ils étaient souvent mal configurés ou mal maintenus les attaques les plus récentes profitent des failles de sécurité des services ou applications Web qui sont plus vulnérables Heady et al 1990 Graham 2001 Escamilla 1998 Pour pallier ce problème de nouvelles approches appelées Systèmes de Détection d’Intrusions SDI ont fait leur ap parition Installés sur les réseaux ils ont pour objectif d’analyser le trafic de requêtes et de détecter des comportements malveillants e g Prelude IDS Snort Ils peuvent être classés en deux grandes catégories e g McHugh et al 2000 Proctor 2001 les systèmes de détec tion d’anomalies qui cherchent à détecter les attaques et les systèmes de détection d’abus qui Détection d’intrusion collaborative et sécurisée après avoir spécifié le comportement normal sur un site vont rechercher les comportements non reconnus Dans le cadre de cet article nous nous intéressons plus particulièrement aux systèmes de type détection d’anomalies Leur principe général est le suivant une comparai son est effectuée entre une nouvelle requête et les signatures d’attaques représentées sous la forme d’expressions régulières Par exemple une attaque qui cherche à récupérer le fichier des mots de passes d’une machine e g abc de fg etc passwd pourra être détectée via l’expression régulière suivante [ˆ ]* * etc passwd Traditionnellement ces signatures sont obtenues à partir d’algorithmes d’apprentissage ou bien via des sites spécialisés e g OSVDB Database 2008 Même si ces systèmes sont largement utilisés aujourd’hui le pro blème essentiel est qu’ils ne savent pas gérer des attaques qui n’appartiennent pas à la base de signatures Ainsi lorsqu’une requête n’est pas reconnue par l’IDS une alarme est déclenchée afin de requérir une expertise extérieure Récemment de nouvelles approches de détection appelées Collaborative Intrusion Detec tion Systems CIDS e g Cuppens et Miege 2005 Zhou et al 2007 Janakiraman et al 2003 Locasto et al 2005 Zhang et Parashar 2006 ont été proposées En comparaison avec les IDS isolés ces CIDS offrent la possibilité d’améliorer considérablement les temps de réactions et l’efficacité des détections en partageant entre les IDS répartis sur une ou plu sieurs organisations les informations sur les attaques Le principe général de ces approches est d’échanger via des réseaux Pair à Pair des informations survenues sur les différents IDS Cependant traditionnellement les informations échangées se limitent aux adresses IP sources d’attaques e g Cuppens et Miege 2005 Janakiraman et al 2003 Locasto et al 2005 et considèrent que les données peuvent librement être échangées parmi les pairs Cette dernière contrainte est très forte les entreprises pour des raisons de confidentialités ne souhaitent pas dire qu’elles ont été attaquées et donc ne veulent pas donner d’information sur les signatures utilisées Dans cet article nous proposons une approche de détection collaborative sécurisée appelée SREXM Secure Regular Expression Mapping qui garantit que les données privées ne seront pas divulguées Via notre approche les différentes expressions régulières contenues dans les différents sites collaboratifs peuvent être utilisées sans qu’aucune information ne soit divulguée à l’extérieur Les sites collaboratifs ont toute liberté pour travailler avec des signa tures d’attaques ou de non attaques Ainsi lorsqu’une nouvelle requête intervient la réponse obtenue sera simplement qu’il s’agit d’une attaque d’une non attaque ou qu’il n’est pas pos sible de répondre i e les bases de données n’ont pas d’information pour permettre de décider A notre connaissance il existe très peu de travaux qui ont abordé la problématique de la sécu rité dans un tel environnement collaboratif Seuls les travaux de Wang et al 2005 Locasto et al 2005 ont considéré l’aspect à la fois collaboratif et sécurisé Dans ce contexte la sé curisation concerne principalement les informations sur les adresses IP et sur les ports utilisés et utilise des filtres de Bloom pour les échanges Notre problématique est différente dans la mesure où nous souhaitons échanger des données plus complexes que les adresses IP et les ports utilisées des expressions régulières L’article est organisé de la manière suivante Dans la section 2 nous présentons la problé matique Un aperçu général de l’approche est proposé dans la section 3 Les différents algo rithmes utilisés sont décrits dans la section 4 La section 5 conclut en présentant différentes perspectives N Verma et al 2 Problématique Soient DB une base de données telles que DB = DB1 ⋃ DB2 ⋃ DBD Chaque base de données DBi correspond à un tuple < id Sexp > où id correspond à l’identifiant de la base et Sexp est un ensemble d’expressions régulières Toute expression régulière expi ∈ Sexp est exprimée sous la forme d’un automate déterministe e g Hopcroft et al 2000 représenté par le tuple aexpi =< Etat T rans Init F inal > Dans aexpi Etat représente l’ensemble des états de l’automate Init l’état initial de l’automate Final l’ensemble des états finaux et Trans l’ensemble des transitions de l’automate Chaque transition est un quadruplet Einitial Condition Efinal Longueur signifiant que si l’automate est dans l’état Einitial et que la condition Condition est vérifiée alors l’automate passe dans l’état Efinal et qu’un déplace ment de Longueur est effectué dans la chaîne à filtrer Dans notre approche nous associons également une valeur entière à chaque état final Cette valeur spécifie si c’est une attaque ou non booléen 0 ou 1 mais peut aussi fournir le type de l’attaque entier Exemple 1 Considérons l’expression régulière suivante [ˆ ]* * etc passwd L’automate associé est décrit dans la figure 1 Le tableau de gauche représente la matrice de transition et celui de droite les différentes conditions à respecter pour passer d’un état initial à un état final Par exemple pour passer de l’état E6 à l’état final la condition à vérifier est que la portion courante de la chaîne de longueur 6 soit "passwd" I cond1 E1 1 E1 cond2 I 2 E1 cond3 E2 1 E1 cond4 E3 1 E2 cond5 E2 1 E2 cond6 I 3 E3 cond7 E2 1 E3 cond8 E4 1 E4 cond9 E2 1 E4 cond10 E5 1 E5 cond11 E2 1 E5 cond12 E6 1 E6 cond13 I 2 E6 cond14 F 6 cond1 cond2 cond3 [ˆ e] cond4 e cond5 [ˆ ] cond6 cond7 [ˆ t] cond8 t cond9 [ˆ c] cond10 t cond11 [ˆ ] cond12 cond13 cond14 passwd FIG 1 – L’automate associé à l’expression régulière exp Définition 1 Soient DB une base de données telle que DB = DB1 ⋃ DB2 ⋃ DBD et une requête R la problématique de la recherche d’expressions régulières dans un environne ment collaboratif sécurisé consiste à vérifier s’il existe une expression régulière exp contenue dans DB pour laquelle matching exp R = TRUE tout en garantissant qu’aucune base ne fournisse directement d’information sur son contenu Détection d’intrusion collaborative et sécurisée DB1 DBD 4 5 2 4 2 5 3 7 7 2 13 6 6 1 Non−Colluding Site Non−Colluding Site NC1 NC Processing Site PS 2 Site Control Site CTRL FIG 2 – L’architecture générale de SREXM 3 L’approche SREXM Dans cette section nous proposons un survol de l’architecture sécurisée SREXM Secure Regular Expression Mapping définie pour pouvoir répondre à la problématique de la préser vation de la vie privée dans le cas d’un environnement de détection collaboratif Inspirée des travaux de Kantarcioglu et Vaidya 2002 cette architecture offre l’avantage de pouvoir réali ser les différentes opérations tout en garantissant qu’aucune des parties ne puisse avoir accès aux données privées des bases d’origine Outre le site S chargé de fournir la requête à tester l’architecture nécessite quatre sites non collaboratifs et semi honnêtes Goldreich 2000 ils suivent le protocole correctement mais sont libres d’utiliser l’information qu’ils ont collec tée pendant l’exécution du protocole Ces sites indépendants collectent stockent et évaluent l’information de manière sécurisée Les différentes fonctions de ces sites sont les suivantes – Le site de contrôle Control Site CTRL CTRL est utilisé pour ordonnancer les différentes opérations de comparaisons de l’expression régulière Pour cela il interagit avec deux sites non collaboratifs NC1 et NC2 – Les sites Non Collaboratifs Non Colluding Sites NC1 et NC2 Ces sites symé triques collectent les données bruitées de toutes les bases ainsi que la requête bruitée à tester Sous le contrôle de CTRL ils interagissent avec PS et réalisent une série d’opé rations de manière sécurisée sans pouvoir inférer ni des résultats intermédiaires ni du résultat final qui est retourné au site S – Le site de calcul Processing Site PS Ce site est utilisé à la fois par NC1 et NC2 pour calculer de manière sécurisée les différentes fonctions et opérations De manière similaire aux sites NC1 et NC2 PS ne peut pas déduire les résultats intermédiaires ou finaux des données qu’il traite Les échanges de données entre les différents sites utilisent une fonction sécurisée SENDS + V | − V ′ qui permet d’envoyer un vecteur de bits V = + V ⊕ − V à NC1 et NC2 Elle est définie de manière à envoyer + V à NC1 et − V à NC2 ou inversement Pour effectuer l’envoi N Verma et al sécurisé nous utilisons un nombre aléatoire R tel que + V = R et − V = V ⊕ R Cette méthode est par exemple utilisée pour envoyer des données des différentes bases DBi ou pour en voyer la requête du site S Ainsi le processus décrit figure 2 débute de la manière suivante Tout d’abord le site S envoie sa requête à NC1 et NC2 en utilisant la fonction SEND S C f flèche numérotée 1 dans la figure 2 De manière plus précise la requête R est considérée sous sa forme booléenne Nous générons un vecteur aléatoire AR ayant la même taille que la requête R et nous calculons un nouveau vecteur ZR = AR ⊕ R ZR est alors envoyé à NC1 et AR à NC2 ou vice versa Chaque base de données DBi décompose la matrice de transition en trois tableaux le premier correspond aux transitions le second au conditions et le troisième aux longueurs des déplacement Les indices de ces tableaux sont triés aléatoire ment de manière à encoder la matrice Les bases de données DBi envoient d’abord à CTRL la matrice de transition transformée puis en utilisant SENDS envoient à NC1 et NC2 les conditions associées à la matrice ainsi que le tableau des longueurs dans l’ordre des indices fournis à CTRL C f flèche numérotée 2 A partir de ce moment l’évaluation de la requête est effectuée sous le contrôle de CTRL Ce dernier demande à NC1 et NC2 via la fonction NCOMPARES d’évaluer la condition d’indice i dans leur tableau de condition C f flèche numérotée 3 A ce moment NC1 dispose d’une partie de la requête à tester notée + R d’une partie des conditions notée + STRi ainsi que la position courante dans R De la même manière NC2 contient − R − STRi et la position dans la requête pos Il ne reste donc plus pour NC1 et NC2 qu’à extraire dans la requête la sous chaîne commençant à la position pos et dont la lon gueur est égale à celle de la condition i e + STRi ou − STRi L’étape suivante consiste à comparer les deux chaînes de manière sécurisée en envoyant à PS les différentes parties via la fonction NCMPS C f flèche numérotée 4 Le résultat des comparaisons est réparti entre NC1 et NC2 et est retourné au contrôleur de manière sécurisé C f flèches 5 et 6 Le processus est répété sous le contrôle de CTRL tant que l’automate n’est pas terminé De manière à mainte nir le déplacement de la position dans la requête lorsqu’une condition est vérifiée i e les deux chaînes sont semblables CTRL utilise une opération sécurisée INCRS dont l’objectif est de décaler la position en fonction de la longueur associée à la transition Pour cela il indique à NC1 et NC2 l’indice correspondant dans le tableau des longueurs et ces derniers mettent à jour la valeur de pos Lorsque l’automate passe dans un état final ou qu’il ne reconnaît pas la séquence CTRL agrège les différents résultats attaque non attaque ou inconnu via une fonction sécurisée AGGREGATES et répartit le résultat final entre NC1 et NC2 Tant qu’il existe des données à traiter ces derniers conservent le résultat agrégé pour les transmettre au site S en fin de traitement 4 Les différents algorithmes sécurisés Dans cette section nous présentons les différents algorithmes utilisés dans l’approche SREXM De manière à simplifier l’écriture des algorithmes nous considérons les notations suivantes Soit + X| − X ← hS + Y1 + Yn| − Y1 − Yn un calcul triparti de n’importe quelle fonction h S entre NC1 NC2 et PS où NC1 possède une partie des entrées + Y1 + Yn et obtient une partie du résultat + X et de manière similaire NC2 possède une partie des entrées − Y1 − Yn et obtient une partie des résultats − X à la fin du processus Le résultat final est obtenu en appliquant l’opérateur Détection d’intrusion collaborative et sécurisée binaire XOR ⊕ entre + X et − X Cependant cela n’implique pas que NC1 envoie directement + Y1 + Yn à PS et reçoit le résultat + X de PS En fait NC1 transforme ses entrées + Y1 + Yn en + Y ′1 + Y ′ n via l’addition d’un bruit aléatoire uniforme et les envoie de manière sécurisée à PS De manière symétrique NC2 envoie aussi ses entrées bruitées à PS A la fin du calcul les deux sites reçoivent le résultat partagé et bruité + X′ et − X′ de PS Ce résultat intermédiaire pourra par la suite être utilisé comme entrée pour d’autres calculs De la même manière nous utilisons 1 gS + x + y| − x − y ⇔ gS + x| − x + y| − y 2 Si hS est une fonction à deux arguments alors hS + X1 · · · + Xn| − X1 · · · − Xn correspond à hS hS · · ·hS hS + X1 + X2| − X1 − X2 + X3| − X3 · · · + Xn| − Xn 4 1 L’algorithme NCOMPARES Algorithme 1 Algorithme NCOMPARES Data i|i L’indice de la condition à tester qui est envoyé à NC1 et NC2 par CTRL Result + b| − b deux booléens tels que b = + b ⊕ − b soit faux si STRi se trouve à la position courante de la requête examinée et vrai sinon 1 NC1 calcule Len1 = length + STRi NC2 calcule Len2 = length − STRi Par définition Len1 = Len2 2 If pos + Len1 > length + R || pos + Len2 > length − R then return + b| − b = 1|0 3 NC1 calcule + S = + Rpos · · · + Rpos+Len1−1 4 NC2 calcule − S = − Rpos · · · − Rpos+Len2−1 5 avec PS NC1 et NC2 calculent + b| − b = NCMPS + S| − S L’évaluation de la condition NCOMPARES Str|Str C f Algorithme 1 d’une transi tion est commandée par le contrôleur CTRL Il envoie à NC1 et NC2 l’indice i d’une chaîne dans le tableau des conditions dont NC1 ne connaît que la partie + STRi et NC2 l’autre partie − STRi de telle manière que la chaîne réelle soit STRi = + STRi ⊕ − STR1 Chacun des sites NC1 et NC2 ne connaît également que sa partie de la requête à tester + R| − R ainsi que la position courante dans cette requête pos Après avoir extrait la partie de la requête R commençant à la position pos et ayant même longueur que STRi l’opération de comparaison est effectuée via NCMPS La fonction NCMPS + S1 + S2| − S1 − S2 → + b| − b C f section 4 4 permet de com parer des séquences de bits de même longueur S1 = + S1 ⊕ − S1 et S2 = + S2 ⊕ − S2 et retourne une valeur booléenne b = + b ⊕ − b telle que b est faux si S1 et S2 sont identiques et vrai dans le cas contraire Le résultat final est retourné à CTRL N Verma et al Complexité La complexité de l’algorithme NCOMPARES est la même que celle de NCMPS C f section 4 4 COMPARES ne permet pas à NC1 ou NC2 de connaître si le résultat de la comparaison est vrai ou faux Ils ne peuvent normalement déduire que la longueur de la requête qui a été comparée avec succès la valeur de pos Cependant même s’ils arrivaient à déduire la liste des indices des chaînes qui ont effectivement filtré la requête étant donné qu’ils ne connaissent que des valeurs aléatoire contenues dans STR ils ne peuvent en déduire au pire qu’une séquence aléatoire de longueur pos Pour autant ils ne peuvent pas en déduire si le filtrage a réussi ou non ni connaître la valeur associée à l’état final dans le cas où le filtrage a réussi Au niveau du contrôleur CTRL aucune information sur la longueur de la partie filtrée ou sur la valeur de la requête ne peut être déduite En effet CTRL n’a aucun accès aux valeurs requête ou STR il ne connaît que des indices et il en est de même pour les déplacement La seule information qu’il connaît est le parcours effectué dans l’automate 4 2 L’algorithme INCRS La requête à tester est répartie dans NC1 et NC2 de manière sécurisée La position du début d’une comparaison est connue par NC1 et NC2 La modification de cette position est commandée par CTRL via l’algorithme INCRS len|len 1 Lors de l’envoi de l’automate à CTRL et des données à NC1 et NC2 ces derniers reçoivent également un tableau trié de manière aléatoire indiquant les longueurs des déplacements à effectuer L’objectif de ce tri est d’interdire qu’il puisse y avoir une correspondance directe entre les indices des conditions et des longueurs L’algorithme INCRS ne fait qu’indiquer quel est l’indice du tableau à utiliser par NC1 et NC2 pour mettre à jour la position pos de la requête en cours d’analyse Lorsque CTRL commande une incrémentation rien ne permet à NC1 ou NC2 de connaître la condi tion qui a déclenché le déplacement car CTRL peut très bien faire faire des calculs inutiles Du coté de CTRL aucune information sur la longueur ne peut être déduite car il ne connaît que des indices sur le tableau des longueurs 4 3 L’algorithme AGGREGATES L’aggrégation des résultats consiste à conserver de manière sécurisée le dernier résul tat obtenu par CTRL lorsqu’un automate a reconnu la requête L’objectif est qu’au travers d’AGGREGATES C f Algorithme 2 ni NC1 ni NC2 ne puissent savoir si l’automate a filtré la requête ou non Pour cela CTRL positionne un bit à 1 si la requête a été filtrée et à 0 autrement En fonction de la valeur de ce bit l’information qui sera stockée dans un accumulateur entre NC1 et NC2 est soit la valeur de l’état final Wf soit un vecteur aléa toire Pour cela nous utilisons la fonction ∨S + S1 + S2| − S1 − S2 → + V | − V qui réalise un OU bit à bit sur les séquences de bits S1 et S2 de même longueur et retourne la séquence V ainsi que ∧S + S1 + S2| − S1 − S2 → + V | − V qui réalise un AND bit à bit sur les séquences de bits S1 et S2 de même longueur et retourne la séquence V A l’issu du processus SREXM NC1 et NC2 envoient les valeurs stockées dans l’accumulateur à S Ce dernier n’a plus qu’à effectuer un 1Par manque de place nous ne décrivons pas le contenu de cet algorithme Détection d’intrusion collaborative et sécurisée XOR entre les deux valeurs retournées pour obtenir le résultat Pour chaque expression régulière automate les valeurs Vf associées aux états finaux des bases sont encodées à l’aide de deux nombres aléatoires R1 et R2 en calculant Wf = Vf ⊕ R1 ⊕ R2 CTRL connaît les Wf NC1 connaît R1 et NC2 connaît R2 On considère que la longueur des Wf est identique pour toutes les bases Algorithme 2 Algorithme AGGREGATES Data Y = + Y ⊕ − Y de longueur n + 1 dont le bit zéro correspond au bit positionné par CTRL + A et − A sont les valeurs d’agrégation conservées respectivement par NC1 et NC2 n + 1 la longueur de A 1 NC1 calcule + Z = + Y ⊕ 0R1 NC2 calcule − Z = − Y ⊕ 0R2 2 ∀k ∈ 1 n NC1 NC2 PS effectuent + Bk| − Bk = ∧S ∨S + Z0 + Ak| − Z0 − Ak ∨S ¬ + Z0 + Zk| − Z0 − Zk 3 NC1 NC2 PS calculent + B0| − B0 = ∨S + Z0 + A0| − Z0 − A0 4 NC1 et NC2 effectuent respectivement + A = + B et − A = − B Propriété 1 L’algorithme AGGREGATES interdit à NC1 ou NC2 de connaître les infor mations stockées dans l’accumulateur De la même manière il n’est pas possible de savoir si la valeur de l’accumulateur a changé ou pas Preuve Les données + Y | − Y reçues par NC1 et NC2 sont bruitées par CTRL de manière aléatoire et il est donc impossible de connaître la valeur de Y ou celle de Y0 i e le premier bit indiquant si l’automate a atteint l’état final ou non Les opérateur ∨S et ∧S retournent des valeur bruitées aléatoirement à NC1 et NC2 ce qui signifie que du point de vue de NC1 respectivement NC2 la séquence obtenue dans + B respectivement − B est alétoire et donc in dépendante des valeurs de + Y et + A respectivement − Y et − A En particulier même si NC1 et NC2 connaissent la valeur initiale de A 0 au début du processus il leur est impossible de déduire si cette valeur a été changée ou non par AGGREGATES Complexité La fonction ∨S est utilisée 2n+1 fois et ∧S n fois sur 1 bit En reprenant la com pexité des opérateurs ∨S et ∧S C f section 4 4 AGGREGATES NC1 et NC2 effectuent donc 34n+12 opérations binaires calculent 6n+2 bit aléatoires envoient 12n+4 bits et reçoivent 10n+4 bits données comprises De son côté PS effectue 12n+4 opérations binaires calcule 3n+1 bits aléatoires reçoit 12n+4 bits 6n+2 pour NC1 et 6n+2 pour NC2 et envoi 6n+2 bits 3n+1 à NC1 et 3n+1 pour NC2 Ceci est bien sûr à rapporter à la longueur des entrées n+1 bits Remarques Les deux mécanismes bufferisation des données envoyées par les bases et agré gation des résultats permettent de réaliser l’anonymisation des bases En effet même si le client peut détecter quelles sont les bases qui ont envoyé leurs données à SREXM il ne peut pas en déduire quelle est celle qui a fourni le résultat final Le retour de la valeur agrégée des N Verma et al résultats peut être effectué dès qu’une expression est validée Cependant dans ce cas NC1 et NC2 peuvent savoir quelle est la base qui a fourni la réponse Pour que l’anonymisation soit efficace il est donc nécessaire d’attendre par exemple que toutes les expressions de toutes les bases aient été considérées Cette approche n’est malheureusement pas efficace car trop coûteuse en temps Pour minimiser ce coût il est bien sûr possible de retourner des valeurs intermédiaires au client chaque fois que n résultats ont été agrégés ce qui minimise le coût à n 2 En fait les deux mécanismes d’anonymisation ont des coûts différents la bufferisation in troduit essentiellement des coûts en espace alors que l’agrégation introduit des coûts en temps de calcul Il est bien sûr possible de faire varier ces deux paramètres pour adapter le processus d’anonymisation en fonction des besoins et des coûts supportables Algorithme 3 L’algorithme ∧S Data + X + Y | − X − Y sont des bits tels que + X et + Y appartiennent à NC1 − X et − Y appartiennent à NC2 Result AR|BR sont tels que AR ⊕ BR = + X ⊕ − X ∧ + Y ⊕ − Y 1 NC1 et NC2 génèrent et échangent quatre nombres aléatoires RA R ′ A RB et R ′ B tels que + X ′ = + X ⊕ RA + Y ′ = + Y ⊕ R′A − X ′ = − X ⊕ RB et − Y ′ = − Y ⊕ R′B 2 NC1 envoie + X ′ et + Y ′ à PS 3 NC2 envoie − X ′ et − Y ′ à PS 4 PS calcule + C = + X ′ ∧ − Y ′ et − C = − X ′ ∧ + Y ′ ainsi qu’un nombre aléatoire RPS 5 PS envoie A′PS = + C ⊕ RPS à NC1 et B ′ PS = − C ⊕ RPS à NC2 6 NC1 calcule A R = A′PS ⊕ + X ∧ R′B ⊕ + Y ∧ RB ⊕ + X ∧ + Y ⊕ RB ∧ R′A 7 NC2 calcule B R = B′PS ⊕ − X ∧ R′A ⊕ − Y ∧ RA ⊕ − X ∧ − Y ⊕ RA ∧ R′B 4 4 Les algorithmes NCMP S ∧ S et ∨ S Dans cette section nous définissons trois algorithmes permettant de réaliser de manière sécurisée les opérations de comparaisons de chaînes Le principe fondamental de ces algo rithmes est d’ajouter un bruit aléatoire uniforme aux données qui pourra par la suite être sup primé du résultat final Le protocole débute avec NC1 et NC2 qui modifient leurs données en les XOR isant avec des valeurs aléatoires NC1 et NC2 échangent ces valeurs Les don nées modifiées sont alors envoyées e g pour NC2 − X ′ = − X ⊕ RB et − Y ′ = − Y ⊕ R′B à PS qui peut alors calculer de manière sécurisée une opération ∧ ou ∨ En fait PS travaille sur des données bruitées et calcule + C = + X ′ ∧ − Y ′ et − C = − X ′ ∧ + Y ′ Ce dernier ajoute également un bruit aléatoire aux résultats intermédiaires afin d’éviter que NC1 et NC2 ne disposent du résultat final A la fin de l’application des algorithmes les sites non collaboratifs peuvent alors calculer le résultat final en supprimant le bruit qu’ils avaient ajouté Par exemple pour NC1 l’opération suivante AR = A′PS ⊕ + X ∧ R′B ⊕ + Y ∧ RB ⊕ + X ∧ + Y ⊕ RB ∧ R′A peut Détection d’intrusion collaborative et sécurisée être réalisée de manière sécurisée dans la mesure où il connaît ses propres éléments + X + Y et R′A et les nombres aléatoires de NC2 R ′ B et RB Le résultat final est alors A R ⊕ BR = A′PS ⊕ + X ∧ R′B ⊕ + Y ∧ RB ⊕ + X ∧ + Y ⊕ RB ∧ R′A ⊕ B′PS ⊕ − X ∧ R′A ⊕ − Y ∧ RA ⊕ − X ∧ − Y ⊕ RA ∧ R′B où A ′ PS ⊕ B′PS = + X ∧ R′B ⊕ + Y ∧ RB ⊕ − X ∧ R′A ⊕ − Y ∧ RA ⊕ + X ∧ + Y ⊕ − X ∧ − Y ⊕ RA ∧ R′B ⊕ RB ∧ R′A ⊕ RPS ⊕ RPS Grâce à la propriété de l’opérateur XOR R ⊕ R = 0 nous obtenons le résultat désiré AR ⊕ BR = + X ∧ + Y ⊕ + X ∧ − Y ⊕ − X ∧ + Y ⊕ − X ∧ − Y Toutefois cette opération n’est jamais réa lisée par les sites non collaboratifs et le résultat final est partagé entre NC1 et NC2 Algorithme 4 L’algorithme ∨S Data + X + Y | − X − Y sont des bits tels que + X et + Y appartiennent à NC1 − X et − Y appartiennent à NC2 Result AR|BR sont tels que AR ⊕ BR = + X ⊕ − X ∨ + Y ⊕ − Y 1 5 Les 5 premières étapes sont similaires à celle de ∧S 6 NC1 calcule A R = A′PS ⊕ + X ∧ R′B ⊕ + Y ∧ RB ⊕ + X ⊕ + Y ⊕ + X ∧ + Y ⊕ RB ∧ R′A 7 NC2 calcule B R = B′PS ⊕ − X ∧ R′A ⊕ − Y ∧ RA ⊕ − X ⊕ − Y ⊕ − X ∧ − Y ⊕ RA ∧ R′B Propriété 2 L’algorithme ∧S resp ∨S interdit à NC1 d’apprendre des données privées de NC2 et vice versa En outre la troisième partie PS ne peut rien apprendre sur leurs entrées privées Preuve A partir de l’algorithme B′PS est tout ce que NC2 peut apprendre sur les données privées de NC1 Grâce au bruit ajouté RPS NC2 ne peut pas trouver les valeurs de + X ou + Y Etant donné que les rôles de NC1 et NC2 sont interchangeables la même argumentation peut s’appliquer à NC1 qui ne peut pas apprendre les données privées − X ou − Y de NC2 En outre en bruitant leurs entrées NC1 et NC2 garantissent qu’aucune information privée n’est transmise à PS Enfin grâce à l’étape de prétraitement PS ne dispose que d’un flot de valeurs qu’il ne peut pas distinguer de vraies valeurs ou de valeurs aléatoires Complexité Pour l’opérateur ∧S dix opérations doivent être réalisées 6 ⊕ et 4 ∧ Etant donné que deux opérations XOR sont réalisées dans l’algorithme ∨S nous avons au total 12 opérations Pour chaque ∧S NC1 et NC2 échangent 2 × 2 bits A partir de NC1 ou NC2 2× 1 bits sont envoyés à PS et un bit retourné En outre NC1 et NC2 calculent tous les deux 2 bits aléatoires et 1 bit aléatoire est généré par PS La fonction NCMPS compare deux vecteurs de bits à l’aide de la fonction sécurisée ∨S Le résultat de NCMPS donne 2 bits L’un est envoyé à NC1 et l’autre est envoyé à NC2 Un XOR de ces bits vaut 0 si les vecteurs sont similaires et 1 autrement N Verma et al Algorithme 5 L’algorithme NCMPS Data Une partie de V et de W est stockée dans NC1 et l’autre partie est dans NC2 Result + R| − R est tel que + R ⊕ − R = 0 si V = W sinon 1 1 NC1 calcule X ← + V ⊕ + W où X = X1 X2 · · · Xl et l est la longueur du vecteur V ou W 2 NC2 calcule Y ← − V ⊕ − W où Y = Y1 Y2 · · · Yl 3 + R| − R ← ∨S X1 X2 · · · Xl|Y1 Y2 · · · Yl Complexité Si l est la longueur des vecteurs comparés alors CMPS effectue l opérations ⊕ et utilise l − 1 l’opération ∨S NC1 et NC2 effectuent donc 13l − 12 opérations binaires calculent 2l − 2 bits aléatoires reçoivent 4l − 3 bits donnée comprise et envoient 5l − 4 bits résultat compris De son côté PS effectue 4l − 4 opérations binaires calcule l − 1 bits aléatoires reçoit 4l − 4 bits et envoie 2l − 2 bits Propriété 3 NC1 NC2 et PS n’ont aucune connaissance sur la valeur des données compa rées ni sur le résultat de la comparaison Preuve Les données reçues par NC1 et NC2 sont bruitées au moment de l’envoi par des vecteurs aléatoires De la même manière toutes les valeurs retournées par ∨S sont elles aussi bruitées avec des bits générés aléatoirement NC1 et NC2 ne voient donc que des valeurs aléatoires Ils ne peuvent donc rien déduire sur les données et les résultats réels du calcul Si PS conserve les résultats intermédiaires il peut déduire une partie des nombres aléatoires qui ont été utiliśés pour réencoder ses résultats envoyés à NC1 et NC2 Cependant cela ne lui donne aucune information sur les données réelles 5 Conclusion Dans cet article nous avons proposé une nouvelle approche de détection d’intrusion sécu risée collaborative Via notre approche une requête peut utiliser les différentes connaissances des bases de données pour savoir si elle correspond à une attaque ou non Nous avons prouvé que notre architecture garantissait qu’il n’était pas possible de connaître la base qui a fourni l’information et que tous les composants de l’architecture n’avaient pas la possibilité d’inférer de connaissances sur ces bases et sur la requête Via notre approche il est également possible de déduire le type d’attaque qui a eu lieu si celui ci est précisé dans les bases de données Les travaux que nous menons actuellement concernent d’une part l’étude de la suppression du site semi honnête CTRL en répartissant les opérations à réaliser pour évaluer l’automate entre les différents autres sites D’autre part nous étudions l’optimisation de la gestion de l’automate e g prise en compte de nouveaux opérateurs de conditions Références Cuppens F et A Miege 2005 Alert correlation in a cooperative intrusion detection fra mework In Proc of the IEEE International Conference on Networks ICON 2005 pp 118–123 Détection d’intrusion collaborative et sécurisée Database T O S V 2008 osvdb org Escamilla T 1998 Intrusion Detection Network Security beyond the firewall John Wiley and Sons New York Goldreich O 2000 Secure multi party computation working draft cite seer ist psu edu goldreich98secure html Graham R 2001 FAQ Network intryusion detection system robertgraham com pubs network intrusion detection html Heady R G Luger A Maccabe et M Servilla August 1990 The architecture of a network level intrusion detection system Technical Report CS9020 Hopcroft J R Motwanu Rotwani et J Ullman 2000 Introduction to Automata Theory Languages and Computability Addison Wesley Janakiraman R M Waldvoge et Q Zhang 2003 Indra a peer to peer approach to network intrusion detection and prevention In Proc of the 12th IEEE International Workshops on Enabling Technologies Infrastructure for Collaborative Enterprises pp 226–231 Kantarcioglu M et J Vaidya 2002 An architecture for privacy preserving mining of client information In Proc of the Workshop on Privacy Security and Data Mining in conjunction with the 2002 IEEE ICDM Conf pp 27–42 Locasto M J Parekh A Keromytis et S Stolfo 2005 Towards collaborative security and p2p intrusion detection In Proceedings of the 2005 IEEE Workshop on Information Assurance and Security West Point NY McHugh J A Christie et J Allen 2000 Defending yourself the role of intrusion detection systems IEEE Software 42–51 Proctor P 2001 Practical Intrusion Detection Handbook Prentice Hall Wang K G Cretu et S Stolfo 2005 Anomalous payload based worm detection and signa ture generation In Proceedings of the 8th International Symposium on Recent Advances in Intrusion Detection Zhang G et M Parashar 2006 Cooperative defence against ddos attacks Journal of Re search and Practice in Information Technology 38 1 Zhou C V S Karunasekera et C Leckie 2007 Evaluation of a decentralized architec ture for large scale collaborative intrusion detection In Proceedings of the 10th IFIP IEEE International Symposium on Integrated Network Management IM 2007 pp 80–89 Summary Intrusion Detection System IDS uses misuse detection and anomaly detection to recog nize any intrusions Even if new efficient IDS are available they have to face on the following problem what can we do when a request does not match a signature Usually IDS send an alert to the supervisor Nevertheless this signature was probably found in another web server and even if organizations may be willing to share their results they also want privacy of their data In this paper we propose a new approach for detecting attacks in a collaborative way but by preserving the privacy of the collaborative organizations 