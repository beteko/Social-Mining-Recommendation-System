 Mining Frequent Queries in Star Schemes Tao Yuan Jen Dominique Laurent Nicolas Spyratos Oumar Sy LICP Université de Cergy Pontoise 95302 Cergy Pontoise Cedex FRANCE {tao yuan jen dominique laurent} dept info u cergy fr LRI Université Paris 11 91405 Orsay Cedex FRANCE spyratos lri fr Université Gaston Berger Saint Louis SENEGAL oumar sy ugb sn Résumé L’extraction de toutes les requêtes fréquentes dans une base de données relationnelle est un problème difficile même si l’on ne considère que des requêtes conjonctives Nous montrons que ce problème devient possible dans le cas suivant le schéma de la base est un schéma en étoile et les données satisfont un ensemble de dépendances fonctionnelles et de contraintes référentielles De plus les schémas en étoile sont appropriés pour les entrepôts de données et que les dépendances fonctionnelles et les contraintes référentielles sont les contraintes les plus usuelles dans les bases de données En considérant le modèle des instances faibles nous montrons que les requêtes fréquentes exprimées par sélection projection peuvent être extraites par des algorithmes de type Apriori 1 Introduction The general problem of mining all frequent queries in a relational database i e all queries whose answer has a cardinality above a given threshold is known to be intractable even if we consider conjunctive queries only Goethals 2004 However mining all frequent queries from a database allows for the production of relevant association rules that cannot be obtained by other approaches even when dealing with multiple tables such as in Dehaspe and Raedt 1997 Diop et al 2002 Faye et al 1999 Han et al 1996 Meo et al 1997 Turmeaux et al 2003 This is so because in these approaches association rules are mined in the same table On the other hand when mining all frequent queries it is possible to obtain rules whose left and right hand sides are frequent queries mined in different tables The following example that serves as a running example throughout the paper illustrates this point Example 1 Let ∆ be a database containing three tables Cust Prod and Sales dea ling with customers products and sales transactions respectively and suppose that – the table Cust is defined over the attributes Cid Cname and Caddr standing respectively for the identifiers the names and the addresses of customers – the table Prod is defined over the attributes Pid and Ptype standing respectively for the identifiers and the types of products – the table Sales is defined over the attributes Cid Pid and Qty where Qty stands for the quantity of a product bought by a customer RNTI E 3331 Mining Frequent Queries in Star Schemes If all frequent queries in ∆ can be mined then it is possible to mine a rule such as At least 80% of customers living in Paris buy beer Indeed this is stated by the facts that the queries q1 = πCid σCaddr=Paris Cust and q2 = πCid σCaddr=Paris∧Ptype=beer Cust on Prod on Sales are frequent and that the confidence of the rule q1 ⇒ q2 is greater than or equal to 80% Notice that in q1 Cust cannot be replaced with Cust on Prod on Sales because in this case customers with no transactions would not be taken into account ¤ In this paper we show that the problem of mining all frequent queries in a database becomes tractable under restrictions that are met in data warehousing Indeed data warehouses are organized according to star schemes over which constraints such as functional dependencies and referential constraints are assumed The main contribution of this paper is to show that for a database over a star scheme all selection projection queries that are frequent can be computed based on any level wise algorithm such as Apriori Agrawal et al 1996 and thus that this computation is tractable In our formalism a database ∆ satisfying a set FD of functional dependencies is represented by its weak instance denoted by ∆FD Ullman 1988 Roughly speaking ∆FD is a set of tuples over the set U of all attributes and the difference between tuples in ∆FD and standard tuples is that tuples in ∆FD may contain null values Using this unique table ∆FD we consider all queries of the form σS π ↓ X ∆FD where S is a conjunctive selection condition X is any set of attributes and π↓X ∆FD is the total projection of ∆FD over X i e all restrictions over X of tuples in ∆FD whose values over X are constants Given such a query q the answer to q in ∆ denoted by ans∆ q is the set of all tuples in π ↓ X ∆FD that satisfy the selection condition S Then the support of q in ∆ denoted by sup∆ q is the cardinality of ans∆ q Example 2 Referring back to Example 1 assume that Cust satisfies the functio nal dependencies Cid → Cname and Cid → Caddr that Prod satisfies the func tional dependency Pid → Ptype and that Sales satisfies the functional dependency Cid P id → Qty Then the scheme of ∆ is a star scheme in which the fact table is Sales and the two dimensional tables are Cust and Prod Denoting by FD the set of the functional dependencies given above instead of consi dering the queries q1 and q2 of Example 1 we consider the following queries − q′1 = σCaddr=Paris π↓Cid Caddr ∆FD and − q′2 = σCaddr=Paris∧Ptype=beer π↓Cid Caddr Ptype ∆FD We note that although q′1 and q ′ 2 involve the same table ∆FD the computation of the supports and thus of the confidence takes into account the fact that there may exist customers in the table Cust whose identifiers do not occur in the table Sales ¤ We show that if the scheme of ∆ is a star scheme then the problem of mining all frequent conjunctive queries can be treated according to the following two steps each of them being based on a level wise algorithm such as Apriori Agrawal et al 1996 – Step 1 compute all frequent queries of the form π↓X ∆FD – Step 2 for each relation scheme X such that π↓X ∆FD is frequent compute all frequent queries of the form σS π ↓ X ∆FD where S is a conjunction of selection conditions of the form A = a with A in X and a in dom A RNTI 1 RNTI E 3 332 Jen et al To our knowledge except in Goethals 2004 no other work addresses the general pro blem of computing all frequent queries in a given database The work in Goethals 2004 considers conjunctive queries as we do in this paper and points out that considering no restrictions on the database scheme and no functional dependencies leads to a non tractable complexity Although some hints on possible restrictions are mentioned in Goethals 2004 no specific case is actually studied As we shall see considering a star scheme with its associated constraints leads to tractable level wise algorithms The approach of Casali et al 2003 is also related to our work because data cubes and star schemes both deal with multi dimensional data However the frequent queries considered in Casali et al 2003 involve the fact table only Therefore contrary to our approach it is not possible to mine frequent queries defined on any set of attributes We note however that Casali et al 2003 takes into account the hierarchies on the dimensions which is not the case in our approach As mentioned previously all approaches dealing with mining frequent queries in multi relational databases Dehaspe and Raedt 1997 Diop et al 2002 Faye et al 1999 Han et al 1996 Meo et al 1997 Turmeaux et al 2003 consider only one table for a given mining task and consequently these approaches fail to mine association rules as in Example 1 We also note that except for Turmeaux et al 2003 all these ap proaches are restricted to conjunctive queries as we do in this paper The paper is organized as follows In Section 2 we recall the basics of weak instance semantics and of star schemes Section 3 deals with the queries that are of interest in our approach In Section 4 two algorithms are provided for the computation of frequent queries and Section 5 concludes the paper 2 Background We recall from Ullman 1988 that in the relational model of databases given a universe of attributes U every attribute A in U is associated with a set of values called the domain of A and denoted by dom A Moreover a relational database scheme consists of a set S of tables τ1 τn where each table τi is associated with an attribute set called the scheme of τi and denoted by sch τi In a relational database over S each table τi contains a relation over sch τi i e a finite set of tuples over sch τi 2 1 Universal Relation Scheme Interfaces Universal relation scheme interfaces were introduced in the early 80s in order to pro vide logical independence to the relational model Given a database ∆ over a universe of attributes U and a set of functional dependencies FD over U logical independence is achieved by associating ∆ FD to a single table over U that we denote by ∆FD and that is called the weak instance of ∆ We refer to Laurent et al 2003 Ullman 1988 for more details on the contruction of ∆FD and we simply note here that contrary to standard relations tuples in ∆FD may contain null values The weak instance ∆FD can be seen as the only table to which queries on ∆ are addressed More precisely for every relation scheme X we denote by π↓X ∆FD the set of all tuples t over X such that i t contains no null value and ii there exists a RNTI 1 RNTI E 3333 Mining Frequent Queries in Star Schemes tuple t′ in ∆FD such that t′ A = t A for every attribute A in X π ↓ X ∆FD is then the set of all tuples over X that are true in ∆ and so it is possible to consider all queries of the form σS π ↓ X ∆FD where S is a selection condition involving attributes in X In this paper we consider only queries whose selection condition is a conjunction of selection conditions of the form A = a where A is an attribute in X and a is a constant in dom A 2 2 Star Schemes An N dimensional star scheme consists of a distinguished table ϕ called the fact table and N other tables δ1 δN called dimension tables such that 1 If K1 KN are the primary keys of δ1 δN respectively then K = K1 ∪ ∪KN is the key of ϕ 2 For every i = 1 N πKi ϕ ⊆ πKi δi Note that each Ki is a foreign key in the fact table ϕ The attribute set M = sch ϕ \K is called the measure of the star scheme Moreover we use the following simplified notation sch δ1 sch δN are denoted by D1 DN respectively and sch ϕ is denoted by F Example 3 The scheme of the database ∆ FD in our running example is a 2 dimensional star scheme {δ1 δ2 ϕ} where the two dimension tables are δ1 = Cust and δ2 = Prod the fact table is ϕ = Sales and the measure is {Qty} Moreover − Cid is the key of δ1 Pid is the key of δ2 and Cid Pid is the key of ϕ − πCid ϕ ⊆ πCid δ1 and πPid ϕ ⊆ πPid δ2 ¤ Now let ∆ FD be a database defined over an N dimensional star scheme and let us consider its weak instance ∆FD We “simplify” the table ∆FD by removing from it all tuples t′ for which there exists t in ∆FD such that t′ A = t A for every attribute A over which t′ is a constant We feel justified in performing this simplification because doing so does not change the answers to queries From now on the symbol ∆FD will denote the simplified table It is important to note that the simplified table contains two kinds of tuples – either total tuples i e tuples containing no null value and there is a one to one mapping between these tuples and the tuples of the fact table – or tuples t containing constants over the attributes of a single dimension say i such that the key value t Ki does not occur in the fact table We denote by ∆ϕFD the set of all total tuples in ∆FD and by ∆ i FD the set of all tuples in ∆FD containing constants only over attributes of dimension i for i = 1 N In the remainder of this paper we consider a fixed N dimensional star scheme with fact table ϕ and dimension tables δ1 δN and a fixed database ∆ over that scheme Moreover for the sake of simplification we assume that for every i = 1 N the key of dimension i is reduced to a single attribute Ki On the other hand it is well known that in practice the cardinality of the fact table is much higher than that of any dimension table In order to take this situation into account we assume that for every i = 1 N |δi| ≤ |ϕ| RNTI 1 RNTI E 3 334 Jen et al Example 4 We refer back to the database introduced in Example 1 where the universe of attributes is U = {Cid Cname Caddr P id P type Qty} and the functional depen dencies are FD = {Cid → Cname Cid → Caddr P id → Ptype CidP id → Qty} Let us consider a database ∆ FD consisting of the following three relations Cust Cid Cname Caddr c1 John Paris c2 Mary Paris c3 Jane Paris c4 Anne Tours Prod P id P type p1 milk p2 beer Sales Cid P id Qty c1 p1 10 c2 p2 5 c2 p1 1 c1 p2 10 The simplified weak instance ∆FD in which null values are not represented is the following ∆FD Cid Pid Cname Caddr P type Qty c3 Jane Paris c4 Anne Tours c1 p1 John Paris milk 10 c2 p2 Mary Paris beer 5 c2 p1 Mary Paris milk 1 c1 p2 John Paris beer 10 Notice that in this example ∆ϕFD and ∆ 1 FD contain respectively the last four tuples and the first two tuples of ∆FD whereas ∆2FD is empty Moreover the answers to queries q′1 and q ′ 2 of Example 2 are shown below ans q′1 Cid Caddr c1 Paris c2 Paris c3 Paris ans q′2 Cid Caddr P type c2 Paris beer c1 Paris beer ¤ 3 Frequent Queries 3 1 Queries Definition 1 Given a database ∆ over an N dimensional star scheme let X be a rela tion scheme Denoting by ⊥ and > the false and true selection conditions respectively let Σ X be the following set of conjunctive selection conditions Σ X = {⊥ >} ∪ { A1 = a1 ∧ ∧ Ak = ak | ∀i = 1 k Ai ∈ X and ai ∈ dom Ai and ∀i j ∈ {1 k} i 6= j ⇒ Ai 6= Aj } Selection conditions of Σ X are called selection conditions over X Moreover we denote by Q X the set of all queries of the form σS π↓X ∆FD where S ∈ Σ X and by Q ∆ the union of all sets Q X for all relation schemes X According to Definition 1 we have σ> π ↓ X ∆FD = π ↓ X ∆FD and σ⊥ π ↓ X ∆FD = ∅ In order to simplify the notations we denote σS π↓X ∆FD by σS X with the convention that when S = > π↓X ∆FD is denoted by X RNTI 1 RNTI E 3335 Mining Frequent Queries in Star Schemes We compare queries of Q X using the standard query containment pre ordering Ullman 1988 for all q1 and q2 inQ X q1 is contained in q2 denoted by q1 v q2 if for all databases over the fixed N dimensional star scheme we have ans q1 ⊆ ans q2 Let us define the following two operators Z and Y on selection conditions in Σ X For all S1 and S2 in Σ X define – If S1 = ⊥ or S2 = ⊥ then S1 Z S2 = ⊥ If S1 = > respectively S2 = > then S1 Z S2 = S2 respectively S1 Otherwise if S1 ∧ S2 ∈ Σ X then S1 Z S2 = S1 ∧ S2 else S1 Z S2 = ⊥ – If S1 = ⊥ respectively S2 = ⊥ then S1 Y S2 = S2 respectively S1 If S1 = > or S2 = > then S1 Y S2 = > Otherwise S1 Y S2 is the conjunction of all elementary selection conditions Ai = ai that occur in both S1 and S2 It can be seen that for all queries q1 = σS1 X and q2 = σS2 X in Q X we have 1 σS1ZS2 X and σS1YS2 X are in Q X 2 qi v σS1YS2 X and qi w σS1ZS2 X for i = 1 2 3 σS1YS2 X = minv{q ∈ Q X | q1 v q and q2 v q} and σS1ZS2 X = maxv{q ∈ Q X | q v q1 and q v q2} Thus 〈Q X v〉 is a lattice This property is used in our approach to compute the frequent queries ofQ X using a level wise algorithm such as Apriori Agrawal et al 1996 3 2 Frequent Queries Definition 2 Let ∆ be a database over an N dimensional star scheme For every query q in Q ∆ the support of q in ∆ denoted by sup∆ q or by sup q when ∆ is understood is the cardinality of the answer to q in ∆ A query q is said frequent in ∆ or frequent when ∆ in understood if sup q is greater than or equal to a given support threshold σ Referring back to Example 4 it is easy to see that we have sup q′1 = 3 and sup q ′ 2 = 2 Thus for a given support threshold equal to 3 q′1 is frequent whereas q ′ 2 is not It turns out that our notion of support is monotonic with respect to v i e for all queries q1 and q2 in Q ∆ q1 v q2 ⇒ sup q1 ≤ sup q2 Since q1 v q2 requires that q1 and q2 be over the same scheme the previous im plication can be stated as follows If q1 = σS1 X and q2 = σS2 X are such that S2 = S1 Z S and if q1 is not frequent then q2 is not frequent either Consequently frequent queries of Q ∆ can be computed using any level wise algorithm Morever notice that if X is not frequent then no query of Q X is frequent On the other hand given a standard relation r over relation scheme R i e a finite set of tuples defined on all the attributes of R for all X and Y such that X ⊆ Y ⊆ R we have |πX r | ≤ |πY r | However this property does not hold for partial tuples meaning that X ⊆ Y ⇒ sup X ≤ sup Y does not hold in our framework Indeed in the table of Example 4 with X = {Cid Caddr} and Y = {Cid Caddr Qty} we have X ⊆ Y whereas sup X = 4 and sup Y = 3 The following proposition shows cases of monotonicity RNTI 1 RNTI E 3 336 Jen et al Proposition 1 Let X and Y be relation schemes satisfying one of the statements either ∀i j ∈ {1 N} X 6⊆ Di and Y 6⊆ Dj or ∃i ∈ {1 N} X ⊆ Di and Y ⊆ Di For every selection condition S over X X ⊆ Y ⇒ sup σS X ≤ sup σS Y Based on Proposition 1 the frequent queries of the form X are computed by consi dering the lattice of all non empty subsets of U starting by U itself At each level candidate relation schemes of the same cardinality are pruned as follows – If for every i = 1 N X 6⊆ Di and if for some attribute A XA has been found not frequent then X cannot be frequent – If there exists i in {1 N} such that X ⊂ Di and if for some A in Di XA has been found not frequent in the previous step then X cannot be frequent It is important to note that for a given dimension i the fact that DiA is not frequent does not imply that Di is not frequent Moreover Proposition 1 and our assumption that |ϕ| ≥ |δi| i = 1 N imply the following corollary Corollary 1 For every query q in Q ∆ we have sup q ≤ sup U We use the functional dependencies for further optimization based on the following given a standard relation r over relation scheme R i e a finite set of tuples defined on all the attributes of R if X and Y are such that r satisfies X → Y then |πX r | = |πXY r | Thus if X and Y have the same key then for every selection condition S over X and Y we have |σS X | = |σS Y | Moreover it can be seen that in the case of a star scheme every relation scheme X has one key denoted by key X and defined by − if for every i = 1 N Ki ∈ X then key X = K1 KN − else key X = X \ {A ∈ X | ∃i ∈ {1 N} KiA ⊆ Di ∩X and A 6= Ki } Proposition 2 Let X and Y be two relation schemes such that key X = key Y For every selection condition S over X and Y sup σS X = sup σS Y Therefore applying Proposition 2 in the context of a level wise algorithm for every can didate query X if there exists an attribute A not in X such that key X = key XA then X is frequent if and only if XA has been found frequent The following example illustrates Proposition 1 and Proposition 2 Example 5 Consider the database ∆ of Example 4 and a support threshold equal to 3 We recall that the query q′2 = σCaddr=Paris∧Ptype=beer X where X = {Cid Caddr P type} is not frequent Therefore when computing the frequent queries of Q Y where Y = {Caddr P type} by Proposition 1 we know without any computation that the query σCaddr=Paris∧Ptype=beer Y is not frequent On the other hand since sup U = 4 U is frequent Using Proposition 2 all queries of the form X such that {Cid P id} ⊆ X are frequent So when computing the frequent queries of the form X with |X| = 5 we know without any computation that the following schemes are frequent with a support equal to 4 {Cid P id Caddr P type Qty} {Cid P id Cname P type Qty} {Cid P id Cname Caddr Qty} and {Cid P id Cname Caddr P type} ¤ RNTI 1 RNTI E 3337 Mining Frequent Queries in Star Schemes 4 Algorithms 4 1 Frequent Queries of the Form X In the algorithm given below we use the following notations – For a given integer k Cϕk denotes the set of candidate relation schemes of car dinality k that are not subsets of any Di Cik i = 1 N denotes the set of candidate relation schemes of cardinality k that are subsets of Di and Ck denotes the union of Cϕk and of all C i k for i = 1 N – Similarly for a given integer k Lϕk denotes the set of frequent queries whose corresponding scheme is of cardinality k and not a subset of any Di Lik i = 1 N denotes the set of frequent queries whose corresponding scheme is of cardinality k and is a subset of Di and Lk denotes the union of L ϕ k and of all L i k for i = 1 N – supϕ X and supi X i = 1 N denote the number of distinct tuples over X obtained by scanning the tables ∆ϕFD and ∆ i FD respectively Thus given a relation scheme X if there exists i in {1 N} such that X ⊆ Di then sup X = supϕ X + supi X else sup X = supϕ X Algorithm 1 Input The simplified weak instance ∆FD associated to a database ∆ over an N dimensional star scheme {D1 DN F} The cardinalities |ϕ| |δ1| |δN | of all tables in ∆ A support threshold σ Output All queries of the form X that are frequent in ∆ Method if |ϕ| < σ then 1 no computation based on Corollary 1 return ∅ else k = |U | Lk = { U } Lϕk = { U } for each i = 1 N do Lik = ∅ end for each while Lk 6= ∅ or k > mini |Di| do k = k − 1 2 generation of candidates of level k by considering all subsets of cardinality k of all relation schemes in Lk+1 generate Ck from Lk+1 Cϕk = {X ∈ Ck | ∀i = 1 N X 6⊆ Di } 3 pruning based on Proposition 1 Cϕk = C ϕ k \ {X ∈ Cϕk | ∃A ∈ U XA 6∈ Lϕk+1 } 4 pruning based on Proposition 2 same sup = {X ∈ Cϕk | ∃A ∈ U XA ∈ Lϕk+1 and key X = key XA } Cϕk = C ϕ k \ same sup Lϕk = { X | X ∈ same sup} for each i = 1 N do Cik = ∅ if k ≤ |Di| then if k = |Di| then 5 test whether Di is frequent if |δi| ≥ σ then Lik = { Di } else Lik = ∅ end if else Cik = {X ∈ Ck | X ⊂ Di} RNTI 1 RNTI E 3 338 Jen et al 6 pruning based on Proposition 1 Cik = C i k \ {X ∈ Cik | ∃A ∈ Di XA 6∈ Lik+1 } 7 pruning based on Proposition 2 same sup = {X ∈ Cik | Ki ∈ X and ∃A ∈ Di XA ∈ Lik+1 } Cik = C i k\ same sup Lik = { X | X ∈ same sup} end if end if end for each 8 computation or pre computation of the supports one pass over ∆ϕFD compute supϕ X for each X ∈ Cϕk ∪ C1k ∪ ∪ CNk Lϕk = L ϕ k ∪ { X | X ∈ Cϕk and supϕ X ≥ σ} for each i = 1 N do 9 additional pruning Cik = C i k \ {X ∈ Cik | supϕ X + |δi| < σ} 10 computation of the supports one pass over ∆iFD Lik = L i k ∪ { X | X ∈ Cik and supϕ X + supi X ≥ σ} end for each Lk = L ϕ k ∪ L1k ∪ ∪ LNk end while return ⋃ k Lk end if We give more details on comments in Algorithm 1 Comment 1 is an immediate consequence of Corollary 1 and concerning comment 2 we note that all candidates at level k are obtained by removing one attribute from the frequent schemes at level k+1 We do not give details about the function generate but we mention that considering the attributes according to a fixed ordering allows to efficiently perform this step Comments 3 and 6 are consequences of Proposition 1 In particular it is im portant to note that in the case of comment 6 Cik is pruned by considering subsets of Di only Similarly comments 4 and 7 are consequences of Proposition 2 The test in comment 5 comes from the fact that for every i = 1 N the support of Di is equal to |δi| and thus requires no computation Moreover due to Proposition 1 all dimensions Di must be considered even if not generated from the previous step This comment is also related to the condition in the while loop Comments 8 and 10 deal with the count of sup X if X is not contained in any dimension scheme Di then sup X = supϕ X and if X is a subset of some Di then sup X = supϕ X + supi X In this case an additional pruning is mentioned in comment 9 Indeed for every X ⊆ Di we know that sup X ≤ supϕ X + |δi| Therefore if supϕ X + |δi| < σ then X is not frequent Summarizing the remarks just above it can be seen that Algorithm 1 is a level wise algorithm that scans the table ∆FD only once per level and that more prunings than in Apriori are possible 4 2 Frequent Queries of the Form σS X The frequent queries of the form σS X are computed by applying the algorithm Apriori to each frequent query in the output of Algorithm 1 The queries in ⋃ k Lk RNTI 1 RNTI E 3339 Mining Frequent Queries in Star Schemes are considered in a decreasing ordering of the cardinalities of the schemes in order to prune candidate queries based on Proposition 1 and Proposition 2 In the algorithm given below we denote by CXk respectively L X k the set of all candidate respectively frequent queries of the form σS X where S is a selection condition over X containing exactly k conjuncts A = a Moreover LX denotes the set of all queries in Q X that are frequent Algorithm 2 Input The simplified weak instance table ∆FD associated to a database ∆ over an N dimensional star scheme {D1 DN F} The output ⋃ k Lk of Algorithm 1 and the cor responding support threshold σ Output All queries of the form σS X that are frequent in ∆ Method for each X in ⋃ k Lk do if ∃A ∈ U key X = key XA then 1 no computation based on Proposition 2 LX = {σS X | σS XA ∈ LXA and S is over X} else k = 0 LXk = { X } SXk = > while LXk 6= ∅ and k < |X| do k = k + 1 2 generation of all selection conditions based on Definition 1 generate the set SXk of all selection conditions over X based on L X k−1 CXk = {σS X | S ∈ SXk } 3 standard pruning CXk = C X k \ {σS X | ∃S′ S = S′ ∧ A = a and σS′ X 6∈ LXk−1 } 4 pruning based on Proposition 1 if ∀i = 1 N X 6= Di then CXk = C X k \ {σS X | ∃A ∈ U σS XA 6∈ LXA } enf if 5 computation of the supports if ∃i ∈ {1 N} X ⊆ Di then one pass over ∆ϕFD ∪∆iFD or δi else one pass over ∆ϕFD compute sup σS X for each σS X ∈ CXk LXk = L X k ∪ {σS X | σS X ∈ CXk and sup σS X ≥ σ} end while LX = ⋃ k L X k end if end for each return L = ⋃ X L X We review the main steps of Algorithm 2 as follows as stated in comment 1 Proposition 2 implies that LX can be obtained from LY if X ⊆ Y and key X = key Y Concerning comment 2 we simply note that selection conditions at level k are obtained from the selection conditions in the queries of LXk−1 in much the same way as in Apriori Comment 3 refers to the standard pruning phase of Apriori and as noticed in comment 4 Proposition 1 allows for additional pruning based on the fact that when computing LX if for some superset Y of X LY has already been computed then we know that for every selection condition S over X sup σS X ≤ sup σS Y Comment 5 specifies the part of the table ∆FD that has to be scanned to compute RNTI 1 RNTI E 3 340 Jen et al the supports We note that if X ⊆ Di then scanning δi could be an option instead of scanning ∆ϕFD ∪∆iFD 4 3 Computational Issues Although we have no experiments to report we would like to point out some com ments on our approach First we note that the table ∆FD can be efficiently computed using for instance external joins Ullman 1988 On the other hand finding all frequent queries in a database over an N dimensional star scheme requires at most P + 1 appli cations of a level wise algorithm if P schemes X are such that X is frequent However it is likely that not all frequent queries are of interest for each user Instead some users can be interested in some schemes while other users would like to focuss on other schemes We propose the following policy – Run Algorithm 1 once for all users Storing all frequent queries of the form X with their supports could serve as a basis for queries issued by the users – Assuming that users ask for frequent queries on different schemes but rarely all of them it is easy to modify Algorithm 2 so that it is restricted to a specified set of schemes at the cost of less additional prunings – If all frequent queries computed so far are stored with their supports then addi tional prunings are possible as done in Diop et al 2002 5 Conclusion and Further Work In this paper we have considered the weak instance model of relational databases in order to design level wise algorithms for the computation of all frequent queries in a database over an N dimensional star scheme Moreover we have shown that in this case additional prunings with respect to Apriori are possible We are currently implementing our approach and future research directions include the following i Considering schemes more sophisticated than star schemes such as snowflake or constellation schemes The work reported in Levene and Loizou 2003 provides a suitable theoretical basis for this investigation ii Since our work is closely related to the approach presented in Diop et al 2002 we are investigating the rela tionships between the two approaches iii Since data cubes and star schemes are two notions that deal with multi dimensional data the relationships between our work and that of Casali et al 2003 must be investigated further Références Agrawal R Mannila H Srikant R Toivonen H and Verkamo A 1996 Fast discovery of association rules In Advances in Knowledge Discovery and Data Mining pages 309–328 AAAI MIT Press Casali A Cichetti R and Lakhal L 2003 Extracting semantics from data cubes using cube transversals and closures In KDD pages 69–78 ACM RNTI 1 RNTI E 3341 Mining Frequent Queries in Star Schemes Dehaspe L and Raedt L D 1997 Mining association rules in multiple relations In S Dzeroski and N Lavrac editors 7th International Workshop on Inductive Logic Programming volume LNCS 1297 pages 125–132 Springer Verlag Diop C T Giacometti A Laurent D and Spyratos N 2002 Composition of mining contexts for efficient extraction of association rules In EDBT’02 volume LNCS 2287 pages 106–123 Springer Verlag Faye A Giacometti A Laurent D and Spyratos N 1999 Mining rules in databases with multiple tables Problems and perspectives In 3rd International Conference on Computing Anticipatory Systems CASYS’99 Liège Belgique Goethals B 2004 Mining queries unpublished paper In Workshop on induc tive databases and constraint based mining Hinterzarten Germany available at informatik uni freiburg de ̃ ml IDB talks Goethals slides pdf Han J Fu Y Wang W Koperski K and Zaiane O 1996 Dmql A data mining query language for relational databases In SIGMOD Workshop DMKD’96 pages 27–34 Laurent D Luong V P and Spyratos N 2003 Querying weak instances under extension chase semantics International Journal of Comp Mathematics 80 5 591– 613 Levene M and Loizou G 2003 Why is the snowflake schema a good data warehouse design Information Systems 28 3 225–240 Meo R Psaila G and Ceri S 1997 An extension to sql for mining association rules In Data Mining and Knowledge Discovery volume 9 pages 275–300 Turmeaux T Cassard D Salleb A and Vrain C 2003 Apprentissage de règles caractéristiques In Journées francophones d’Extraction et de gestion des Connais sances EGC pages 437–448 Ullman J 1988 Principles of Databases and Knowledge Base Systems volume 1 Computer Science Press Summary The problem of mining all frequent queries in a database is intractable even if we consider conjunctive queries only In this paper we show that this problem becomes tractable under the following restrictions the database scheme is a star scheme the data in the database satisfies a set of functional dependencies and a set of referential constraints We note that star schemes are considered to be the most appropriate for data warehouses while functional dependencies and referential constraints are the most common constraints that one encounters in real databases Our approach is based on the weak instance semantics and considers selection projection queries over weak instances In such a context we show that frequent queries can be mined using level wise algorithms such as Apriori RNTI 1 RNTI E 3 342