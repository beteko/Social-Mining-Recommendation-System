articles assemblage pdfPGP extraction parallèle efficace motifs graduels Laurent Benjamin Negrevergne Nicolas Sicard Alexandre Termier LIRMM 34392 Montpellier Cedex laurent lirmm lirmm EFREI République Villejuif nicolas sicard efrei efrei Passerelle 38402 Saint Martin Hères benjamin Negrevergne Alexandre Termier liglab Résumé Initialement utilisés systèmes commande règles graduels forme personne salaire trouvent nombreuses applications exemple domaines biologie données flots issues réseaux capteurs récemment algorithmes proposés extraire automatiquement motifs Cependant certains entre permis gains performance importants algorithmes restent coûteux permettent traiter efficacement bases données réelles souvent volumi neuses nombre lignes nombre attributs proposons article méthode originale recherche motifs utilisant multi threading exploiter mieux multiples coeurs présents plupart ordinateurs serveurs actuels efficacité cette approche lidée étude expérimentale Introduction fouille données recherche motifs fréquents sujet recherche Initialement étudiés données transactionnelles algorithmes étendus structures données complexes séquences arbres graphes Kamber manière générale algorithmes doivent explorer espace recherche important coûteux temps calcul complexité calculs augmentant celle structures données traiter grande partie travaux menée mettre point algorithmes efficaces permettant fouiller grandes bases données structures potentiellement complexes Récemment nouveau règles motifs introduit motifs graduels itemsets graduels problème découvrir partir bases données numériques motifs individu salaire élevé trouve breuses applications bases données numériques comme exemple données extraction parallèle efficace motifs graduels biologiques médicales contexte algorithme GRITE proposé Jorio notre connaissance efficace termes temps calcul occupation moire Développé partir approche niveaux Agrawal Srikant permet fouiller bases données comprenant jusqu plusieurs centaines attributs plusieurs milliers lignes quand approches précédentes étaient limitées attributs Berzal Cependant performances restent faibles regard bases données réelles comprenant milliers attributs millions lignes lesquelles algorithme GRITE avérer voire impossible exécuter solutions exclusives envisageables échelle GRITE appliquer données réelles améliorations algorithmiques exemple utilisant techniques pattern growth définissant notion fermeture motifs graduels Pasquier explorant possibilités parallélisation article explorons seconde solution exploitant parallélisme processeurs multi cœurs cours dernières années augmentation performance processeurs passait effet essentiellement augmentation fréquence depuis limites physiques empêchent améliorer cette fréquence Cepen possible intégrer transistors permettent multiplier cœurs calcul processeur exploitation optimale multiples cœurs quiert écriture programmes parallèles architecture ayant propriétés propres différentes exemple clusters machines processeurs multi cœurs souvent architecture Uniform Memory Access machine dotée mémoire cœurs temps accès équivalent cette mémoire travers unique usage mémoire goulot étranglement classique applications parallèles denières années recherches menées fouille données parallèle ploiter architectures multi cœurs Buehrer Lucchese Tatikonda Parthasarathy montrant problème fouille était plexe arbres graphes parallélisation améliorait performances principale raison accès mémoires relativement faibles rapport calculs coûteux effectuer données chargées caches application parallélisation recherche motifs graduels reste technique coûteuse prometteuse étudions après validons travers expérimentations menées suite article organisé manière suivante section introduit notion motif graduel tandis section rappelle principales définitions motifs présents littérature ainsi principales approches fouille données parallèle section présente notre algorithme parallèle extraction motifs graduels résultats expérimentaux présentés section Enfin section conclut présente principales perspectives associées travail Motifs graduels motifs graduels forme moins moins considère données consistant relation définie ensemble attributs contexte motifs graduels définis ensemble éléments associés ordre croissant décroissant valeur attribut Laurent Weight Sugar Fruits leurs caractéristiques exemple considère données figure décrivant fruits leurs caractéristiques Définition graduel données définie attributs motif graduel couple attribut opérateur comparison operator itemset graduel motif graduel ensemble items graduels exemple graduel tandis Weight itemset graduel support itemset graduel données revient culer point motif présent Plusieurs définitions formelles cette notion support proposées section dessous article considère nombre uplets possible ordonner respecter opérateurs comparaison chacun attributs présents motif considéré Définition Support itemset graduel données itemset graduel cardinalité notée correspond longueur longue liste uplets comparaison valide support correspond ratio cardinalité notons calculer Jorio propose considérer graphe lequel nœuds correspondent uplets lequel existe entre nœuds uplets associés ordonnés rapport exemple figure montre ordonnancement uplets exemple précédent itemset taille grande moins sucre important extraction parallèle efficace motifs graduels longeur chemin graphe Comme contient uplets algorithme principe APriori notant items explorés mesure toute données ordonnée trier unique attribut algorithme débute étudiant support toutes paires items graduels ensuite niveau suivant constituant candidats niveau fonction fréquents taille testant support stockage ordonnancements niveau format binaire coûteux Cependant principal goulot étranglement uplets doivent ordonnés fonction itemset graduel considéré calcul longueur chemin prend temps Travaux connexes rappelons cette section principales approches littérature décou verte motifs graduels extraction parallèle motifs fréquents Découverte motifs graduels motifs graduels étudiés depuis nombreuses années contrôle mande floue systèmes recommandation récemment algorithmes fouille données étudiés extraire automatiquement motifs Jorio Berzal Jorio Hüllermeier Laurent Ainsi Hüllermeier utilise régression linéaire tandis Berzal définit quatre types règles graduelles forme moins alors moins propose algorithme niveaux extraire telles règles Cependant support calculé considérant couples uplets approche complexe auteurs introduisent motifs séquentiels graduels rendre compte force modification accélération Jorio Jorio méthodes proposées différence étant calcul support tandis heuristique utilisée Jorio support exact calculé Jorio grâce méthode précédemment Laurent teurs proposent autre manière calculer support considérant Kendall ranking correlation coefficient calcule longeur chemin nombre paires uplets ordonnables données accord motif graduel considéré parle alors paires concordantes discordantes article considérons approche présentée Jorio notre connaissance performante Extraction parallèle motifs fréquents Depuis spécialistes extraction motifs fréquents travaillé rithmes parallèles nombreux travaux réalisés extraire motifs fréquents clusters Agrawal Shafer cette époque mémoire ordinateurs personnels était beaucoup petite taille plupart bases données quelques centaines MégaOctets quelques GigaOctets Laurent intérêt principal calcul parallèle était permettre traiter efficacement bases données taille importante distribuant plusieurs machines augmenta capacité mémoires vives découverte manières efficaces explorer espace recherche motifs fréquents fermés exemple publications extraction parallèle motifs fréquents raréfiées jusqu Depuis apparition proces seurs multicœurs appelés anglais MultiProcessors nouvelle thématique recherche apparue définition algorithmes performants utilisant processeurs multicœurs Cette thématique initiée Buehrer algorithme traction graphes fréquents présentant excellentes techniques passage échelle algorithme gSpan contribution consiste manière efficace partager travail entre cœurs autre technique exploiter localité temporelle cache décisions locales savoir immédiatement traiter appel récursif mettre attente Lucchese ensuite présenté premier algorithme extraire itemsets fréquents fermés contribution concentre meilleure manière répartir travail montrent intérêt utiliser instructions améliorer encore performances année présenté parallélisation célèbre algorithme growth récemment Tatikonda Parthasarathy présenté algorithme extraire arbres fréquents speed quasi linéaire montrent principal facteur limitant performances extraction motifs fréquents processeur multicœurs mémoire partagée entre cœurs cœurs accèdent simultanément quantité importante données entre mémoire processeur saturé performances chuter contention bande passante Cette observation opposée donnait résultats séquentiel éviter calculs redondants grande quantité résultats inter médiaires étaient stockés mémoire Tatikonda montrent taille ensemble travail réduite autant possible conduire refaire certains calculs plusieurs montrent également traditionnelles structures données pointeurs adaptées extraction parallèle motifs fréquents cause mauvaise localité cache encore amène avoir contention bande passante article intéressons problème complexe extraction motifs graduels sommes favorable beaucoup calculs faire chaque données transféré depuis mémoire devrait avoir contention importante bande passante condition utiliser structures données inutilement volumineuses Recherche parallèle motifs graduels Caractéristiques motifs graduels problème extraction itemsets graduels diffère classiques simples dernier chaque ligne données possible supporte itemset graduel toute données néces saire chaque comptage raisonnable envisager distribution données extraction parallèle efficace motifs graduels blocs lignes Notons extraction motifs séquentiels problème termédiaire comptage lignes chaque correspondant toutes lignes associées client calcul support itemset graduel opération assez complexe nécessite tâches coûteuses englobons procédure appelée Cette procédure décrite détail Jorio assure ordonnancement lignes données construction matrice binaire associée calcul chemin Notre proposition repose grand nombre répétitions opérations ploration données problème irrégulier difficile prévoir avance nombre motifs retenus distribution espace didats construit dynamiquement niveau niveau revanche notons calcul support itemset dépend calcul support autres itemsets niveau permet envisager construction plusieurs candidats parallèle rappelons adoptons approche multi thread sépare exécute travail différentes unités calcul processeurs coeurs procédant manière concurrente Approche proposée GRITE algorithme GRITE repose exploration treillis niveau niveau premier niveau initialisé partir colonnes Ensuite candidats niveau construits partir chaque itemset niveau combiné successivement ensemble itemsets frères supérieur Siblingsj grâce procédure Lorsqu candidat dépasse certain seuil support considéré comme fréquent conservé processus arrête quand dernier niveau construit contient aucun fréquent algorithme montre version simplifiée construction niveau partir niveau Algorithme GRITE construction niveau partir niveau PourChaque itemset niveau Faire PourChaque itemset Siblingsj Faire itemset fréquent Alors devient prend index conservé niveau FinSi FinPourChaque FinPourChaque chaque niveau construit avant commencer traitement niveau suivant cette raison sommes concentrés parallélisation chaque niveau individuellement construction candidat procédure opération Laurent essentiellement indépendante autres problème principal concerne alors équilibre distribution tâches unités traitement disponibles effet nombre rations boucle interne algorithme difficile prévoir niveau nombre itemsets frères chaque itemset varier façon sensible parallélisation automatique boucles risque conduire déséquilibre charge Notre méthode compenser cette irrégularité affectant dynamiquement construc tions candidats niveau threads selon règle premier arrivé servi début itemsets fréquents niveau marqués traités stockés attente nouvel itemset défilé nœuds frères ajoutés seconde Chaque thread disponible extrait alors itemset construit nouveau candidat partir fréquent candidat conservé niveau comme Lorsque nouvel itemset extrait processus reprend début arrête quand itemsets traités files vides algorithme montre version simplifiée cette approche Algorithme GRITE multithread construction niveau partir niveau itemsets threads itemsets niveau nœuds frères traités PourChaque thread parallèle Faire TantQue Faire Alors defiler Siblingsj FinSi defiler itemset frequent Alors devient prend index conservé niveau FinSi FinTantQue FinPourChaque œuvre optimisations préliminaires Outre contraintes bande passante mémoire autre problème calculs sivement multithreadés apparaître lorsqu grand nombre allocations mémoires extraction parallèle efficace motifs graduels dynamiques simultanément tâches allocations défaut dévolues noyau système exploitation plupart temps sérialisées pouvant introduire attentes inutiles calcul simplifier utilisation mémoire aussi terme cupation nombre transactions avons profilé optimisé version initiale programme Jorio modifier algorithme programme sultant consomme moyenne moitié mémoire presque tiers seulement temps exécution travaux parallélisation expérimentations basés cette nouvelle version Notons threads implantés bibliothèque threads standard POSIX Résultats expérimentaux discussion cette section présentons résultats obtenus exécution notre gramme architectures multi processeurs comportant jusqu cœurs COYOTE dispose processeurs quadri cœurs Opteron mémoire Linux Centos IDKONN dispose processeurs Intel cœurs chacun Linux Debian expériences menées bases artificielles créées automatiquement outil version adaptée Synthetic Generation Associations Sequential Patterns outil produit bases numériques fonction nombre lignes nombre attributs nombre moyen valeurs distinctes attribut Accélérations résultats suivants illustrent évolution temps calcul accélérations complexité problème Cette complexité avoir origines nombre tributs dépend nombre tâches nombre candidats synthétiser tester nombre lignes influe temps traitement moyen chaque tâche temps traitement procédure présentons permettant observer comportement notre solution suivant aspects premier tests concerne bases données comportent grand nombre lignes relativement attributs genre bases produit général assez itemsets fréquents seuil support suffisamment élevé temps global exécution programme principalement dévolu construction premiers veaux candidats figure montre diminution temps exécution traitement bases données 10000 lignes attributs machine COYOTE figure montre accélérations correspondantes accélérations atteignent niveau satisfaisant complexes exemple accélération atteint environ attributs threads limite teinte attributs explique essentiellement construction niveau occupe grande temps exécution global programme almaden software projects resources shtml Laurent COYOTE Bases 10000 lignes attributs minsupp Nombre threads exécution COYOTE Bases 10000 lignes attributs minsupp Nombre threads Accélération exécution accélération threads 10000 lignes COYOTE niveau nombre tâches strictement nombre attributs faible ploiter quelques unités traitement surtout assurer équilibre charge Ainsi traitement séquentiel attributs prend environ secondes parmi lesquelles secondes nécessaires charger construire premier niveau threads temps global exécution secondes secondes encore nécessaires premier niveau expériences pratiquées machine IDKONN mêmes bases montrent résultats similaires résultats détaillés tables courbes consultables ligne adresse lirmm laurent EGC10 deuxième tests concerne bases données complexité croissante fonction nombre attributs figures montrent respectivement diminution temps traitement accelérations obtenues bases lignes contenant attributs machine IDKONN IDKONN 10000 15000 20000 Bases lignes attributs minsupp Nombre threads exécution IDKONN Bases lignes attributs minsupp Nombre threads Accélération exécution accélération threads lignes IDKONN extraction parallèle efficace motifs graduels encore notre solution efficace problèmes suffisamment complexes puisque accélérations éloignées progression maximale théorique partir attributs IDKONN figures montrent respectivement temps exécu accélérations obtenues mêmes bases entre attributs machine COYOTE traitement attributs passe durée heures minutes séquentiel environ minutes secondes threads cette machine COYOTE Bases lignes attributs minsupp Nombre threads exécution COYOTE Bases lignes attributs minsupp Nombre threads Accélération exécution accélérations threads lignes COYOTE similarité résultats machines différentes architectures proces seurs hiérarchie mémoire différentes noter performances terme accélération sensibles spécificités architecturales plateforme mémoire caches Précisons enfin résultats traitement lignes attributs nécessairement pertinents cadre calculs massivement parallèles puisque temps exécution séquentiel environ secondes COYOTE avons tefois reportés montrer notre approche permet aussi situations obtenir accélérations sensibles Celles peuvent avérer déterminantes traitement blèmes fouille données temps quasi temps exemple détection intrusion manière générale fouille données arrivant flots stream mining puisqu alors traitement rapide arrivée données Limitations occupation mémoire principale difficulté genre problème reste maîtrise consommation moire grand nombre candidats traités éventuellement retenus chaque niveau exploration treillis titre illustration avons appliqué notre gramme dense lignes colonnes seuil support élevé avons trouvé environ millions itemsets fréquents niveau traitement 10000 premiers conduit création millions nouveaux fréquents niveau Selon rythme consommation mémoire 150Go mémoire auraient néces saires stocker itemsets fréquents niveau limitations bases données denses conduisent explorer autres architectures clusters notamment Laurent Conclusion Perspectives article proposons nouvelle approche extraction motifs règles graduels forme personne salaire élevé Notre approche basée utilisation multiples cœurs présents maintenant plupart ordina teurs serveurs maintenant accessibles Anciennement réservée domaines particuliers utilisation telles machines désormais courante important algorithmes fouille données puissent profiter mieux architectures expéri mentations menées montrent grand intérêt efficacité notre approche atteignant speed quasi linéaires problèmes difficiles réduisant considérablement temps calcul threads contre séquentiel perspectives associées travail nombreuses optimisations techniques optimisations selon différentes architectures allons particu intéresser trois pistes principales utilisation motifs graduels duire temps calcul algorithmes profondeur patterns growth utilisation autre parallélisation clusters compris clusters machines mutli processeurs multi cores Remerciements auteurs remercient Jorio avoir fourni sources implémentation recherche motifs règles graduels Jorio Références Agrawal Shafer Parallel mining association rules Trans Knowl Agrawal Srikant algorithms mining association rules Proceedings Conference Berzal Cubero Sanchez Serrano alternative approach discover gradual dependencies Journal Uncertainty Fuzziness Knowledge Based Systems IJUFKS Buehrer Parthasarathy Adaptive parallel graph mining architectures Jorio Laurent Teisseire extraction gradual association rules heuristic based method computing Transdisciplinary Science Technology CSTST Jorio Laurent Teisseire Mining frequent gradual itemsets large databases Intelligent Analysis Masseglia Laurent Teisseire Gradual trends fuzzy sequential patterns Information Processing Management Uncer tainty Knowledge based Systems Kamber Mining Concepts Techniques Morgan Kaufmann Series Management Systems Morgan Kaufmann Publishers Mining frequent patterns without candidate generation International Conference Management extraction parallèle efficace motifs graduels Hüllermeier Association rules expressing gradual dependencies European Principles Mining Knowledge Discovery Springer Verlag Laurent Lesot Rifqi Graank Exploiting correlations extrac gradual dependencies Zhang Optimization frequent itemset mining multiple processor Proceedings international conference large bases Endowment Lucchese Orlando Perego Parallel mining frequent closed patterns Harnessing modern computer architectures Pasquier Bastide Taouil Lakhal Efficient mining association rules using closed itemset lattices Information Systems Tatikonda Parthasarathy Mining structured multicore systems Proceedings international conference large bases Collaboration array bitmap prefix frequent itemset mining SIGKDD Source Mining Workshop Frequent Pattern Mining Implementations gspan Graph based substructure pattern mining International Conference Mining Computer Society Parallel sequence mining shared memory machines Large Scale Parallel Mining Parthasarathy Ogihara Parallel algorithms discovery association rules Knowl Discov Summary Gradual patterns older higher salary extensively fuzzy command systems currently crucial world applications where volumes complex numerical handled biological databases survey databases streams sensor readings recently algorithms appeared efficiently gradual patterns However complexity mining gradual rules these algorithms cannot scale world datasets paper propose exploit parallelism order enhance performances fastest existing GRITE Through detailed experimental study parallel algorithm scales number cores available