EGC2008 dviEchantillonnage extraction motifs séquentiels bases données statiques flots données Chedy Raïssi Pascal Poncelet LIRMM 34392 Montpellier Cedex France raissi lirmm LGI2P Scientifique Georges Besse 30035 Nîmes Cedex France prénom Résumé Depuis quelques années communauté fouille données ressée problématique extraction motifs séquentiels partir grandes bases données considérant comme hypothèse données pouvaient chargées mémoire centrale Cependant cette hypothèse lorsque bases manipulées volumineuses article étudions technique échantillonnage basée réservoirs montrons comment cette dernière particulièrement adaptée résumer volumes données intéressons ensuite problématique cente fouille données disponibles forme continu éventuellement infini stream étendons approche échantillon nouveau contexte montrons sommes extraire motifs séquentiels flots garantissant erreurs résultats différentes expérimentations menées confirment résultats théoriques Introduction problématique extraction motifs séquentiels grandes bases données intéresse communauté fouille données depuis dizaine années différentes thodes développées extraire séquences fréquentes extraction motifs toutefois tâche difficile espace recherche considéré grand gérer mieux espace recherche différentes stratégies proposées tradition nelles utilisent approche Apriori Srikant Agrawal diffèrent principalement structures données utilisées vecteurs arbres préfixés approches récentes considèrent quant elles projections multiples données selon principe pattern growth proposé évitent ainsi générer didats Outre différentes stratégies propositions efficaces considèrent comme hypothèse données chargée directement mémoire centrale Cepen développement nouvelles technologies dernières trouvent mises défaut mesure quantité données manipulées volumineuse devient irréaliste stocker intégralité mémoire centrale développement nouvelles technologies permet également générer grands volumes données issues différentes sources trafic transactions financières Echantillonnage extraction motifs séquentiels registrements médicaux capteurs données apparaissent alors forme stream manière continue rythme rapide éventuellement manière infinie traction connaissances partir flots récemment donné nombreux travaux recherche focalisés découverte itemsets fréquents Giannella Manku Motwani utilisant méthodes telles fenêtre glissante modèles pondérations temporelles travaux intéressés extraction motifs séquentiels flots données Raissi outre espace recherche approches traditionnelles nécessitent faire plusieurs passes stocker cette dernière mémoire reste article organisé manière suivante travaux extraction motifs séquentiels présentés section section introduisons formellement problème concepts préliminaires extraction motifs section présente échantillonnage cadre données statique résultats riques précision échantillon seuil erreur section étend résultats flots données présentant notre algorithme maintien synopsis expérimentations décrites section conclusion proposée section Travaux antérieurs Différentes approches efficaces extraction séquences proposées dernières années PrefixSpan SPADE Ayres PrefixSpan algorithme représentation motifs moyen arbre préfixé implémentation publique charge données mémoire centrale utilise différentes projections éviter générer candidats SPADE propose transformer données représentation verticale appliquer rapidement opérations jointure originalité réside représentation données forme bitmaps expérimentations montrent efficace PrefixSpan SPADE grandes bases données Cependant trois algorithmes défaut lorsqu essayent charger bases volumineuses ordre quelques gigaoctets volume données important croissant bases données statiques flots données impose nouvelles contraintes prendre compte algorithmes extraction devient acceptable obtenir réponses approxima tions Aggarwal autres termes devient indispensable trouver équilibre entre efficacité précision résultats nombreuses structures synopsis développées dernières années comme sketches échantillonnage wavelets histogrammes Toutes différentes structures possèdent mêmes propriétés grandes applicabilités elles peuvent utilisées répondre divers problèmes efficacité moire elles capables résumer manière significative grandes quantité données robustesse outre toutes méthodes nécessitent passe particulièrement utiles flots données travaux avons menés sommes focalisés classes échantillonnage servoir mesure elles aisées mettre œuvre garantissent échantillon représentatif bonne qualité Cette approche initialement introduite Vitter principe suivant maintenons réservoir taille premiers points ensemble données stockés étape initialisation Lorsque Raïssi Poncelet Client Items données exemple point traité remplace aléatoirement points réservoir probabilité Ainsi taille ensemble données augmente probabilité inclusion réduit entendu inconvénient majeur flots données considèrent souvent informations récentes pertinentes Giannella solution répondre problème utiliser fonctions biaisées réguler échantillon données Aggarwal Concepts préliminaires cette section présentons problématique extraction motifs séquentiels Srikant Agrawal Srikant ainsi principe échantillonnage réservoir biaisé transaction constitue client ensemble items achetés transaction écrit forme ensemble triplet client itemset itemset ensemble items séquence liste ordonnée itemsets notée itemset séquence données séquence représentant achats client transactions client ordonnées dates achat croissantes itemset ensemble items correspondant alors séquence données client itemset itemset itemset client supporte séquence incluse séquence données client support séquence Support représente pourcentage clients supportent seuil support minimal défini utilisateur problème extraction motifs séquentiels consiste extraire toutes séquences telles Support Exemple Considérons données figure support minimum séquences fréquentes suivantes échantillonnage réservoir biaisé introduit Aggarwal principale réguler introduction points réservoir maîtriser fraîcheur échantillon produit autres termes fonction biais permet moduler échantillon manière focaliser comportements récents anciens fonction contraintes application fonction biais définie manière suivante paramètre correspond biais Cette fonction proportionnelle probabilité point introduit réservoir instant encore présent instant outre inclusion fonction biais exponentielle possible utilisation algorithmes remplacement simples surtout cette classe spéciale fonctions biais Echantillonnage extraction motifs séquentiels implique aussi borne supérieure taille réservoir indépendante gueur longueur taille maximale réservoir satisfait fonction biais exponentielle avons Echantillonnage données statique Etant donné facteurs extraction taille considérée intuition jacente algorithme extraction pourrait lancé échantillon données originale avoir résultats manière rapide facile première question laquelle devons répondre voulons extraire motifs partir échantillon point échantillon pertinent rapport données original répondons cette question exhibant garantie erreur support séquence Notons approche similaire proposée extraction itemsets fréquents Toivonen Définition erreur données transactionnelle clients échantillon aléatoire généré partir séquence présente dansD erreur absolu terme estimation support défini Support Support Posons variable aléatoire indépendante définie telle client supporte séquence sinon représente nombre clients supportant séquence présents échan tillon clients peuvent réécrits manière suivante Support espérance variable Support voulons estimer probabilité erreur dépasse seuil défini utilisateur répondre cette estimation utilisons méthode connue statistiques inégalités concentration précisément inégalités Hoeffding Hoeffding permettent borner valeur réelle variable aléatoire rapport espérance terme erreur théorème suivant exhibe borne inférieure taille échantillon réservoir Théorème séquence taille réservoir alors Preuve Support Support Support Support Raïssi Poncelet inégalité Hoeffding énonce variables aléatoires indépendantes alors 2n2t2 2n2t2 somme variables noter inégalités Hoeffding souvent considérées comme générales moins précises inégalités concentration Chernoff choix variables aléatoires indépendantes intervalle donne résultats similaires inégalités remarquer taille échantillon indépendante taille données initiale reste conditionnée uniquement table illustre quelques exemples tailles échantillons termes clients différentes valeurs noter lorsque valeurs strictes échantillon atteindre taille assez importante 26492 38005 49518 3333333 Différentes tailles échantillons donnés Motifs séquentiels échantillonnage flots données problèmes majeurs pratique échantillonnage difficile flots avance taille développer algorithmes échantillonnages dynamiques prennent compte évolution changements distribution données transitant cette section étendons résultats précédents présentons algorithme maintien échantillon biaisé manière dynamique prend compte différentes évolutions données algorithme présenté comme étape traitement nécessaire permettre extrac séquences fréquentes cette étape traitement pertinente respecter conditions suivantes échantillon avoir borne inférieure taille minimiser erreur absolu terme estimation support cause nature séquences opérations insertions enlèvements nécessaires échantillon doivent faire niveau clients aussi leurs itemsets convaincre suffit considérer ensemble clients chacun grand nombre itemsets rajoutent chaque instant ensemble considéré comme échantillon réservoir borné augmenter notre modèle données point données apparaissant chaque instant défini comme couple constitué identifiant client transaction Echantillonnage extraction motifs séquentiels Partant contraintes résultats théoriques obtenus section posons algorithme simple remplacement approche réservoir biaisé proposé Aggarwal permet réguler échantillonnage transactions clients grâce fonction biaisage temporelle exponentielle suivante commençons réservoir capacité maximale discutons valeur biais chaque itemset client apparaissant inséré manière probabiliste réservoir après opération lancer pièce remplacement itemsets client présent réservoir ajout direct places encore vacantes Comme discuté précédemment devons aussi contrôler taille réservoir terme nombre clients nombre itemsets Cette opération contrôle appliquée grâce approche fenêtre glissante Aggarwal Widom permet garder uniquement itemsets récents client donné réservoir fenêtre glissante définie comme fenêtre basée séquences taille contenant points récents apparus comme fenêtre basée intervalle temps taille contenant points apparus durée temps notre approche utilisons fenêtres glissantes basées séquences garder uniquement transactions récentes clients présents échantillon fenêtre glissante permet extraction séquences horizon récent fonction exponentielle biais permet utilisateur choisir taille réservoir contraintes approximation ainsi échantillon représentatif construit mémoire selon besoins application utilisateur corollaire suivant théorème exhibe existe entre biais seuils erreurs Corollaire Soient seuil erreur probabilité maximale telle alors Preuve après Aggarwal taille supposons taille possible réservoir satisfait fonction biaisage exponentielle alors définition considérons réservoir entier comme échantillon cible extraction motifs substitution théorème avons résultat énoncé table montre quelques valeurs biaisage taille minimale réservoir nécessaire bonne approximation support séquences 0000377 26492 00002631 38005 00002019 49518 Différents biaisage différentes valeurs fonctionnement général algorithme suivant arrivée itemset client client liste noire auquel ignorer itemset sinon passer étape Raïssi Poncelet client réservoir rajouter itemset fenêtre décalage nécessaire faire sinon passer étape Faire lancer pièce aléatoire succès remplacer clients présent réservoir manière aléatoire client remplacé alors liste noire échec rajouter client itemset réservoir remplacer partie importante algorithme gestion décalages fenêtres glissantes liste noire problème apparaître étape remplacement clients présents réservoir devons détecter client était présent réservoir réintroduire aucun préalable rendrait résultats extraction motifs séquentiels inconsistants réalité problème consistance apparaît lorsqu client remplacé autre revient réservoir instant suivant moment extraction client itemsets avoir fenêtre glissante actuelle points certains clients doivent ignorés autre ignorer points introduire nouveau biais puisque seuls clients ayant remplacé autres clients seront présents échantillon résoudre problème inconsistance entre itemsets différents clients introdui système liste noire permet interdire échantillonnage certain nombre clients indésirables Cette liste noire irréversible réactualisée chaque glisse fenêtre Algorithme Algorithme échantillonnage réservoir extraction motifs séquentiels Réservoir Taille réservoir Nombre clients présents réservoir Taille fenêtre glissante point Result Réservoir après traitement point begin1 liste noire2 then3 then4 Insertion lancer5 Random then7 Random Replace else9 else11 Insertion directe12 Insert window then14 slideAllWindows Update end17 Echantillonnage extraction motifs séquentiels Notons algorithme facilement implémenté Cependant avons supposé implicitement algorithme construisait réservoir biaisé respectant fonction biaisage exponentielle paramètre allons maintenant présenter preuve formelle cette proposition Comme Aggarwal démontrer politique remplacement appliquée notre algorithme permet construire réservoir biaisé taille Proposition algorithme construit réservoir biaisé respectant fonction biaisage temporel Preuve Soient nombre total clients nombre points insérés réservoir instant taille liste noire instant Posons nombre possible points échantillon probabilité client arrivant liste noire probabilité client réservoir probabilité lancer pièce succès après appartenance liste noire probabilité lancer fructueux probabilité point réservoir éjecté instant donné probabilité point encore instant donné réservoir alors étape algorithme sachant devons calculer toutes combinaisons possibles probabilité client inséré instant encore réservoir instant grandes valeurs grandes valeurs approximativement substitution équation avons résultat énoncé Expérimentations Items Taille trans Trans Client Clients Taille CL1MTR2 5SL50IT10K 10000 1000000 CL1MTR10SL20IT10K 10000 1000000 5MTR20SL20IT10K 10000 500000 CL6MTR2 5SL10IT20K 20000 6000000 Différents données synthétiques utilisés experimentations Raïssi Poncelet motifs extraits Support Traitement Mémoire CL1MTR10SL20IT10K 5MTR20SL20IT10K CL6MTR2 5SL10IT20K Résultats extraction motifs données statiques 5MTR20SL20IT10K motifs Erreurs Temps requis Mémoire requise Taille échantillon 25000 38005 50000 100000 200000 CL1MTR10SL20IT10K motifs Erreurs Temps requis Mémoire requise Taille échantillon 25000 38005 50000 100000 200000 CL6MTR2 5SL10IT20K motifs Erreurs Temps requis Mémoire requise Taille échantillon 25000 38005 50000 100000 500000 Résultats extractions différents données statiques Toutes expérimentations lancées ordinateur MacBookPro mémoire tournant algorithmes codés langage programmation comparer résultats utilisons implémentation PrefixSpan1 permet extraction motifs séquentiels tests lancés plusieurs données synthétiques générés logiciel QUEST1 différents données utilisés expérimentations leurs caractéristiques regroupés tableau échantillonner bases données statiques avons implémenté algorithme échantillonnage réservoir Vitter avons testé pertinence calculs théoriques échantillonnage bases données statiques section avons utilisé expérimentations données CL6MTR2 5SL10IT20K CL1MTR10SL20IT10K 5MTR20SL20IT10K comparer résultats estimations approximation théorème résul différentes expérimentations listés tableaux avons construit échantillons différentes tailles allant 25000 500000 clients utilisant approche échantillonnage réservoir expérimentations répétées chaque échantillon valeurs présentées moyennes résultats colonne Erreur illimine almaden projects Projects data_mining datasets syndata Echantillonnage extraction motifs séquentiels 20000 40000 60000 80000 100000 120000 Seconds Taille réservoir terme clients Seconds Taille liste noire terme clients 40000 60000 80000 100000 120000 140000 160000 180000 200000 220000 240000 260000 Seconds Taille réservoir terme clients Seconds Taille liste noire terme clients Expérimentations données CL1MTR2 5SL50IT10K 00001 00004 19000 20000 21000 22000 23000 24000 25000 26000 27000 Seconds 00001 10000 12000 14000 16000 Seconds 00004 Besoin mémoire données CL1MTR2 5SL50IT10K Raïssi Poncelet tableaux décrit nombre séquences extraites support dépasse appro ximations remarque échantillonnage bases données statiques reste précis comme présenté résultats théoriques section petites tailles résumés temps extraction motifs utilisation mémoire processus diminué plusieurs ordres magnitudes permet pousser processus global extraction supports expérimentation flots données utilise données CL1MTR2 5SL50IT10K faisant varier différents paramètres valeurs biais taille fenêtre glissante expérimentations mettons valeur efficacité échantillonnage trons empiriquement liste noire reste bornée temps figure montre liste noire garante consistence échantillon processus extraction motifs reste assez limitée terme espace mémoire utilisé grâce différentes mises jours faites chaque décalage fenêtres glissantes clients présents réservoir taille fenêtre glissante petite liste noire petite aussi fréquents décalages permettent mettre clients ignorés réservoir figure montre réservoir remplit étape extraction motifs séquentiels lancé partir 50eme seconde comme figure réservoir reste borné stable terme occupation mémoire Conclusion article sommes intéressés nouvelles techniques résumés représenter bases données motifs séquentiels avons montré approche basée échantillons était adaptée bases données statiques étions capables maîtriser erreur résultats extraction motifs séquentiels notre connaissance travail premier utiliser techniques échan tillonnage extraire motifs séquentiels bases données avons égale montré approche échantillonnage basée réservoirs pouvait adapté contexte flots données avons proposé algorithme remplacement éléments réservoir permet réguler échantillonnage transactions clients fonction biaisage temporelle exponentielle avons précédemment approches extraction motifs flots néces sitent raisons capacités mémoire supprimer connaissances acquises lablement exemple séquence fréquente petit intervalle temps travers notre approche besoin exécuter algorithme extraction continu plutôt demande fournir décideur toute connaissance extraite garantissant marge erreur perspectives associées travaux nombreuses premier temps souhaitons offrir possibilité stocker évolutions réservoir étapes extraction connaissances déterminer tendances souhaitons étendre notion tilted window intro duite Giannella stocker variations fréquences toutes fréquences motifs agrégées intervalle temps second temps souhaitons intégrer cette approche outil complet suivi flots données mettant ainsi pouvoir effectuer seulement extraction aussi requêtes données Echantillonnage extraction motifs séquentiels Références Aggarwal Streams Models Algorithms Springer Aggarwal biased reservoir sampling presence stream evolution Ayres Flannick Gehrke Sequential pattern mining using bitmap representation Widom Continuous queries streams SIGMOD Record Muntz Moment Maintaining closed frequent itemsets stream sliding window Giannella Mining frequent patterns streams multiple granularities Generation Mining Press Hoeffding Probability inequalities bounded random variables Journal American Statistical Association Manku Motwani Approximate frequency counts streams Prefixspan Mining sequential patterns efficiently prefix projected pattern growth Raissi Poncelet Teisseire Speed Mining maximal sequential patterns streams Srikant Agrawal Mining sequential patterns Generalizations perfor mance improvements Srikant Mining sequential patterns Toivonen Sampling large databases association rules Vitter Random sampling reservoir Trans Softw Spade efficient algorithm mining frequent sequences Machine Learning Summary Sequential pattern mining active field domain knowledge discovery Since database influential factor mining algorithms examine sampling static databases approximate mining results upper bound error Moreover extend these sampling analysis present algorithm based reservoir sampling sequential pattern mining streams demonstrate empirical results sampling methods efficient sequence mining mains accurate static databases streams