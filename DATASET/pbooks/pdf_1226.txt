dviIntégration efficace méthodes fouille données Cédric Udréa Fadila Bentayeb Jérôme Darmont Boussaid Université Lumière avenue Pierre Mendès France 69676 Cedex France cudrea bentayeb jdarmont boussaid lyon2 Résumé article présente nouvelle approche permettant appli algorithmes fouille particulier apprentissage supervisé grandes bases données temps traitement acceptables objectif atteint intégrant algorithmes Ainsi sommes limités taille disque celle mémoire Cependant entrées sorties nécessaires accéder engendrent temps traitement longs proposons article méthode originale réduire taille apprentissage construisant table contingence algorithmes apprentissage alors adaptés appliquer table contin gence valider notre approche avons implémenté méthode construction arbre décision montré utilisation table contingence permet obtenir temps traitements équiva lents logiciels classiques Intégration Bases données Fouille données Arbres décision relationnelles Table contingence Apprentissage super Performance Introduction application opérateurs fouille données grandes bases données enjeu intéressant Cependant algorithmes fouille données peuvent opérer structures mémoire tableau attributs valeurs limite taille bases traiter méthodes classiques fouille données utilisent méthodes traitement données telles sélection variables Motoda échantillonnage Chauchat appliquer algorithmes fouille données grandes bases nouvelles voies recherche apparues dernières années Elles consistent intégrer méthodes fouille Systèmes Gestion Bases Données Chaudhuri premières avancées domaine intégra méthodes analyse données amorcée avènement entrepôts données analyse ligne particulier autres travaux recherche concerné intégration méthodes règles ciation généralisation Sarawagi revanche existe travaux intégration méthodes classiques fouille Intégration efficace méthodes fouille données analyse données telles regroupement classification effet domaine plupart travaux concernent plutôt application méthodes fouille grandes bases données Agrawal Gehrke Néanmoins plupart éditeurs logiciels leurs méthodes fouille données Microsoft Oracle pendant cette intégration présente forme boîtes noires réalisées grâce extensions nécessitant utilisation interfaces programmations pourquoi avons proposé Bentayeb Darmont approche intégration méthodes fouille données arbre décision lisant outils offerts précisément avons implémenté méthode Oracle forme procédure stockée utilisant relationnelles cette approche avons montré possible traiter grandes bases données limitation taille Cependant temps traitement demeurent longs raison accès multiples améliorer temps traitements préparation données processus fouille devient cruciale proposons article méthode originale atteindre objectif construire table contingence table populations agrégées taille beaucoup réduite appren tissage départ avons ensuite adapté méthodes fouille données elles puissent appliquer table contingence obtenue actuel connaissances aucune méthode fouille données utilise telle méthode préparation données illustrer valider notre approche avons adapté implémentation appliquer table contingence obtenue partir apprentis départ montrons utilisation table contingence permet nettes améliorations termes temps traitement rapport notre première implémentation temps traitement équivalents logiciels classiques article organisé façon suivante Section présente principe notre approche intégration méthodes fouille données arbres décision particulier intégration méthode Oracle Section expose principe notre approche utilisant phase préparation données basée construction table contingence Section présente résultats expérimentaux étude complexité valident notre approche Section conclut article expose perspectives recherche Intégration méthodes construction arbres décision Principe arbres décision outils apprentissage produisent règles alors Zighed Rakotomalala utilisent entrée ensemble objets uplets décrits variables attributs Chaque objet appartient classe classes étant mutuellement exclusives construire arbre décision UDREA nécessaire disposer population apprentissage table consti objets classe connue processus apprentissage consiste ensuite déterminer classe objet quelconque après valeur variables méthodes construction arbres décision segmentent population prentissage obtenir groupes desquels effectif classe Cette segmentation ensuite réappliquée façon récursive partitions obtenues recherche meilleure partition segmentation noeud revient rechercher variable discriminante classes ainsi arbre généralement graphe constitué Finalement règles décision obtenues suivant chemins partant racine arbre population entière jusqu feuilles populations desquelles classe représente majorité objets Figure montre exemple arbre décision ainsi règles associées Classe représente probabilité objet appartenir Classe numéro Classe Classe Classe Classe Classe Classe Classe Classe Classe Classe Règle alors Classe Règle alors Classe Règle alors Classe Noeud Noeud Noeud Noeud Noeud Exemple arbre décision pouvoir appliquer méthodes fouille données bases volumi neuses nouvelles voies recherche consiste intégrer méthodes étant utiliser uniquement outils offerts derniers approche présentée Bentayeb Darmont racine arbre décision représentée relationnelle correspond population apprentissage entière Comme chaque noeud arbre décision représente population noeud parent associons chaque noeud construite partir parente ensuite utilisées dénombrer effectifs chaque classe noeud comptages servent finalement déterminer critère partition nement noeuds partitions conclure noeud feuille Figure présente titre exemple commandes permettant créer associées arbre décision Figure Entropie information algorithme Induction Decision Quinlan pouvoir discri minant variable segmentation noeud exprimé variation entropie entropie noeud présisément entropie Shannon Intégration efficace méthodes fouille données Noeud CREATE SELECT class training_set Noeud CREATE SELECT class WHERE Noeud CREATE SELECT class WHERE Noeud CREATE SELECT class WHERE Noeud CREATE SELECT class WHERE relationnelles associées arbre décision exemple effectif nombre objets appartiennent classe cardinalité classe information portée partition noeuds alors moyenne pondérée entropies effectif noeud segmenté Finalement informationnel associé Comme toujours positif processus construction arbre décision revient heuristique maximisation chaque itération sélection variable correspondante segmenter noeud donné rithme arrête lorsque devient inférieur seuil minimum défini utilisateur Discussion avantage intégrer méthodes fouille données bénéficier puissance niveau accès données persistantes effet logiciels fouille classiques nécessitent charger données mémoire traiter limités niveau quantité données analysables illustré Figure représente temps construction arbre décision taille augmente logiciels fouille classiques occurrence SIPINA Zighed Rakotomalala configuré utiliser méthode autre notre implémentation Oracle baptisée Buildtree tests effectués ordinateur disposant mémoire cette configuration SIPINA traiter bases taille dépasse résultat montre travaux permettent continuer traiter bases données grande taille logiciels travaillant mémoire peuvent UDREA Taille Sipina Buildtree Temps traitement fonction taille opérer Cependant résultats terme taille bases traiter promet teurs temps traitements demeurent longs temps calcul généralement considéré comme point critique processus fouille données néanmoins nécessaire réduire maximum ailleurs périence Figure oeuvre données nombre uplets augmente schématisant complexité algorithmes construction arbres décision linéaire selon nombre objets uplets exponentielle selon nombre variables attributs primordial optimiser temps traitement algorithmes fouille fonctionnant obtenir temps réponse acceptables Utilisation table contingence Principe améliorer temps traitement méthodes fouille données grées proposons réduire taille apprentissage calculant table contingence algorithmes fouille données seront ainsi appliqués cette dernière algorithmes construction arbres décision procèdent manière récursive chaque noeud déterminer variable prédictive apportant meilleur information Ainsi chaque noeud mêmes opérations noeud effectuées collection uplets restreinte chaque opérations consiste déterminer chaque valeur classe nombre total uplets chacune valeurs chaque attribut prédictif cette façon procéder entraîne plusieurs lectures chaque uplet puisque ensemble uplets noeuds correspond uplets chaque compte uplets ensemble collection associée conséquent lectures multiples induisent supplémentaire alors définitive nombre uplets similaires significatif uplets mêmes construction noeud consiste écrire population uplets Intégration efficace méthodes fouille données correspondant diminuée attribut écrire nouveau uplets Construction table contingence contexte méthodes fouille intégrées table contingence obtenue simple requête utilisant regroupement fonction agrégat Count appliquée table départ attribut supplé mentaire appelé Population naturellement obtenu représenter effectif obtenu chaque uplets table contingence nombre uplets table contingence inférieur nombre uplets départ terme temps traitement important manière générale apprentissage définie attributs prédictifs attribut prédire table contingence obtenue simple requête Figure CREATE Contingence SELECT COUNT Population GROUP relationnelle associée table Contingence Exemple TITANIC illustrons notre approche utilisant apprentissage TITANIC comporte trois attributs prédictifs Classe 2ième 3ième Equipage Adulte Enfant Homme Femme ainsi classe prédire Survivant population totale individus titre exemple Bentayeb Darmont application méthode intégrée Oracle Buildtree cette apprentissage consiste créer succession partitions départ individus formeront arbre décision construisant table contingence TITANIC méthode appliquer nombre individus beaucoup réduit effet table contingence obtenue contient uplets Figure requête correspondant présentée Figure CREATE Contingence SELECT Classe Survivant COUNT Population TITANIC GROUP Classe Survivant relationnelle associée table Contingence Exemple Titanic Calcul information entropie démontrer pertinence efficacité notre approche avons implé menté nouveau méthode tenant compte phase préparation UDREA Classe Survivant Population Adulte Homme Adulte Homme Adulte Femme Adulte Femme Enfant Homme Enfant Femme 2ième Adulte Homme 2ième Adulte Homme 2ième Adulte Femme 2ième Adulte Femme 2ième Enfant Homme 2ième Enfant Femme 3ième Adulte Homme 3ième Adulte Homme 3ième Adulte Femme 3ième Adulte Femme 3ième Enfant Homme 3ième Enfant Homme 3ième Enfant Femme 3ième Enfant Femme Equipage Adulte Homme Equipage Adulte Homme Equipage Adulte Femme Equipage Adulte Femme Table contingence TITANIC données véritable différence situe calcul information chaque attribut prédictif conséquent calcul entropie implémentations algorithme standard contraintes calculer information attribut prédictif uplets partie départ correspondant noeud courant arbre induction déterminer répartition uplets fonction chaque valeur attribut prédictif chaque valeur classe notre approche connaître effectif population noeud obtenu partir ensemble critères Enfant Femme exemple suffit effectuer somme valeurs attribut Population table contingence uplets satisfaisant Cette technique beaucoup rapide applique nombre restreint uplets Enfin modifiant manière calculer devient possible effectuer seule lecture connaître information attribut prédictif effet comme avons section calcul normal attribut Intégration efficace méthodes fouille données ayant valeurs possibles classe ayant valeurs possibles entropie noeud effectif noeud ayant valeur attribut prédictif effectif population noeud effectif noeud ayant valeur attribut prédictif valeur classe développant obtient entropie noeud étant log2a log2b obtient après entropie noeud log2nik log2nk développant obtient entropie noeud log2nik log2nk log2nk log2nk après entropie noeud log2nik log2nk appliquant Formule table contingence lisons seule unique obtenons facilement effet cette formule nécessaire connaître moment différents effectifs obtient somme somme Implémentation implémentation méthode table contingence effectuée compatible Oracle Oracle forme procédure stockée nommée TC_ID3 package procédures nommé decision_tree adaptation algorithme calcul entropie infor mation nécessaire puisse appliquer table contingence lyon2 download decision_tree UDREA Résultats complexité Résultats expérimentaux valider notre approche comparer performances aussi méthodes fouille classiques méthode intégrée Buildtree basée relationnelles avons effectué tests TITANIC schéma donné section comporte uplets trois attributs prédictifs attribut prédire avons comparé temps traitements méthode appliquée TITANIC préparation données BuildTree utilisant relationnelles nouvelle version TC_ID3 appliquée table contingence tests effectués environnement matériel ordinateur disposant mémoire version Oracle Oracle essai TITANIC résultats obtenus montrent efficacité notre approche rapport méthode Buildtree puisque temps traitement divisé avons comparé temps traitements TC_ID3 pouvons observer grâce application table contin gence associée TITANIC temps traitement notre approche laire celui méthodes classiques Figure Temps traitement fonction taille apportons preuve efficacité notre approche puisque façon nérale celle réduit considérablement taille apprentissage Néanmoins extrêmes arriver taille table contingence proche celle départ devient infime restant toutefois pratique rares utilisation table contingence cadre intégration méthodes fouille améliore considérablement temps traitement lyon2 ricco sipina Intégration efficace méthodes fouille données Etude complexité étude complexité suivante permet appuyer résultats expérimentaux obtenus Soient nombre uplets départ nombre attri prédictifs taille table contigence Notre objectif comparer complexité entre algorithme relationnelles Buildtree celui utilisant table contingence TC_ID3 considérons algorithmes optimisés implémentation telle sorte seuls uplets nécessaires cette étude intéressons temps passé lecture écriture données opérations coûteuses considérons uplet écrit unité temps Enfin considérons arbre décision obtenu équilibré complet chaque niveau arbre union populations différents noeuds niveau équivaut toute entière algorithme relationnelles niveau quelconque arbre aboutir niveau chaque noeud autant existe tributs prédictifs niveau Comme somme populations noeuds niveau correspond population départ nécessaire uplets autrement nombre uplets nombre attri candidats temps total lecture niveau obtenir niveau fallu écrire uplets correspondants temps écriture rappelant obtenons alors complexité finale racine jusqu feuilles niveau égale lecture unités temps écriture unités temps notre approche convient abord créer table contingence temps écriture obtenir convient intégralement départ première temps lecture chaque niveau aboutir niveau intégralité uplets temps chaque niveau création table contingence résultats lecture unités temps écriture unités temps Ainsi temps traitement notre approche apporte amélioration lecture écriture Comme normalement supérieur cette amélioration importante augmente nombre attributs Conclusion Perspectives avantage majeur intégrer méthodes fouille données pouvoir traiter grandes bases données grâce puissance niveau accès données persistantes Cependant processus fouille données UDREA engendre nombreuses entrées sorties ralentissent considérablement temps traitement remédier problème avons proposé article méthode originale préparation données construire table contingence table populations agrégées biais requête réduit considérablement taille table apprentissage départ valider notre approche avons implémenté méthode construction arbre décision algorithme adapté table contingence forme procédure stockée nommée TC_ID3 Ainsi avons montré utilisation table contingence permet nettes améliorations termes temps traitement rapport méthodes fouille classiques méthode intégrée Buildtree TC_ID3 présente résultats similaires terme temps traitement comparée méthodes fouille classiques opérant mémoire enrichir notre package decision_tree sommes train implémen autres méthodes fouille données telles utilisant table contingence ailleurs envisageons comparer performances TC_ID3 SIPINA grandes bases données réelles classiquement employées communauté apprentissage autres tests autres bases actuelle cours tests objectif déterminer empiriquement temps quand nombre attributs augmente quand nombre uplets mente prévoyons intégration package decision_tree autres procédures compléter outils fouille données offerts comme échantillon gestion valeurs manquantes validation Références Agrawal Agrawal Mannila Srikant Toivonen Verkamo discovery association rules Advances Kowledge Discovery Mining pages Bentayeb Darmont Bentayeb Darmont Decision modeling relational views XIIIth International Symposium Methodologies Intelli Systems ISMIS France volume pages Heidelberg Germany Springer Verlag Chauchat Chauchat Echantillonnage validation généralisation traction connaissances partir données Mémoire habilitation diriger recherches Université Lumière France Janvier Chaudhuri Chaudhuri mining database systems Where intersection Engineering Bulletin Providing analytical processing analysts mandate Technical report Associates Gehrke Gehrke Ramakrishnan Ganti Rainforest mework decision construction large datasets International Conference Large Bases pages Morgan Kaufmann Intégration efficace méthodes fouille données intelligent miner scoring software iminer scoring Motoda Motoda Feature Selection knowledge discovery mining Kluwer Academic Publishers Psaila operator mining association rules International Conference Large Bases Mumbai India pages Morgan Kaufmann Microsoft Microsoft Introduction mining microsoft oledb Oracle Oracle Oracle mining White paper Quinlan Quinlan Induction decision trees Machine Learning Sarawagi Sarawagi Thomas Agrawal Integrating mining relational database systems Alternatives implications SIGMOD ternational Conference Management SIGMOD Seattle pages Press Performance study microsoft mining algorithms Technical report Microsoft Zighed Rakotomalala Zighed Rakotomalala Sipina guide Technical report laboratory University France Zighed Rakotomalala Zighed Rakotomalala Graphes induc Apprentissage Mining Summary propose paper approach applying mining algorithms particularly supervised machine learning algorithms large databases acceptable response times achieved integrating these algorithms within limited capacity available memory However necessary access database induce response times Hence propose paper original method reduce learning building contingency table machine learning algorithms adapted operate contingency table order validate approach implemented decision construction method showed using contingency table helped obtaining response times equivalent those classical software Keywords Integration Databases mining Decision trees relational views Contingency table Supervised machine learning Performance