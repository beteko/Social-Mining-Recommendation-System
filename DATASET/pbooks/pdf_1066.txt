Recherche structures fréquentes intégration schémas Federico López Laurent Pascal Poncelet Maguelonne Teisseire LIRMM Université Montpellier 34392 Montpellier cedex delrazo laurent teisseire lirmm LGI2P EERIE Georges Besse 30035 Nîmes cedex Pascal Poncelet Résumé recherche schéma médiateur partir ensemble problématique actuelle résultats recherche issus fouille données arborescentes peuvent adoptés contexte plusieurs propositions réalisées méthodes représentation arborescences souvent coûteuses permettre véritable passage échelle article proposons algorithmes recherche schémas fréquents basés méthode originale représentation schémas décrivons brièvement structure adoptée ensuite détailler algorithmes recherche arbres fréquents appuyant telle structure représentation proposée algorithmes associés évalués différentes bases synthétiques schémas montrant ainsi intérêt approche proposée Introduction Étant donné explosion volume données disponibles Internet devient indispen sable proposer nouvelles approches faciliter interrogation grandes masses information retrouver informations souhaitées conditions permettre interroger données hétérogènes disposer plusieurs schéma général utilisateur pourra interroger partir duquel données sources directement accédées Malheureusement utilisateurs disposent moyen connaître modèles jacents données souhaitent accéder challenges contexte fournir outils extraire manière automatique médiateurs schéma médiateur alors considéré comme interface permettant utilisateur interrogation sources données utilisateur requêtes manière transparente tenir compte hétérogénéité répartition données étant maintenant prépondérant Internet recherche moyens intégration schémas domaine recherche actif recherches permettant accès données quand schéma interrogation connu maintenant avancées Xylème recherches concernant définition automatique schéma médiateur restent complètes satisfaisantes Tranier alors intéressant considérer Recherche structures fréquentes intégration schémas travaux réalisés contexte fouille données obtenir schéma fréquent ensemble schémas fréquents derniers offrent alors éléments pertinents construction schéma médiateur proposer approche permettant pondre cette dernière problématique focalisons recherche structures fréquentes données schémas structure fréquente arbre trouvant plupart schémas considérés Cette proportion examinée support correspond nombre minimal arbres lesquels arbre retrouver considéré comme fréquent telle recherche complexe mesure nécessaire traduire ensemble structure aisément manipulable Cette transformation données conduit parfois doubler tripler taille initiale souhaite utiliser propriétés spécifiques permettant améliorer processus fouille existe solution efficace problème alliant représentation compacte propriétés intéressantes objet article définition approche fouille données répondant objectif article structuré manière suivante section introduit définitions différentes inclusions contexte structures hiérarchiques propose aperçu principales approches existantes fouille données arborescente présentons égale détail problématique étudiée section présente notre proposition méthode recherche schémas fréquents utilisant propriétés structure données arborescentes compacte originale différentes expérimentations menées bases schémas décrites section Enfin section conclut présente principales perspectives associées travaux Définitions problématique travaux connexes Définitions préliminaires arbre graphe orienté connexe cycle composé ensemble nœuds reliés existe particulier nommé racine arbre ordonné existe ordre entre arbre ordonné sinon Définition arbre enraciné étiqueté ordonné ensemble nœuds ensemble branches Chaque branche couple ordonné nœuds ensemble étiquettes fonction racine relation ordre entre chaque interne taille notée nombre nœuds Lorsque manipulerons plusieurs arbres noterons arbre suite article utilisons arbre arbre enraciné étiqueté ordonné Définition inclusion Soient arbres disons inclu arbre existe fonction injective nœuds nœuds vérifie conditions suivantes préserve étiquettes préserve relation ordre entre frères alors préserve relations parenté alors ancestralité alors inclusion induite relations parenté préservées ailleurs relations ancestralité respectées inclusion incrustée Exemple arbres inclusion induite incrustée exemple considérons arbres représentés figure relations parenté respectées inclusion induite inclus manière induite arbre relations ancestralité conservées alors trouve inclusion incrustée inclu préserve ordre entre frères suite article considérons inclusion induite haitons traiter ordre existant entre nœuds hiérarchie façon directe ordre entre nœuds niveau façon indirecte pouvons définir support arbre selon cette inclusion manière suivante Définition support forêt arbres arbre support minimal spécifié utilisateur support défini Support nombre arbres incluant inclusion induite nombre arbres Support alors arbre fréquent Problématique problématique étudiée article recherche structures quentes arbres apparaissent suffisamment fréquemment documents considérons suite étape initiale traitement réalisée documents manière retenir structure forme arbre consi dérons également issue cette phase étiquetage nœuds homogène nœuds étiquette arbres différents partagent seulement syntaxe également sémantique objectif consiste alors rechercher partir forêt arbres obtenue fonction support minimal spécifié utilisateur arbres apparaissent suffisamment fréquemment nombre occurrences supérieur support Recherche structures fréquentes intégration schémas minimal répondre cette problématique trouvons confrontés problèmes suivants Quelle structure représentation efficace utiliser Idéalement étant donné considérons grandes quantités arbres souhaitons avoir structure seulement efficace mémoire également adaptée traitements souhaitons faire Comment tester efficacement inclusion arbre arbre Rechercher ensemble arbres fréquents nécessite parcourir arbres effectuer nombreuses comparaisons réussir extraire parties communes indispensable pouvoir trouver rapidement partir compa raison effectuée souhaitons améliorer efficacité recherche travaux existants cette partie intéressons seulement approches recherche examinons également méthodes représentation arbres travaux domaine fouille données arborescentes peuvent distingués selon traitent arbres ordonnés situant contexte schémas avère nécessaire traiter ordre éléments celui spécifié focaliserons propositions prenant charge arbres ordonnés notre connaissance existe travaux proposant méthodes extraction arbres ordonnés Ainsi propose rithme TreeMiner extraire arbres fréquents selon inclusion incrustée représentation originale arbres facilite gestion candidats offre performances intéressantes traitent également problématique arbres ordonnés selon définition inclusion induite approche proposée FREQT adopte structure représentation first child sibling comme illustrée figure proces fouille chaque structure fréquente FREQT conserve liste nœuds droite arbres données supportant cette structure illustrons figure fréquent positions données stockées fréquent positions droite stockées Cette information représente positions cette structure supportée examinons attentivement représentation verticale adoptée TreeMiner aboutit stocker trois taille arbre manière structure utilisée FREQT offre performances attractives cette représentation conduit également tripler taille stocker informations nécessaires elles abordent problématique approches représentation efficaces arbres récemment proposées Cependant outre elles considèrent notion ordre elles utilisent propriétés aussi intéressantes travaux précédents améliorer processus extraction Notre objectif permettre recherche arbres ordonnés contrai rement approches existantes contexte utiliser représentation coûteuse mémoire Cette structure outre posséder propriétés intéressantes Représentation first child sibling 4next first FREQT représentation arbre 4T3T1T min_supp FREQT stockage liste positions fréquents améliorer processus extraction contexte situe notre proposition décrite section Proposition cette section proposons nouveaux algorithmes permettant extraction arbres fréquents ordonnés données arborescentes premier temps décrivons structure adoptée soulignons intérêts second temps proposons survol notre approche extraction montrons comment propriétés structure utilisées améliorer processus fouille Finalement décrivons formellement algorithmes proposés illustrer propos utiliserons arbres figure Représentation arbres représenter différents arbres manipulés notre approche adoptons représentation proposée arbre ainsi décrit vecteurs comme proposé Weiss premier nommé conserve position chaque nœuds arbre numérotés profondeur abord racine correspond index valeur indiquer racine Recherche structures fréquentes intégration schémas forêt arbres exemple racine droite structure étiquettes feuille représentation arbre valeurs correspondent positions nœuds comme illustré figure Cette représentation permet retrouver temps constant permet localisation directe feuille droite rapport index parcourant arbre ainsi possible obtenir toutes relations directes entre nœuds deuxième vecteur nommé utilisé enregistrer étiquettes arbre représentant étiquette chaque structure adoptée permet représentation arbres coûteuse puisqu possède propriétés intéressantes évoquées paragraphe suivant pouvant utilisées recherche structures fréquentes Aperçu général Notre proposition basée approche classique générer élaguer chaque étape générons différents candidats testons inclus bases arbres inclusion notre entendu définie comme étant induit méthode représentation arbres proposons permet générer manière efficace arbres candidats élaguer arbres fréquents après calcul support Transformation arbre après génération Considérons présent comment candidats générés candidats taille abord obtenus parcourant nœuds arbres données Chaque support incrémenté parcours seuls conservés nœuds support supérieur support minimal défini utilisateur données alors transformée conserver nœuds fréquents comme illustré figure branche droite Génération candidats candidats taille générés combinant fréquents taille génération candidats taille effectue manière proches classiques Apriori Agrawal Srikant combinaison fréquents taille adoptons stratégie génération candidats selon branche droite comme proposée illustrée figure pouvons ainsi constater intérêt notre structure représentation puisque naturellement suffit ajouter nouvel élément représentation arbre spécifiant nouveau calcul support chaque candidat consiste compter nombre arbres contiennent arbre candidat Ainsi chaque arbre recherchons points ancrage lesquels racine arbre tester instancier points correspondent nœuds arbre correspondent racine arbre tester chaque point ancrage trouvé cherche alors instancier ensemble nœuds arbre candidat arbre courant testé tester Notons inclusion induite recherchons instanciation exacte candidat arbres nœuds candidat trouvés arbre supporte candidat support structure candidate alors incrémenté algorithmes algorithme Algorithme fonctionne manière suivante premier parcours réalisé extraire items nombre occurrences supérieur minimal items constituent arbres résumés seule racine considéré obtenons ainsi ensemble arbres fréquents taille derniers combinés entre former candidats taille parcours permet obtenir semble constitué arbres taille algorithme poursuit générant candidats taille effectuant parcours compter nombre occurrences chaque candidats Lorsque aucun candidat généré algorithme termine algorithme GenCandidats Algorithme décrit génération candidats utilise branche droite arbres fréquents taille proposer candidats taille chaque arbre fréquent taille génère nouveau candidat étendant arbre branche droite Cette génération obtenue intermédiaire fonction Ainsi chaque ajoutons seules extensions possibles celles avèrent fréquentes Recherche structures fréquentes intégration schémas Entrée données arbres minimal Sortie arbres fréquents arbres fréquents taille arbres fréquents taille faire GenCandidats chaque faire Support alors retourner Algorithme Entrée arbres fréquents Sortie arbres candi chaque faire chaque faire chaque faire alors retourner Algorithme GenCandidats Entrée candidat Sortie Support candidat chaque faire faire alors Ancre alors retourner Algorithme Support Entrée candidat arbre racine ancrage Sortie supporte nbnœuds Nniv_act NœudsNivSuiv while Nniv_act Poursuit Nniv_act nbnœuds Nniv_act NœudsNivSuiv Nniv_act nbnœuds alors retourner sinon retourner Algorithme Ancre calcul support chaque candidat consiste compter nombre arbres contiennent arbre candidat chaque arbre recherche effectuée existe points ancrage lesquels racine arbre tester instancier appel algorithme Ancre arbre existe nombre occurrences alors incrémenté support retourné Considérons algorithme gestion points ancrage Algorithme chaque point ancrage trouvé chaque arbre candidat possède label arbre cherche instancier ensemble nœuds arbre candidat arbre couramment testé autres termes souhaitons projeter arbre candidat arbre réalisé intermédiaire algorithmes Ancre Poursuit algorithmes algorithme Poursuit utilisé chercher instanciation exacte candidat arbres nœuds candidat trouvés algorithme retourne alors valeur arbre supporte candidat retourne valeur nœuds arbre parcourus trouver ensemble nœuds candidat Algorithme Poursuit Nniv_act nbnœuds Entrée Nniv_act ensemble nœuds trouver arbre nbnœuds nombre nœuds vérifiés Sortie nœuds Nniv_act trouvés chaque Nniv_act faire alors nbnœuds nbnœuds Nniv_act alors retourner sinon retourner Algorithme Poursuite recherche Expérimentations expérimentations réalisées Pentium ayant système Linux programmes développés compilés avons utilisé bases données construites employant programme généra arbres proposé Termier programme propose différents ramètres spécifier nombre arbres générer profondeur nombre étiquettes maximales différentes valeurs utilisées générations expérimentations indiquées tableau Paramètres Valeurs Nombre arbres générer Profondeur maximal arbre Nombre maximal branches Nombre maximal étiquettes Arbres fréquents semés générée Probabilité Paramètres construction données synthétiques Recherche structures fréquentes intégration schémas avons souhaité évaluer notre proposition selon aspects temps réponse occupation mémoire effet argumentons notre proposition comme étant efficace passage échelle toujours synonyme efficacité temps réponse expérimentations réalisées prouvent notre proposition répond critères évaluer performances temps exécution sommes comparés algorithme FREQT détection duplicats permettant rechercher inclusions induites optimisation celui FREQT limitant parcours arbres vérification candidats figure représente occupation mémoire utilisée représentation schémas Comme attendions occupe moins espace mémoire puisqu adopte structure représentation réduite FREQT FREQT derniers adoptent structure figures indiquent temps exécution obtenus FREQT différents supports différentes tailles schémas pouvons constater obtient meilleurs résultats Taille données x1000 FREQT min_sup 10000 100000 Taille données x1000 FREQT min_sup 10000 100000 Taille données x1000 FREQT min_sup 10000 Taille données x1000 FREQT min_sup Temps exécution rapport taille FREQT analysant résultats indiqués figure comparant FREQT FREQT avère temps exécution nettement améliorés FREQT obtenu terme espace mémoire comparer temps exécution tenus optimisation basée stockage informations supplémentaires comme indiqué paragraphe souhaitons présent mettre œuvre optimisation parcours structure proposée améliorer performances terme temps exécution telle optimi sation réalisable constitue perspectives principales devrions alors obtenir performances supérieures celles obtenues FREQT conser structure 10000 100000 Taille données x1000 FREQT FREQT min_sup 10000 Taille données x1000 FREQT FREQT min_sup Mémoire Temps exécution FREQT FREQT Conclusion perspectives article proposons approche efficace extraction arbres quents première proposition recherche arbres fréquents selon clusion induite représentation schémas premières expérimentations réalisées données synthétiques soulignent intérêt notre propo sition rapport approches référence perspectives immédiates concernant suivent abord possible améliorer algorithme optimisant parcours réalisés vérification candidats comme proposé optimisation FREQT Toutefois souhaitons mettre place procédé moins coûteux terme espace mémoire Ensuite souhaitons utiliser structure représentation arbres réaliser recherche arbres fréquents basant inclusion incrustée travaux objectif utilisés cadre médiation données arbres fréquents extraits servant support construction automatique schéma médiateur telle solution également adoptée cadre fouille ligne streams traitement volée données Cette perspective permettra traiter volumes données transitant Internet manière efficace rapide Recherche structures fréquentes intégration schémas Références Agrawal Srikant septembre algorithms mining association rules large databases Proceedings Conference Santiago Chile Kawasoe Arimura Sakamoto Efficient substructure covery large structured Proceedings Annual Symposium Mining Arlington Muntz Indexing mining trees Proceedings International Conference Mining Florida Muntz CMTreeMiner Mining closed maximal frequent subtrees Proceedings Eighth Pacific Conference Knowledge Discovery Mining PAKDD Sydney Australia Laurent Teisseire Représentation efficace arborescences recherche structures fréquentes Actes atelier Fouille données complexes Conférence Extraction Gestion Connaissances Termier Rousset Sebag TreeFinder first towards mining Proceedings Conference Mining Tranier Baraer Bellahsene Teisseire Where family based heuristics schema integration Proceedings International Database Engineering Applications Symposium IDEAS Coimbra Portugal Chopper efficient algorithm mining Journal Computer Science Technology Weiss Structures Algorithm Analysis Xylème dynamic warehouse Engineering Bulletin Efficiently mining frequent trees forest Proceedings SIGKDD Conference Edmonton Alberta Canada Summary research mediator schema schemas current problem where results stemming mining databases adopted context several propositions proposed methods representation databases often memory consuming querying volumes paper propose rithm research frequent structures based original method representation schemas describe structure adopted algorithms research frequent trees leaning structure