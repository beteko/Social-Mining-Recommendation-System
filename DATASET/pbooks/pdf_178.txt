Fouille motifs séquentiels Thomas Guyet Moinard Quiniou Torsten Schaub AGROCAMPUS OUEST IRISA Saint Brieuc 35042 Rennes Inria Centre Rennes Bretagne Atlantique Université Potsdam Allemagne Résumé article présente utilisation programmation ensembles réponses répondre tâche fouille motifs séquentiels syntaxe proche Prolog langage pertinent présenter connaissances manière aisée mécanismes résolution basés solveurs efficaces solution alternative approches programmation contraintes fouille déclarative motifs proposons premier encodage tâche classique extraction motifs quentiels variantes motifs maximaux comparons performances calculatoires encodages approche programma contraintes performances obtenues inférieures approches programmation contraintes encodage purement déclaratif offre perspectives intégration connaissances expertes Introduction extraction motifs pattern mining consiste identifier motifs intéressants données structurée extraction motifs séquentiels données structurée forme ensemble séquences itemsets exemple séquences achats tâche extraction motifs consiste identifier ensemble séquences apparaissent fréquemment séquences fréquence suffisante définie seuil mesure intérêt classiquement utili motifs permet concevoir algorithmes efficaces recherches algorithmique conduit proposer méthodes extraction séquentiels efficaces elles mesure extraire motifs grandes bases données seuils fréquences méthodes heurtent maintenant profusion motifs devenu problème analystes place noyés données trouvent noyés motifs nouveau méthodes fouille motifs extraire moins motifs pertinents mesure intégrer connaissances expertes processus extraction motifs telles connaissances exprimées forme contraintes portant exemple forme motifs extraire contraintes taille motifs forme leurs occurrences contraintes séquences Fouille motifs séquentiels ensemble motifs patterns Ugarte intégra contraintes nécessite modifier parfois significativement algorithme fouille utilisation nouvelle contrainte motifs ainsi conduire effort temps développement important analyste pratique analyste limitera outils tants fortement limité expression connaissances domaine Notre objectif développer approche permette expert domaine tégrer connaissances riches connaissance algorithmes extraction connais sances riches domaine portent exemple fonctionnement systèmes jacents données Flouvat illustrent principe proposant système extraire motifs appliqué érosion modèle physique érosion intro évaluer intérêt motifs extraits système riche requiert conception dédiée assurer fonctionnement algorithmes approche haite mettre œuvre suffisamment expressive représenter grande variété contraintes grande variété systèmes solution envisagées article utiliser approche déclarative ticulièrement programmation logique intégrer connaissances processus extraction motifs travaux portant utilisation approches programmation contraintes partie développées objectif plupart travaux développés cadre fouille itemsets travaux récents intéressés fouille séquences Negrevergne Coquery Métivier applicabilité réside efficacité encodage problème fouille travaux montré telle approche pouvait approcher performances algorithmes dédiées outils programmation logique conçus représenter raisonner connaissances offrent expressivité importante syntaxe naturelle celle programmation contraintes paradigme programmation logique Answer Programming programmation ensembles réponses dispose cette grande expressivité appuie solveurs contraintes résoudre programmes manière efficace Lifschitz Järvisalo montré cette approche pouvait viable fouille motifs article mettons évidence problème extraction motifs séquen tiels variantes motifs maximaux peuvent encodés manière purement décla rative analysons performances computationnelles approches comparant celles approche programmation contraintes Answer Programming Principes programmation ensembles réponses forme programmation déclarative basée sémantique modèles stables manière générale programme compose spécification nérale problème autre description instance problème données entrée serviront résolution concrète Guyet spécification problème effectue moyen ensemble formules logiques premier ordre règles similaires clauses programme Prolog Lallouet modèle assignation valeur vérité chacun atomes programme solution programme ensemble modèles minimaux appelés ensembles réponses contredisent aucune règles programme modèles minimaux effectivement Exemple exemple dessous illustre syntaxes règles rencontrées gramme résolvant problème coloration graphe lignes décrivent tance problème graphe nœuds numérotés entre nœuds couleurs lignes décrivent problème coloration graphe ligne indique modèle contenir atome forme color couleur atomes décrivent coloration Cette règle comme règle choix engendre espace recherche problème ligne règle exprimer contrainte intégrité impose modèle nœuds voisins peuvent avoir couleur symbole dénote conjonction description instance problème résolution problème coloration couleurs color color color ensemble color color color color color color solution programme dessous principe ensemble solutions possibles exprimé règles choix programme résolution consiste explorer ensemble modèles évaluer contraintes celui modèles respectent ensemble contraintes donnés comme ensembles réponses résolution problème assurée efficacement grâce solveurs spécifiques Lifschitz présentent analogies fortes mécanismes programmation contraintes suite logiciels Potassco moteurs actuels résolution programmes appuient solveurs contraintes efficaces pratique utilisons outil clingo Gebser performances remarquables syntaxe respecte standard outil clingo décompose résolution programme parties distinctes instanciation grounding consiste propositionnaliser programme écrit syntaxe premier ordre programme transformé clauses proposi Potassco potassco sourceforge Standard unical aspcomp2013 ASPStandardization Fouille motifs séquentiels tionnelles clauses optimisation exprimant contraintes modèles tions résolution consiste trouver toutes solutions programme tancié clasp solveur suite Potassco solveur MaxSAT résolution utilise approche dirigée conflits algorithme appuie prentissage nogood utilise défaut heuristique vsids adaptée besoins problème résolution contrôlée langages procéduraux particulier Python Cette fonctionnalité utile automatiser traitements récupérer statistiques résolution problèmes ensemble outils disponibles ainsi efficacité reconnue solveur préférer appuyer cette suite logicielle plutôt outils alternatifs Leone ASPeRiX Lefèvre Nicolas Extraction motifs séquentiels cette section rappelle définitions classiques extraction motifs séquen tiels partir séquences ensemble premiers entiers ensemble types items ordre total lexico graphique itemset ensemble ordonné items distincts itemset itemset existe suite entiers telle séquence suite ordonnée itemsets longueur séquence notée nombre itemsets composent séquence séquence existe suite entiers telle préfixe alors Exemple Soient ordre lexicographique quence simplifier écriture parenthèses omises autour itemsets comprenant longueur séquences séquences préfixes Propriété relation ordre partiel ensemble séquences séquences support séquence nombre séquences supportent Propriété mesure monotone ensemble séquences relation Guyet Cette propriété implique toute paire séquences avons support minimum défini analyste séquence séquence fréquente motif séquentiel fréquent extraction motifs séquentiels consiste extraire motifs séquentiels fréquents séquences propriété monotonie propriété usuellement utilisée algorithmes extraction motifs élaguer efficacement espace recherche effet motif fréquent inutile explorer motifs définition tâche extraction motifs fréquents accompagne générale tâches extraction motifs maximaux motifs motif fréquent maximal backward maximal relation motif fréquent motif fréquent backward relation aucun autre motif Extraire ensemble motifs réduit significativement nombre motifs perdre informations ensemble motifs fréquents Programme extraction motifs séquentiels manière similaire Järvisalo programmes dessous basent modèle motif ensemble réponse motif fréquent complet correct programme explorer motifs possibles contraintes exprimées doivent vérifiées uniquement motif fréquent suite présente évalue programmes tâche extraction motifs séquentiels séquences items itemsets contenant toujours séquences itemsets Cette limitation permet présentation pédagogique programmes extension général itemsets aisée Représentation séquences séquencesD représentée moyen atomes prédicat exemple atome déclare présent séquence position manière similaire motif associé modèle décrit atomes prédicat indique motif contient position définit également constantes programme const seuil fréquence nombre occurrences const maxlen longueur maximale motifs Encodage extraction motifs séquentiels programme présente programme extraction motifs séquentiels mière ligne effectue projection séquences extraire ensemble items contient Fouille motifs séquentiels lignes engendrent espace recherche elles permettent crire motifs séquentiels possibles longueur inférieure maxlen cette ration ensemble atomes prédicat patpos représentent liste entiers consécutifs longueur inférieure maxlen Toute longueur inférieure maxlen possible primée absence nombres autre accolade prédicat patlen déter cette longueur ligne ligne engendre motifs proprement génération atomes chaque position unique atome choisi parmi ensemble items possibles lignes garantissent complétude exploration motifs taille inférieure égale maxlen génération liste items génération motifs séquentiels patpos patpos patpos maxlen patlen patpos patpos patpos occurrences motif contrainte fréquence support patlen count support Listing Programme extraction motifs séquentiels occurrences seconde partie programme lignes recherche occurrences motif quentiel séquence prédicat représenter occur rence identifiant séquence position séquence position motif liste atomes prédicat décrit correspondances entre items motif itemsets séquence construction telles listes écrit récursivement efficace initialement ligne cherche correspondance entre premier motif position séquence lorsqu identifié correspondance entre motif position itemset position séquence cherche toutes possibilités trouver position motif itemset position postérieure Cette représentation occurrences nommée identifie toutes occurrences possibles motif unique séquence uniquement première noter occurrence séquence trouvée séquence seulement atome généré modèle longueur motif Cette propriété assure correction approche Finalement lignes ajoutent contrainte fréquence motifs atome support vérifié occurrence motif trouvée séquence ligne ajoute contrainte spécifiant modèle conservé nombre atomes prédicat support inférieur constante programme section Guyet recherche alternative occurrences Contrairement approches utilisent méthodes dédiées vérifier séquence supporte motif approche proposée purement déclarative réaliser cette tâche solveur proposons encodage alternatif améliorer formances globales programmes support patlen seqlen Listing Recherche occurrences programme propose méthode alternative réaliser recherche occurrences atomes toujours utilisés créer correspondance entre items motif itemsets séquence Néanmoins sémantique différente indique lorsqu premiers itemsets séquence reconnu items motif séquentiel séquence position items longueur motif alors séquence supporte motif ligne encodage évite énumération toutes occurrences possibles Extraire motifs maximaux cette tâche difficulté réside principalement processus lution utilisé clingo traite modèles manière indépendante mécanismes siques résolution permettent comparer motifs encodage motifs maximaux appuyer propriétés propres motif Motifs maximaux définition section implique comparer motifs reformule nitions exprimer notion motif maximal programmes modèle motif ensemble réponse motif fréquent maximal motif séquence telle supporte existe ensemble suites entiers telles suffixe séquence séquence telle argminp suffixe partie séquence situe après position dernier première occurrence motif motif séquentiel fréquent backward maximal fréquent monotonie supporté séquence alors aussi déduit avoir backward maximal moins séquences supportées suffixe contienne autre intersection suffixes séquences supportées motif encodage introduit prédicat suffix indique trouve suffixe séquence supportée première ligne listing dessous construit clingo permet résolutions incrémentales pouvant tenir compte contraintes monotones entre modèles ASPRIN Brewka couche clingo permet écrire préférences entre modèles Fouille motifs séquentiels atomes prédicat encodage occurrences programme seconde ligne définit contrainte maximalité motifs suffix patlen count support suffix construction occurrences programme atomes prédicat suffix construites règle dessous cette règle désigne position laquelle dernier élément occurrence trouvé avant incluant position dernier élément suffixe lorsqu trouve position suffix patlen Motifs définition motif référence également autres motifs contrainte maximalité nouvelle définition utilisée exprimer cette contrainte motif motif grand exactement support contrainte monotonie forcément avoir apparaît suffixes toutes séquences supportées règle dessous ajoutée règles production atomes suffix section cédente extrait uniquement motifs reprend propriété précédente éliminant modèles lesquels nouvel trouve suffixe toutes séquences couvertes Cette règle simple écriture utilise expression usuelle vérifier propriété ensemble atomes donné programme contraint avoir atomes suffix vrais toutes séquences supportées motif suffix support Expérimentations résultats objectif expérimentations comparer performances limites temps calcul mémoire différents programmes comparer approche programmation contraintes Negrevergne tâche résolue similaire nôtre approche déclarative recherche occurrences réalisée propagateur dédié point référence naturel ayant comparé algorithmes dédiés lecteur pourra comparer performances approches dédiées reportant travail Expérimentations données réelles données utilisés expérimentations utilisés caractéristiques données tableau chacun données résolutions lancées différents seuils alternatives recherche occur rences types résolution testés kuleuven CP4IM Guyet Caractéristiques données nombre symboles nombre séquences items longueurs maximale moyenne séquences densité Dataset density 10935 75646 98163 20450 741092 extraction motifs séquentiels extraction motifs séquentiels maximaux extraction motifs séquentiels extraction motifs séquentiels maximaux utilisation heuristique subset minimal extraction motifs séquentiels heuristique subset minimal heuristique subset minimal indique solveur motif trouvé alors inutile explorer motifs généraux utilisation cette heuristique conséquence complétude extraction motifs maximaux revanche utilisation extraction motifs fréquents extraction conduit extraire ensemble Chaque exécution lancée serveur disposant quantité mémoire fisante environ requis données threads unique processeur timeout 3600s timeout atteint toujours possible comparer performances temps comparant nombre motifs extraits temps Finalement évalue usage mémoire programmes évaluant quantité règles atomes nécessaires instanciation programme Résultats ensemble résultats illustré Figure constate abord approche ordre grandeurs lente approche constate différence autant importante séquences longues approche rement déclarative utilisons compétitive utilisation propagateurs identification occurrences motif séquence Cette différence importante difficile séquences longues particulier résolutions constate utilisation recherche donne meilleurs résultats explique limitation évaluation multiple occurrences séquence aussi réduction significative taille problème encodé particulier données dense comme constate utilisation cette stratégie efficace différence entre temps calcul différentes tâches extraction maximaux nette globalement indiquer extraction motifs efficace celle encore celle items partie explication résultats réside nombre ensemble réponse moins maximaux motifs revanche efficacité besoin mémoire Fouille motifs séquentiels heuristic noneoption closure maximal noneprog Threshold heuristic option closure maximal Mining Threshold heuristic option closure maximal Mining Threshold heuristic option closure maximal Mining Threshold heuristic option closure maximal Mining Threshold heuristic option closure maximal Mining Threshold heuristic option closure maximal Mining Threshold heuristic option closure maximal Mining Threshold heuristic option closure maximal Mining Threshold heuristic option closure maximal Mining Threshold heuristic option closure maximal Mining Threshold heuristic option closure maximal Mining Threshold heuristic option closure maximal Mining gauche droite taille problème mémoire temps calcul nombre motifs extraits temps calcul donnés résolutions complètes avant timeout revanche nombre motifs extrait donné résolutions chaque graphique courbes comparent résultats obtenus différents programmes approches légende Guyet supplémentaire augmentation taille problème encodé également noter maximaux mémoire moindre Finalement noter utilisation heuristique subset minimal montre efficace Cette heuristique autant intéressante résolution reste complète extraction motifs maximaux constatations similaires peuvent faites partir courbes représentants nombre motifs extrait quasiment motifs séquentiels fréquents finalisé avant timeout seuils élevés courbes différentes approches suivent indiquant ensembles motifs mêmes constate courbes approchent seuils finalement constater usage mémoire relativement indépendant seuil utilisation recherche problème instanciation programme étape charge mémoire programme solveur seuils seuils élevés Conclusions perspectives article présente solution effectuer fouille motifs séquentiels expériences montrent abord approche résolution permet attaquer données réelles efficacité réduite notre approche provient principalement encodage purement déclaratif recherche occurrences programmes présentés constituent premières approches possible améliorer perspectives amélioration visent encoder propriétés additionnelles tâche fouille faciliter résolution acception générale tâche fouille séquences laquelle sommes confrontés réputée calculatoire améliorations pratiques performances tendues tâche simple particulier extraction motifs séquentiels contraintes temporelles diminue manière importante calculs nécessaires ajout telles contraintes programmes présentés étape suivante notre travail montrer programmes peuvent intégrer connaissances expertes riches facilement exprimables aller extraction motifs pertinents Références Brewka Delgrande Romero Schaub asprin Customizing answer preferences without headache proceedings National Conference Artificial Intelligence Coquery Jabbour Salhi Based approach discovering frequent closed maximal patterns sequence proceedings European Confe rence Artificial Intelligence Flouvat Sanhes Pasquier Selmaoui Folcher Boulicaut Improving pattern discovery relevancy deriving constraints expert models Proceedings European Conference Artificial Intelligence Fouille motifs séquentiels Gebser Kaminski Kaufmann Ostrowski Schaub Schneider Potassco Potsdam answer solving collection Communications Dries Nijssen Raedt MiningZinc modeling language constraint based mining Proceedings international joint conference Artificial Intelligence IJCAI Järvisalo Itemset mining challenge application answer enumeration Proceedings conference Logic Programming Nonmonotonic Reasoning Lallouet Moinard Nicolas Stéphan Programmation logique Papini Prade Panorama intelligence artificielle bases métho dologiques développements Volume Cépaduès Lefèvre Nicolas first version solver ASPeRiX Procee dongs conference Logic Programming Nonmonotonic Reasoning Leone Pfeifer Faber Eiter Gottlob Perri Scarcello system knowledge representation reasoning Trans Comput Logic Lifschitz answer programming Proceedings Conference Artificial Intelligence Métivier Loudni Charnois constraint programming approach mining sequential patterns sequence database Negrevergne Constraint based sequence mining using constraint gramming Proceedings International Conference Integration niques Constraint Programming CPAIOR Mortazavi Pinto Dayal Mining sequential patterns pattern growth PrefixSpan approach Transactions Knowledge Engineering Sequential pattern mining Aggarwal Frequent Pattern Mining Springer International Publishing Ugarte Boizumault Loudni Crémilleux Lepailleur Découverte skypatterns approche Actes Journées Francophones Extraction Gestion Connaissances Summary article presents answers programming sequential patterns alternative constraint programming approaches patterns declarative manner Indeed syntax close Prolog relevant representing knowl solving process efficient propose first encoding sequential closed maximal patterns mining compare computational performances these encodings respect constraint programming approach performances obtained lower former purely declarative encoding offers perpectives expert knowledge integration