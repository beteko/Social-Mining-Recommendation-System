Contraintes prescriptives compatibles évaluer complétude ontologies Philippe Martin EA2525 University Réunion 97490 Sainte Clotilde France Philippe Martin reunion phmartin Adjunct researcher School Griffith University Australia School Griffith University SOUTHPORT Australia griffith Résumé article définit contraintes prescriptives comme règles permettant moteurs inférence vérifier certains objets formels réellement utilisés seulement inférés certaines conditions montre contraintes nécessitent exploiter mécanisme héritage autres mécanismes ajoutant relations objets durant tests conclusions règles donne méthode générale effectuer commandes SPARQL implémenter cette méthode lorsque règles représentées relations classe entre conditions conclusions article illustre commandes vérification patrons conception ontologies généralement approche utilisée vérifier complétude ontologie représenter ontologie plutôt requêtes procédures contraintes permettant calculer degré complétude ontologie approche ainsi aider élicitation modélisation validation connaissances Introduction représentations connaissances descriptions formelles permettant inférences logiques ainsi comparaisons automatiques recherches fusions formules logiques prédicats binaires logique ordre aussi appelés triplets instances propriété relations binaires Graphes Conceptuels article souci clarté utilisons terminologie intuitive objets information types individus types types relations types concepts classes types données connaissances formelle collection objets écrits langage ontologie portant essentiellement types Créer évaluer étant difficile tâches souvent évaluation degré complétude selon certains critères abréviation complétude telle évaluation effectuée diverses tâches manière différente suivant Contraintes prescriptives compatibles complétude ontologies outils parfois manière implicite exemples telles tâches domaines extraction automatique manuelle connaissances création exploitation modèles conception ontologies évaluation ontologies généralement données dernier domaine comme Zaveri complétude réfère communément degré présence informations requises satisfaire certains critères certaine requête informations trouvées référence complète degré estimé oracles complétude Galárraga règles requêtes permettant estimer manque répondre aussi hypothétique référence complète article adoptons cette définition générale légère extension précision requis représenté explicitement contraintes contraintes intégrité effet existe référence complète souvent utilisée directement existe oracles complétude peuvent moins partiellement implémentés exploitant contraintes avantageux représenter contraintes plutôt exemple requêtes requis faciliter exploitation réutilisation informations usage contraintes permet vérifier complétude importe moteur inférence pouvant exploiter contraintes implémentation effectuée simple vérification suffisante degré complétude recherché moyen simple définir précisément calculer diviser nombre faits satisfaisant contraintes nombre total faits Cette méthode basique rapport celles agrègent résultats oracles complétude sujet article Celui fournir moyen simple représenter contraintes vérifier SPARQL pouvoir évaluer calculer complétude section distingue contraintes descriptives contraintes prescriptives positives montre dernières peuvent représentées logiques classiques hypothèse monde fermé nécessaires vérifier complétude Cette section introduit ensuite types spéciaux indiquant certaines expressions contraintes méthode vérifier contraintes prescriptives ensemble Profils contraintes compatibles comme moyen simple représenter contraintes expressivité moins égale section montre comment cette méthode vérification contraintes prescriptives implémentée ensemble réduit commandes SPARQL section illustre exploitation commandes ainsi aussi limites compatibilité induit section compare notre approche autres évalue conclut Contraintes prescriptives compatibles Contraintes positives négatives descriptives prescriptives article comme Chein Mugnier contraintes peuvent positives négatives respectivement exprimer faits forme aussi Martin Comme Assmann Wagner modèles ingénierie peuvent descriptifs réalité plupart ontologies prescriptifs informations représentées doivent spécifications systèmes modèles schémas bases données Similairement distinguons sortes contraintes positives contraintes descriptives comme définitions axiomes permettent moteurs inférence vérifier utilisation certains termes formels utilisés contraintes prescriptives permettent moteurs inférence vérifier certains termes formels réellement utilisés seulement inférés utilisés certaines conditions contraintes prescriptives peuvent utilisées vérifier défini comme ayant nécessairement certaines relations relations explicitement données utilisateurs lorsqu créent instance explicitement signifie relations doivent simplement exister suite déduction automatique héritage parce elles créées utilisateur permettent utiliser contraintes permettent généralement spécifier contraintes prescriptives positives titre exemple supposons inclut règle personne parent définition toute personne nécessairement parent utilisateur ajoute personne cette contient aussi contrainte descriptive personne parent aucun message erreur généré puisque cette contrainte satisfaite inférence utilisateur décrire parent contre cette règle marquée comme prescriptive signifie personne avoir parent ajout personne relation parent alors refusé autres termes mécanisme associe automatiquement relations objets héritage dynamique statiquement saturation chaînage avant mécanisme adéquatement désactivé contourné vérifier contraintes prescriptives positives contraintes négatives descriptives prescriptives puisqu elles permettent détection incorrects aient ajoutés automatiquement contraintes prescriptives permettent ainsi vérifications autres contraintes descriptives elles équivalentes utilisation hypothèse monde fermé expressions logiques classiques seulement descriptives comme dessus indiquer toute personne nécessairement parent seulement descriptif règles marquées comme représentant contraintes prescriptives positives nécessitent interprétation spéciale commande procédure spéciale Méthode générale types contraintes prescriptives montrent représenter vérifier contraintes intégrité exploitant certaines formes hypothèse unique hypothèse monde fermé effectué requêtes SPARQL requête différente chaque contrainte différente Notre plutôt permettre représentation contraintes utilisé augmenter possibilités exploitation réutilisation contraintes quelques requêtes SPARQL prédéfinies souhaitons aussi surtout prendre compte contraintes prescriptives notre approche introduire types contraintes reliant types relations instance créateurs peuvent signifier contraintes Ainsi elles peuvent retrouvées Contraintes prescriptives compatibles complétude ontologies interprétées manière spéciale moteur inférence ontologie similairement utilisée augmenter expressivité notre ontologie types contraintes cette ontologie Constraint supertype types contraintes Similairement Prescriptive_constraint Constraint permet retrouver spécifier seulement contraintes prescriptives Constraint_via_types supertype types contraintes représentent relations entre types dernier instance ordre Type_of_constraint_via_types Indiquer Constraint_via_types suffisant spécifier toutes définitions aussi contraintes éviter héritage plutôt indiquer instance Type_of_constraint_via_types partie identifiants abréviation espace webkb vérification adéquate contraintes prescriptives positives section introduit nécessité temporairement désactiver contourner mécanismes inférence associant automatiquement relations objets Toutefois mécanismes utiles vérifier objet vérifie condition contrainte prescriptive positive Ainsi doivent désactivés contournés principal alias objet conclusion cette contrainte objet relations obligatoires objets satisfaisant condition contrainte proposons méthode contournement suivante statiquement traitement dynamiquement vérification telles contraintes créer clone chaque objet vérifiant condition telle contrainte vérification conclusion effectuer clone clone mêmes relations original relations instance individu anonyme avoir identifiant différent objet original clone inférences exploitant types associer relations objet évitées abrévier écrirons désormais cette méthode permet éviter héritage Cette méthode fonctionne inférences exploitant types celles basées typage canard plutôt héritage saturation chaînage avant automatiquement effectuée avant traitement dessus rares Cette méthode repose modification temporaire avant vérification moteur inférence Ainsi cette méthode repose indépendante moteur inférence particulier Ainsi différent domaines applications moteurs inférence différents peuvent utilisés vérifier évaluer complétude ontologies certains langages requête versions actuelles SPARQL modification temporaire effectuée dynamiquement traitement nécessaire limitation serveurs autorisent plupart leurs utilisateurs modifier vérifier Contraintes compatibles Comme contraintes règles particulières comme souhaitons représenter contraintes manière simple indépendante notations particulières avons abord considéré Profils Celui entièrement défini règles définies égalité Datalog ensemble purement déclaratif Prolog Cependant telles règles conclusion Martin inclure objets anonymes existentiellement quantifiés possible règles existentielles Datalog Baget montrent langage nomment représenter nombreuses sortes règles existentielles suffixe simplement utilisant relation subClassOf entre expressions classe expression superclasse représentant conclusion règle autres termes relation subClassOf exprimée notation fonctionnelle traduite manière suivante notation Peano Russel logique ordre correspond partie Datalog pouvant exprimée utilisant seulement ensemble seulement relations binaires variables partagées condition conclusion règle contrainte négative représentée manières expression classe équivalente Nothing conclusion règle règle forme ClassExpression NegativeObjectPropertyAssertion exprimer négation forme ClassExpression Datalog peuvent directement représenter contrainte positive comme expliqué section exprimé spécifiant règle instance Constraint article contraintes toujours représentées règles exploitons forme négative citée dessus utilisant relations subClassOf façon simple quoique restrictive représenter règles Baget montrent traduit Datalog représenté Datalog RuleML RuleML deliberation Comme elles exploitent relations subClassOf techniques peuvent travailler importe ayant moins expressivité permettant réutiliser dernier point expression contraintes compatibles autres termes techniques exigent moins utilisé exploitées serait pertinent article donner détails formalisation représenter règle relation subClassOf implique Baget offrent exploration formelle implique article SPARQL section suivante fournit détails formels nécessaires article formalisation contraintes prescriptives autres celle donnée SPARQL serait utile contraintes compatibles pourraient généralisées utilisant relation relation subClassOf entre condition conclusion contrainte Conformément terminologie donnée introduction permettrait utilisation types relations données seulement classes condition conclusion contrainte Cependant vérification objets relations instances types données souvent effectuer contraintes instances classe liées objets relations peuvent généralement vérifiées leurs sources destinations chaque portant relations chaque instanciation NegativeObjectPropertyAssertion article utilisons relations subClassOf entre conditions conclusions contraintes signifier expression classe condition contrainte compatible ordre like_constraint_condition ordre Type_of_OWL2 like_constraint_condition proposés notre Contraintes prescriptives compatibles complétude ontologies ontologie utilisent respectivement comme indiqué types Constraint_via_types Type_of_constraint_via_types requêtes SPARQL article utilisent like_prescriptive_constraint_condition like_constraint_condition types ordre effet plupart moteurs inférence logiques description peuvent gérer exploitant types ordre prédéfinis logiques cette raison contraintes portant définitions doivent vérifiées moteurs inférence traitement individus requis classes ordre deviennent individus leurs relations doivent également retirées Inversement avant vérifier individus outils types ordre définis doivent supprimés exemples donnés Martin document associé article Commandes SPARQL exploitation contraintes prescriptives compatibles extensions SPARQL telle LDScript Corby commandes suivantes peuvent séquencées scripts fonctions SPARQL variables commencent article raisons clarté types relations débutent lettre minuscule tandis autres débutent majuscule Comme SPARQL réutilise notation Turtle Turtle utilisons aussi section forme Source Destination1_1 Destination1_2 Destination2_1 Destination2_2 Source Destination1_1 Destination1_2 Destination2_1 Destination2_2 Commande traitement retirant temporairement individus vérifier contraintes types moteurs inférences logiques description classiques clause WHERE commande dessous sélectionne chaque objet Class individu clause DELETE supprime relations depuis depuis leurs destinations supprime relations subClassOf lorsqu elles existent remplacer relations subClassOf clause INSERT ajoute relations subClassOf effet elles signification particulière moteur inférence gênent appariement objets classes inférence relations Enfin elles permettent affirmer relations subClassOf initiales commande similaire DELETE subClassOf superClass INSERT subClassOf superClass WHERE subClassOf superClass FILTER EXISTS Class Commande traitement créant clones objets exploiter objets mécanisme héritage SPARQL fournit moyen supprimer héritage exécution requête permet sélectionner régime inférence SPARQL entailments particulier requête Toutefois Martin méthode contournement héritage donnée section implémentée SPARQL commande dessous fournit exemple souci clarté supposé contient ordre chaque objet objet individu commande copie partielle mêmes relations moins relations Cette copie partielle identifiant celui suffixe _cloneWithoutType Cette commande relie aussi relation cloneWithoutType Martin montre extension SPARQL telle Corby Faron Zucker utile effectuer traitement commande seule commande nécessite requête CONSTRUCT inclue requête SELECT permettre ainsi création clones volée INSERT cloneWithoutType WHERE FILTER FILTER EXISTS Class concat _cloneWithoutType Commande vérification contraintes prescriptives positives Cette commande requête liste objets violant contrainte prescriptive positive Comme montre objet satisfait conditions abord apparié avoir condition contrainte posConstr classe like_prescriptive_constraint_condition Nothing conclusion ailleurs objet apparié avoir conclusion contrainte superclasse Ainsi cette requête nécessite moteur SPARQL régime inférence permettant appariement alias catégorisation individu rapport expression classe déduction relation entre commandes dessous chaque ligne utilisant telle déduction finit commentaire débutant appariement exemple individus conditions contraintes conclusions contraintes décrits régime inférence requis suffisant moteur inférence capable gérer expressivité requis SELECT objectNotMatchingPosConstr posConstr WHERE corps cette seconde commande entre premier dernier posConstr subClassOf like_prescriptive_constraint_condition posConstr_conclusion initialisation posConstr FILTER EXISTS posConstr subClassOf Nothing contrainte négative objectNotMatchingPosConstr posConstr appariement condition FILTER EXISTS objets satisfaisant conclusion listés objectNotMatchingPosConstr posConstr_conclusion appariement Commande vérification contraintes prescriptives négatives Cette requête liste chaque objet violant contrainte négative chaque objet appariant ayant negConstr intance Contrainte_in_OWL2 Nothing conclusion distinction entre descriptif prescriptif contraintes négatives cette requête simple précédente inutile moteur inférence utilisé appariement utilisé directement vérifier toute Contraintes prescriptives compatibles complétude ontologies SELECT objectMatchingNegConstr negConstr WHERE negConstr subClassOf like_constraint_condition Nothing objectMatchingNegConstr negConstr appariement Commande vérifier relations binaires individus lister relations binaires violant contraintes prescriptives plutôt lister individus ayant relations violant telles contraintes suffit remplacer relation relation implication entre formules logiques requêtes précédentes référer telle implication Berners utilise identifiant implies Berners remplacement fonctionne moteur SPARQL utilisé exploiter moteur inférence pouvant déduire existence telle implication quand existe entre formules appariées Comme requêtes individus celles relations peuvent utiliser filtres supplémentaires commande fonctionne seulement formules négatives ajouter corps objectMatchingNegConstr NegativeObjectPropertyAssertion appariement Commande évaluation complétude ontologie moyen simple définir calculer degré complétude diviser nombre relations violant contraintes prescriptives nombre total relations liées moins autre objet relations commande dessous recherche individus adaptée comme indiqué précédent paragraphe implémenter définition complétude dessus SELECT nbObjs nbAgainstPosCs nbMatchingNegCs nbObjs completeness SELECT COUNT DISTINCT nbObjs WHERE objet autre objet SELECT COUNT DISTINCT objectNotMatchingPosConstr nbAgainstPosCs WHERE corps commande copié SELECT COUNT DISTINCT objectMatchingNegConstr nbMatchingNegCs WHERE corps commande copié Exemples contraintes prescriptives ainsi exploitables construction hiérarchies types divers travaux recherche conseillent utiliser structures arbres Rector Martin montre utiliser partitions types structures arbre mêmes avantages moins inconvénients cette approche inutilement lourde classer types naturels catégoriser classes réutilisant Martin propose utiliser relations equivDisjointUnion subclassOfDisjointUnion nonNaturalSubclass types trois types définit trois types ainsi supertype commun Martin nonNaturalOrPartitionSubclass patron conception proposé alors vérifié contrainte prescriptive positive suivante existe relation classe entre classes cette relation nonNaturalOrPartitionSubclass contrainte équivalente classe relation classe classe cette relation nonNaturalOrPartitionSubclass permettant utiliser variable référer ladite relation version compatible classe relation classe avoir relation nonNaturalOrPartitionSubclass représentation Turtle dessous contourner ambiguité inhérente cette dernière version effectuer vérification voulue vérifier chaque objet utiliser commande directement vérifier chaque relation utiliser implies comme indiqué texte associé commande Subclass classe ayant classe condition contrainte associée subClassOf ER_prescriptive_constraint_condition equivalentClass définition condition contrainte Restriction classe classe onProperty subclass someValuesFrom Class subClassOf conclusion types relations doivent présents Restriction onProperty nonNaturalOrPartitionSubclass someValuesFrom Class Martin généralise cette contrainte types exploite vérification relation transitive exactement propose commande SPARQL génère ajoute contrainte chaque relation transitive instance certain types ordre certains moteurs inférence traitement effectuer temporairement supprimer types avant vérifier contraintes manière similaire Martin définit autre contrainte types exploite vérifier types relations instances certain systématiquement utilisés lorsque signature permet conditions données Évaluation comparaisons conclusion Notre approche permet représenter contraintes prescriptives expressivité moins égale permet exploiter importe moteur inférence compris requêtes SPARQL originalité contribution article avoir montré comment jusqu point moyennant quelles sortes traitements compenser limites SPARQL pourquoi possibilité représenter contraintes prescriptives plutôt requêtes procédures aussi possibilité réutiliser contraintes moteurs inférences diverse tâches liées vérification évaluation complétude construire possible utiliser contraintes prescriptives représenter patrons conception ontologies modèles tâches génériques utiliser moteur inférences vérifier complétude fonction résultats éliciter connaissance manquante auprès experts Notre approche difficile évaluer théoriquement puisqu repose autres méthodes outils hérite leurs avancées théoriques pratiques Baget Contraintes prescriptives compatibles complétude ontologies listent avancées théoriques pertinentes cette approche avons validé notre approche expérimentalement utilisant vérifier ontologies calculer degré complétude degré faible contraintes implémentant patrons conception connus section poursuivrons expériences ajouterons leurs analyses Martin concerne usage SPARQL vérifier contraintes montrent SPARQL utilisé exprimer valider contraintes intégrité utilisant formes partielles hypothèse monde fermé hypothèse uniques manière cohérente complète certaines conditions expressivité utilisée contraintes respectées notre approche requêtes servent valider contraintes exprimer généralisation approche change leurs résultats théoriques formes partielles hypothèse monde fermé uniques SPARQL spécifiables opérateurs EXISTS EXISTS SPARQL relations sameAs differentFrom formes peuvent similairement exprimer commandes section usage relations sameAs differentFrom contraintes Notre approche basée utilisation particulière comparée SHACL Shapes Constraint Language SHACL ontologie langage telle proposée permettre définir contraintes SHACL réutilise définir contraintes introduit nouveaux termes permet réutiliser vérifier contraintes moteurs inférence comprenant spécial termes moteur inférence dédié SHACL utilisé nouveau SHACL appris SHACL distinction entre contraintes descriptives prescriptives traite partiellement dernières effet SHACL permette spécifier régime inférence utilisé quelle contrainte compris absence inférence insuffisant régime expressif nécessaire apparier objets condition contrainte prescriptive conclusion héritage effet supprimé Enfin flexibilité langage SPARQL traitements permet atteinte SHACL exemples contraintes section semblent pouvoir représenter SHACL Certains langages systèmes transformation exploitent Zamazal Svátek Corby Faron Zucker présentent systèmes Quoique entre permettent utiliser directement fonction appariement motifs aussi transformer appariés PatOMat Zamazal Svátek exception langages systèmes pourraient adaptés avoir telle fonction ainsi utilisés gérer contraintes prescriptives Toutefois notre connaissance systèmes utilisent langages expressifs utilisent généralement langages basés règles permettant usage variables relier objets partagés condition conclusion règle Utiliser langages simplifier écriture contraintes prescriptives Cependant concernant exprimé vérifié contraintes prescriptives article Martin montrent beaucoup réalisé simplement utilisant SPARQL puissance notre approche puissance moteur inférence utilisé appariements seulement langage utilisé Martin Certains systèmes transformation PatOMat Zamazal Svátek génère requêtes SPARQL détecter motifs basées spécifications motifs leurs transformations autre langage Certains autres systèmes transformation offrent directement extension SPARQL telle Corby Faron Zucker écrire spécifications motifs leurs transformations comme montré Corby combiné LDScript spécifier requêtes compilées requêtes SPARQL détectant modèles transformer résultats Toutefois Corby mentionnent exploitation moteurs inférence apparier objets distinction entre contraintes descriptives prescriptives commandes SPARQL compris celles générant contraintes prescriptives pourraient utilement réutilisées systèmes transformation forme adaptée allons explorer utilisant LDScript Références Assmann Wagner Ontologies models Model Driven Paradigm Ontologies Software Engineering Software Technology Springer Baget Gutierrez Leclère Mugnier Rocher Sipieter Datalog RuleML Formats Translations Existential Rules Challenge RuleML Berlin Germany Berners Connolly Kagal Scharf Hendler N3Logic Logical Framework World Theory Practice Logic Programming Chein Mugnier Graph based Knowledge Representation Computational Foundations Conceptual Graphs Springer Corby Faron Zucker SPARQL based Transformation Language WEBIST International Conference Information Systems Technologies Lisbon Portugal Corby Faron Zucker Gandon LDScript Linked Script Language International Semantic Conference Vienna Austria Corby Faron Zucker Gazzotti Validating Ontologies Against Profiles SPARQL Template Transformation Language Reasoning Systems Springer Galárraga Razniewski Enabling completeness aware querying SPARQL WebDB Chicago Martin Compatible Prescriptive Constraints Evaluate Ontology pleteness webkb o_knowledge d_constraints_owl2er Profils Ontology Language Profiles Second Edition Recommendation December profiles Schema Recommendation February schema Contraintes prescriptives compatibles complétude ontologies Rector Brandt Drummond Horridge Pulestin Stevens Engineering cases modular development ontologies Applied Ontology RuleML deliberation Deliberation RuleML ruleml index Specification_of_Deliberation_RuleML_1 SHACL Shapes Constraint Language SHACL Recommendation shacl Conceptual Graphs Summary Conceptual Structures Current Research Practice Ellis Horwood SPARQL entailments SPARQL Entailment Regimes Recommendation March sparql11 entailment Querying Existential Knowledge Bases Decidability Complexity thesis University Montpellier Sirin McGuinness Integrity constraints Press Turtle Turtle Terse Triple Language Recommendation February turtle Zamazal Svátek PatOMat Versatile Framework Pattern Based Ontology Transformation Computing Informatics Zaveri Maurino Pietrobon Lehmann Quality Assessment Linked Survey Semantic Journal Summary article defines prescriptive constraints rules enabling inference engines check certain formal objects inferred certain conditions shows these constraints require exploiting inheritance mechanisms other mechanisms automatically adding relations objects during tests conclusions gives general method SPARQL commands implement method rules represented subclassOf relation condition conclusion article illustrates these commands check ontology design patterns generally approach check completeness ontology represent constraints ontology rather requests procedures calculate degree ontology completeness approach elicitation modeling validation knowledge