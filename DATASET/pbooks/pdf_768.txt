actes_non_num 351rotes créativité calculatoire heuristiques créatives synthèse prédicats multiples Marta Kodratoff Équipe Inférence Apprentissage 91405 Orsay France Résumé présentons approche appelons créativité calculatoire procédés lesquels machine faire montre certaine créativité article montrons essentiellement synthèse prédicats multiples programmation logique inductive synthèse programmes partir spécifications formelles domaines informatique attaquent problèmes notion créativité centrale amenés ajouter formalisme tableaux autre toute série heuristiques article présente collection heuristiques destinées fournir programme forme créativité calculatoire cette présentation accent plutôt heuristiques lorsque était possible longs développements avons aussi présenté quelques heuristiques outil indispensable créativité calculatoire appelons générateur atouts spécification forcément informelle comme verrons fournie comme première conclusion exemples décrits corps article Introduction Motivations article présenter exemple trivial méthodologie créativité commencer tracer grandes lignes pourrait appeler pompeusement créativité calculatoire sujet avons abordé Franova domaine remonte travaux Newell Simon décrit Boden Cependant article destiné aborder domaine montrer comment informaticiens spécialisés programmation logique inductive synthèse programmes partir spécifications formelles affronté problèmes posés synthèse prédicats multiples problèmes ainsi posés nature récursive exigent programmation sorte créativité voulons donner quelques exemples problèmes difficiles programmation logique inductive celui synthèse partir exemples prédicats multiples mutuellement dépendants articles Raedt 1993a Raedt Lavrac analysé difficultés rencontrées résolution problème donné courant recherche illustré nombreux travaux articles auteurs cités après pourra aussi Martin Vrain Zhang Numao Fogel Zaverucha problème communauté Créativité calculatoire synthèse prédicats multiples exactement appelons problème récursif effet confondre programmation récursive consiste écrire façon récursive solution connue problème récursif solution problèmes récursifs justement connaît encore solution suppose créativité différente celle programmation récursive illustrer propos donnons principe exemple simplifié détermination point phrase texte compréhension nécessite connaissance ressort mêmes mécanismes distinguer point phrase point partie abréviation nécessaire combiner sources information point final erreur frappe parlons toujours accolé suite lettres constituant connu suivi blanc autre suivi blanc paragraphe parlons précédant immédiatement débutant majuscule commence souvent minuscule autres parties texte possible écrire procédures reconnaissance point phrase autre débutant toujours majuscule appel autre prendre décision mesure connaissons spécification formelle connu commençant normalement minuscule problème écrire programme récursif sujet problème rechercher spécification problèmes dépendants autre façon récursive constituant problème récursif autres résoudre problème récursif point final majuscule inattendue thèse Heitz propose solution itérative problème récursif exemple celui génération automatique prédicats mutuellement dépendants système Malerba Cette définition paraître surprenante force récursion préférence donnée relations utilisant seule fonction successeur alors devient naturelle simple exemple montre preuve créativité incontestable rapport définitions scolaires montrer heuristiques réservées constituent créativité calculatoire fournirons forme exemples simplifiés possibles équivalent heuristique domaine Après spécification formelle assimilée suite infinie exemples contre exemples permettant obtenir preuve formelle équivalence entre spécification programme synthétisé approche classique Raedt Lavrac semblable contente fournir suite finie exemples contre exemples preuve informelle équivalence programme couvre exemples couvre contre exemples rechercher synthétiser prédicats multiples augmente complexité tâche programmes façon beaucoup dramatique prévoir comme montré Raedt 1993a tâche comprend synthèse plusieurs prédicats évident difficultés centrales ordre lequel prédicats synthétisés primordial cependant difficile maîtriser rassemblons heuristiques trois grands groupes méthodes généralisation particularisation accroissement connaissance domaine background knowledge découverte nouvelles connaissances atouts relatives domaine intuition évidemment seule découverte atouts réellement créative calculatoire illustrer créativité calculatoire combinaison trois groupes méthodes généralisation particularisation mesure exemples instanciés évident programmes prédicats synthétiser sortes généralisations instances insisterons sujet abondamment traité littérature excepté signaler heuristiques différentes peuvent utilisées abord construction clauses possibles utilise techniques généralisation combine celles spécialisation Ensuite quand clauses synthétisées choisir celles conserver définissant notion couverture mesure intérêt méthode classique objet nombreuses variations celle Quinlan mesure entropie apporté chaque clause synthétisée fournit système exemples exemples positifs négatifs entropie départ ensemble exemples Quand synthétisé clause constater cette clause satisfaite exemples positifs exemples négatifs entropie associée différence valeurs mesure entropique associé clause Cette formule classiques diriger déplacement programmes apprentissage automatique espace hypothèses possibles illustre notre propos façon partielle chaque système inductif selon nature données traite utiliser heuristique spéciale déplacer espace hypothèses exemple Kijsirikul développé mesure intérêt combine entropie distance syntaxique entre atteindre transformation opérée équivalent logique cette heuristique encore trivial démontre lemmes théorèmes ordre lequel présentent cours démonstration preuves récurrence utilisent aussi heuristique triviale prouver abord général Quand limite synthèse prédicat cohérence chaque nouvelle hypothèse suggère adjonction seule clause testée exemples contre exemples Quand passe synthèse prédicats multiples continuer utiliser cette procédure chaque prédicat hypothèse multiple conçoit logique tester cohérence constituant hypothèse celle entre Cependant cette forme entrecroisement toutes démonstrations augmente évidemment complexité calculatoire pourquoi résoudre problème analyse images Esposito conduits introduire appellent stratégie recherche separate parallel conquer search reprend classique séparer conquérir exécute plusieurs conquêtes parallèle précisément séparer conquérir classique conquiert apprend seule clause rajoute Créativité calculatoire synthèse prédicats multiples connaissances sépare élimine exemples couverts cette clause reprend ensuite processus exemples restants stratégie Esposito généralisation couvre exemple spécialisations permettant éviter couvrir exemples négatifs examinées parallèle Chaque spécialisation utilise heuristique choisir spécialisation adjoindre couvrir moins contre exemples possibles Toutes spécialisations couvrant aucun exemple négatif candidates devenir clause synthétisée Augmenter connaissance domaine abord distinguer façon précise connaissance domaine création atouts connaissance domaine recueil toutes connaissances sujet problème exemple simple connaissance possibilité relations récursives connaissance générale domaine exemple moins simple utiliserons suite propriété classique récurrence Péter supposons étudie relation partiellement fausse variable entrée celle sortie suggère construction récursive nouveau prédicat comme verrons appliquant hypothèse induction trouve valeur alors écrire récursivement forme connaissances domaine généralement exprimées version quelconque rasoir Occam Inversement création atouts constitue partie réellement créative synthèse prédicats découvrir structures encore inconnues données décrirons évidemment masse connaissances implicites suppose existence poser question synthèse automatique programmes partir exemples thème développé façon approfondie créateurs Pazzani Kibler sujet général prédicats multiples Giordana façon implicite systèmes apprentissage inductifs utilisent appelle biais apprentissage limiter taille espace clauses système apprendre biais nature multiple intéressant décrire biais donnés forme syntaxique forme clauses recherchées trouve exemple approche article Baroglio Botta auteurs introduisent templates associés prédicats synthétiser donnent exemple prédicats binaires auxquels associent entre autres template suivant permet prendre compte prédicat différent nécessaire expression cherchent synthétiser Brazdil Jorge introduisent notion sketch forme intuitive évidente impose liens entre variables constituent partie importante solution Découvrir nouvelles connaissances relatives domaine atouts Inclure connaissances connaissance synthétisée pratiqué général programmes clauses nouvellement apprises rajoutées connaissance clauses connues classique supprimer alors exemples couverts clause vient ajouter assure ainsi convergence système arrête quand exemples positifs couverts Cependant aussi possible aussi rajouter exemples apprentissage faits ground facts déduire clauses synthétisées principe Jorge Brazdil nomment iterative bootstrap induction entendu complique beaucoup déroulement programme puisque faits doivent ajoutés chaque hypothèse nouvelle rétractés chaque clause enlevée connaissances détection chemins relationnels relational pathfinding Richards Mooney introduit cette notion chercher résoudre problème rencontré quand nécessaire ajouter plusieurs littéraux clause pouvoir observer entropie problème particulièrement grave quand plusieurs prédicats synthétisés ensemble solution consiste rechercher graphe relations exprimées exemples graphe caractéristique relation donnée celle prédicat synthétiser présentent heuristique permet utiliser mieux connaissances constitue évidemment solution générale problème trouver graphes graphe donné Supposons cours démonstration besoin prouver prédicat binaire prédicat synthétiser instances présentes exemples reliées entre elles aucune relation connue ayant ensemble relations supposées binaires compliquer exemple connues autres instances Rappelons exemples étant constituée exemples instanciés parlons valeurs instances comme exemple relations familiales propres individus constituant famille heuristique développée Richards Mooney consiste considérer chemins définis chemins partiels créent chemin entre Alors liens entre constitués suite ordonnée opérateurs forme suppose chemin exemple remplaçant instances variables maintenant entre instances obtient facilement prédicat ajoutée connaissance permettra prouver nécessite encore prédicat unaire forcément oublié cours heuristique nécessitera autre heuristique évoquons paragraphe suivant avons moins obtenu première suite prédicats nécessaires ensemble pouvoir observer entropie chemins partiels créent chemin entre procédé itéré sommets libres encore relations instances utilisées Créativité calculatoire synthèse prédicats multiples précédemment plusieurs chemins trouvés encore servir mesure entropie séparer Quand cette heuristique réussit évidence structure présente données importante suite preuve exemple appelons atout donnerons définition générale conclusion analyse échecs exemple récupération échecs synthèse prédicats multiples fourni Kijsirikul Zelle Supposons soyons situation échec parce manque clause prédicat présent ensemble exemples déterminer prédicat ajouter clause couvre encore exemples négatifs utilisée prouver exemples positifs négatifs obtient ainsi liste instances appartenant preuve couvre exemples positifs liste instances appartenant preuve couvre exemples négatifs analysant différences entre instances souvent possible mettre évidence prédicat différencie allons maintenant développer détail méthodes récupération échecs Rappelons quelques principes fondamentaux application preuves récurrence synthèse programmes formule simple puisse avoir démontrer forme Cette formule détermine fonction Skolem associée valeur calculée cette fonction Skolem quand applique variable autres termes quantificateurs leurs associés attribue sémantique variable entrée celle variable sortie problème trouver vérifie trouver preuve constructive Faire preuve récurrence consiste analyser appelle général appliquer général appelle hypothèse induction allons restreindre considérer arithmétique entiers naturels contexte formule simple partons comporte conditions général fonction successeur hypothèse induction formule vraie alors prouver vraie écrit introduisant fonctions Skolem Supposons alors puisse prouver trouve formule vérifiée Comme première illustration notion récupération échec supposons encore général capable trouver fonction telle condition condition sorties constitue échec preuve récurrence effet imposer conditions variable sortie encore calculer alors conditions auraient incluses heuristique réaction échec proposons construire programme qualifions hypothétique disons inspiré savons comporte condition espère entendu cette espérance déçue faits bataille terminée allons contenter illustrer abord simple Cette illustration issue preuves relatives fonction Ackermann publiées Anonyme lecteur devra admettre certains calcul exposés détail ailleurs calculs amènent chercher prouver cherche résoudre équation solution général après calcul assez aperçoit prouver lemme sommes conduits tenter preuve induction autre variable entrée obtenons général posons obtenons pouvions prouver aurions ainsi obtenu formule récursive calcul sommes incapables faire sommes échec preuve récurrence Comme avons allons construire fonction hypothétique éliminera condition variable sortie utilisons savons construire fonction définie prouve alors présente mêmes relations récursives aussi cette propriété récupération erreurs consiste preuve erreur existe réalité complexes amener génération prédicats comme allons maintenant Comme seconde illustration méthode récupération échecs considérons problème construction prédicat partir formule partiellement fausse Considérons formule suivante analyse cette formule cours tentative preuve récurrence montre partiellement fausse preuve échoue Comme Zelle supposons alors existe prédicat hypothétique permettra caractériser vraie construire utilisons échec preuve condition implique considérant formule constate solutions partielles ainsi conditions échec fournissent propriétés prédicat hypothétique général prouver utilisons systématiquement heuristique conseille étudier solutions dites triviales problème utiliser encore hypothèse induction obtenons solutions triviales ainsi fournit nouvelles propriétés utilisons alors explicitement hypothèse induction trouvons aucune condition logique propriétés récursives Péter permet alors tirer propriété récursive Créativité calculatoire synthèse prédicats multiples propriétés venons construire définissent complètement prédicat obtenons preuve conditions auxquelles vérifiée abduction méthode proposée Kakas résoudre problème synthèse prédicats multiples consiste modifier technique preuve utilisant programmation logique abductive Kakas Denecker heuristique proprement parler changement cadre logique étonnant ayons proposer équivalent évident définition fournie Kakas propose associer programme logique habituel ensemble prédicats incomplètement définis appelés abductibles ensemble constantes intégrité assurant inférences abductibles restent cohérentes donne possibilité ajouter négation échec utilisée programmation logique négation défaut façon suivante chaque symbole prédicatif utilisé associe négation non_pred ajoute ensemble contraintes intégrité contrainte non_pred dérivation logique consiste seulement conclure obtenir comme abduction classique ensemble prédicats constituent explication abductive preuve Cette approche illustre inventivité preuve communauté tenter résoudre problème synthèse prédicats multiples partir exemples Quand avons collecté échecs preuve formule avons utilisé approche semblable beaucoup moins formalisée celle Kakas travail formalisation reste faire Conclusion générateur atouts générateur atouts décrit comportement humain automatisé actions enchaînent conduites stratégies elles mêmes définies informellement impossible donner définition formelle complète générateur atouts Voici abord définition formelle atout aurons compléter façon informelle Définition formelle incomplète Etant donnés théorie formelle indécidable éventuellement incomplète théorème premier atout entendu réussir démontrer théorème obtenu analyse échec preuve théorème premier Cette analyse conduire trouver trois différentes causes échec chacune conduisant stratégie reprise différente Premièrement souvent partie connue théorie doamine oubliée récupérée manuels domaine spécialité concerné Deuxièmement lemme particulier classique aurait nécessaire atout conséquence théorie exprimée sorte élimine échec auquel vient heurter Troisièmement théorie incomplète atout complète théorie juste assez rendre prouvable théorème premier Voici maintenant commentaires informels décrivent partir cette définition générateur atouts abord imaginons humain placé situation prouver théorème théorie indécidable abord tenter démontrer directement théorème premier partir théorie Supposons excellent mathématicien échoue trouver preuve moins preuve difficile impossible commencer processus lequel combiner principe stratégies première stratégies consiste rechercher manque effectuer preuve aider intuition connaissance preuves constructives connaissance théorie formelle propriétés affirmées théorème prouver Cette partie comportement humain appelons stratégies choix atouts permet trouver théorèmes indécidables serviraient effet prouver notre théorème Cependant notre expérience montré savons simuler moment cette partie comportement humain deuxième stratégies consiste engendrer théorèmes décidables partir théorie examiner attribuer probabilité succès chacun théorèmes savoir intervenir quelque preuve constructive théorème prouver article illustre plusieurs techniques dérivation atouts utilisées Définition informelle précise générateur atout stratégie preuve définie informellement signifié esprit mathématicien stratégie preuve automatique Etant donnés théorie formelle indécidable théorème premier appelons générateur atouts entendu réussir démontrer théorème premier stratégie preuve présentant propriétés suivantes engendre atouts définition maillons preuve constructive théorème premier engendre atouts seront faciles démontrer théorème premier engendre suite potentiellement infinie atouts alors existe toujours généralisation possible suite finie obtenue cette généralisation censée représenter suite infinie prolonge suite finie obtenue pratique spécification informelle condition formulée plutôt comme exclusion suites infinies générateur atouts engendrer suite infinie atouts constatons générateur atout prétention assurer atteindra preuve formelle théorème premier simplement stratégie donné résultats intéressants construction automatique programmes semble constituer stratégie adaptée besoins utilisateurs aider mieux gérer problèmes récurrence rencontrent activité programmation application réelle toutes techniques paraît beaucoup probable cadre programmation assistée ordinateur difficiles intuitifs atouts connaissance domaine avons définis atouts comme connaissances inventées cours preuve clair connaissance domaine absente problèmes poser Créativité calculatoire synthèse prédicats multiples façon totalement différente particulier impossible découvrir atouts nécessaires exemple fournit selon favorise création définitions récursives définitions récursives croisées obtient résultats extrêmement différents complexité preuves connaissance domaine moins évident mettre évidence façon claire travail désirons entreprendre exemple propriété découverte notre méthodologie article montrer combien notre méthode puissante plutôt combien simple pourquoi exemples décrits peuvent paraître convaincants illustrer conduire résultats créatifs voici exemple problème encore résolu autant sachions fonction Ackermann habituellement définie récurrence premier argument Appelons cette définition Cette définition étant tellement utilisée avons curiosité savoir était possible trouver définition fonction Ackermann récurrente rapport second argument découvrir cette définition avons inspirée notre méthodologie tenter prouver lemmes suivants évidemment tentons prouver directement puisque toute façon ignorons définition inventée cours preuve lemmes preuve récursive premier lemme exige fonction auxiliaire celle second exige autre fonction auxiliaire Finalement fonction définie Cette solution exige autres fonctions auxiliaires Maintenant cette définition trouvée systèmes preuve théorèmes peuvent essayer prouver Notre méthodologie aussi prouvé inventant constatez définition fortement semblable celle notre nouvelle définition malgré beaucoup influencée définition classique présentait intérêt particulier faudrait rechercher autres lemmes moins évidents trouver autres définitions empêche définition complètement nouvelle fonction Ackermann trouvée preuve complète longue exige utilisation complète notre méthodologie Références Denecker Abductive inductive logic programming Proceedings fourteenth International Joint Conference Artificial Intelligence Baroglio Botta Multiple Predicate Learning Topic Artificial Intelligence Foundations Mathematics Amsterdam Boden Computational models creativity Handbook Creativity Sternberg Cambridge University Press Brazdil Jorge Learning Refining Algorithm Sketches European Conference Artificial Intelligence Raedt Lavrac Dzeroski 1993a Multiple Predicate Learning Proceedings thirteenth International Joint Conference Artificial Intelligence Raedt Lavrac Dzeroski 1993b Multiple Predicate Learning Proceedings third International Workshop Inductive Logic Programming Raedt Lavrac Multiple Predicate Learning Inductive Logic Programming Settings Esposito Malerba Multiple Predicate Learning Document Image Understanding Proceedings Fourteenth American Association Artificial Intelligence Conference Fogel Zaverucha Normal Programs Multiple Predicate Learning Proceedings International Workshop Inductive Logic Programming Lecture Notes Computer Science Franova Kodratoff Gross Constructive Matching Methodology Formally Creative Intelligent Inductive Theorem Proving Komorowski Methodologies Intelligent Systems ISMIS Springer Verlag Franova Construction Definition Recursive respect Second Variable Ackermann function paraître comme rapport recherche interne Orsay France Giordana Saitta Baroglio Learning simple recursive theories Methodologies Intelligent Systems Komorowski Springer Verlag Berlin Heitz méthode récursive prétraitement textes Thèse Université Paris Jorge Brazdil Architecture iterative learning recursive definitions Advances Inductive Logic Programming Créativité calculatoire synthèse prédicats multiples Kakas Lamma Riguzzi Learning multiple predicates AIMSA Artificial intelligence methodology systems applications Lecture Notes Computer Science Kijsirikul Numao Shimura Efficient learning logic programs determinate discrimonating literals Machine Learning Conference Kaufmann Kijsirikul Numao Shimura Discrimination based constructive induction logic programs Proceedings tenth National Joint Conference Machine Learning Malerba Esposito Learning Recursive Theories Proceedings Thirteenth European Conference Artificial Intelligence Martin Vrain MULT_ICN empirical multiple predicate learner International Workshop Newell Simon Human Problem Solving Prentice Pazzani Kibler Utility Knowledge Inductive Learning Machine Learning Péter Recursive Functions Academic Press Richards Mooney Learning Relations Pathfinding Proceedings Tenth National Conference Artificial Intelligence Cambridge Press Zelle Mooney Konvisser Combining Bottom Techniques Inductive Logic Programming Machine Learning Proceedings Eleventh International Conference Zhang Numao Efficient Multiple Predicate Learner Based Failure Mechanism Journal Japanese Society Artificial Intelligence Summary present computational creativity whole methods which computer simulate creativity paper restricted multiple predicate learning Inductive Logic Programming Programs Synthesis their Formal Specification called paper These subfields Computer Science problems where creativity primary importance their basic formalism tableaus heuristics enabling program solve problem Multiple Predicate synthesis paper shows heuristics which provide program inventiveness presentation insist possible relatively short describe heuristics