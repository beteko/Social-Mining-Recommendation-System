actes_non_num 351rotes Binary Sequences Association Graphs Detection Sequential Patterns Selim Mimaroglu Simovici Bahcesehir University Istanbul Turkey selim mimaroglu gmail University Massachusetts Boston Massachusetts 02125 Abstract develop efficient algorithm detecting frequent patterns occur sequence databases under certain constraints combining vector representations sequence databases association graphs achieve superior memory usage based considerable reduction number candidate patterns Introduction Mining sequential patterns originally proposed Agrawal Srikant where three algorithms AprioriAll AprioriSome DynamicSome introduced PrefixSpan based prefix projection introduced SPADE performs space efficient joins prefix based equivalence classes PRISM Gouda prime number encoding support counting related distinct problem discussed Mannila finding frequent episodes sequences Ayres finds sequential patterns using bitmap representation extension which incorporates regular expression constraints achieved algorithm Srikant Agrawal similar AprioriAll additionally handle three types constraints minimum maximum between consecutive elements sequence referred min_gap max_gap window between min_gap max_gap window_size sequential patterns found classical sequential patterns introduced Agrawal Srikant algorithm cSPADE introduces similar constraints implemented SPADE SPIRIT Garofalakis general cSPADE deals regular expression constraints describe algorithm combines vector resentations sequence databases association graphs achieve superior performance identifying patterns sequences Apriori Frameworks Sequence refer reader Simovici Djeraba mathematical concepts tions items sequences items consider graded poset where referred terns defined sequence sequences sequence Apriori framework triple where relation between terns implies Detection Sequential Patterns subsequence denote define several partial functions number occurrences function measures outer while measures inner fixed scattered relatively small relatively large another condensed relatively large relatively small example a1a3a4a5a2 a3a4a1a2a5 values functions changed expected because condensed database sequence sequences infix suppose partial functions relation consists those pairs which there exists currence least between consecutive symbols least Similarly consists pairs which there occurrence largest between consecutive symbols These relations introduced Srikant Agrawal relationsσα given Apriori relations Apriori relation infix suppD allows straightforward extension knownApriori algorithm algorithm defined sequences Association Graphs Vectors Storing vectors space efficient bitwise operations which allows storing large databases memory distinct database represented vector denoted vector which contains number database present entry otherwise table contains distinct items represented collection vectors whose length equals length occurs position otherwise vectors speeds mining process considerably providing support count similar vector representation PRISM Gouda where prime number encoding integer operations instead binary operations define association graph sequence database Definition sequence database items min_sup minimum support count Apriori relation association graph Mimaroglu Simovici labeled directed graph defined follows vertices consists those items min_sup edges consists those pairs min_sup labeled quence where otherwise Input Database format minimum support count min_sup Apriori relation Output Association graph Create vertices foreach check constraint suppcount min_sup then2 Create edges labels foreach foreach count min_sup then7 vectors compute suppcount min_sup then8 label ibvii vectors compute suppcount min_sup then11 label output Association Graph Construction Algorithm implementation KFrequentC class represents frequent sequences stores members sequence vector which indexes containing sequence containing sequence there occurrence position length extend sequence there member frequent association graph Since length there exists component other frequent association graph Initially ibvpz obtained ibvpz ibvpiz count ibvpz min_sup Detection Sequential Patterns Input Database minimum support count min_sup Apriori relation Output Frequent Sequences database convert items format convert format1 Create association graph using Association Graph Construction2 Algorithm while ibvpz ibvpiz min_sup pruneσ vectors information KFrequentC compute following Compute Sequential Pattern Mining Association Graph Algorithm Since Apriori relation sequences infix frequent violates condition means frequent either pruneσ returns false Figure these steps represented Following actual frequent sequences computed candidate shown Figure vectors positions follows violating order constraint ibvpz Checking order constraint every database where ibvpz initially procedure count ibvpz min_sup placed Ayres vectors operations vectors combines vectors association graphs allows vital global information Finding occurrences items immediate using vectors addition association graphs handle follow improves candidate pattern generation process considerably Neither Ayres global information provided vectors association graphs therefore track Moreover tremendous amount vector transformations Ayres memory inefficient avoids these difficulties working original vectors without modifying Experimental Results Extensive experiments conducted synthetically generated sequential Pentium computer having memory running Linux results compared SPADE implementation which refer cSPAM cSPADE shown SPADE outperforms using space efficient joins Although cSPAM space efficient because vectors cSPAM Mimaroglu Simovici handle constraints cSPADE implemented SPADE handle constraints Experimental results outperforms SPADE cSPADE cSPAM almost every support level every Figures execution times small database medium database large database large database Minimum Maximum comparison cSPAM SPADE cSPAM SPADE shown synthetic databases range having items average total distinct items superior performance every support level these performs SPADE support level cSPAM outperforms cSPAM comparable cases remaining cases performs better Detection Sequential Patterns cSPAM Experiments expanded include larger having unique items items average results shown cases outperforms SPADE factor shows cSPADE perform similarly minimum constraint times faster cSPAM cases clearly outperforms cSPAM cSPADE considerably maximum constraint illustrated Figure Conclusions Future present efficient algorithm detecting frequent patterns which combines vector representations sequence databases association graphs perimental results faster other state algorithms cSPAM SPADE cSPADE constraints without constraints believe broader applicability determining variability patterns frequency terns shall investigated References Agrawal Srikant Mining sequential patterns Proceedings Eleventh International Conference Engineering Ayres Flannick Gehrke Sequential pattern mining using bitmap representation Garofalakis Rastogi Spirit Sequential pattern mining regular expression constraints Gouda Hassaan Prism prime encoding approach frequent sequence mining Conference Mining Lukov Chawla Sequential pattern mining constraints large protein databases Proceedings International Conference Management COMAD 2005b Computer Society India Mannila Toivonen Inkeri Verkamo Discovery Frequent Episodes Event Sequences Mining Knowledge Discovery Mortazavi Pinto Dayal PrefixSpan Mining Sequential Patterns Efficiently Prefix Projected Pattern Conference Engineering Simovici Djeraba Mathematical Tools Mining Theory Partially Ordered Combinatorics London Springer Verlag Srikant Agrawal Mining sequential patterns Generalizations perfor mance improvements Sequence mining categorical domains Incorporating constraints Spade efficient algorithm mining frequent sequences Machine Learning Résumé développons algorithme efficace détecter motifs fréquents duisent bases données séquentielles certaines contraintes combinant utilisation représentations bases données séquentielles séquences binaires graphes association obtenons meilleur temps utilisation moins grande mémoire basée réduction considérable nombre motifs candidates